[CHUNK 1 OF 2]
BUNDLE_0_CORE - PART 1
Concatenate all chunks in order to reconstruct.

[NOTDEAFBEEF BLOCKCHAIN BUNDLE - BUNDLE_0_CORE]
=============================================================
Core system: seed + extraction script + build script + small audio voices
Generated for on-chain storage following deafbeef methodology.

[MANIFEST]
Bundle: bundle_0_core
Total files: 9
Files included:
  - seed.s (1382 bytes)
  - extract_files.py (2258 bytes)
  - build.sh (3946 bytes)
  - audio/kick.s (2454 bytes)
  - audio/snare.s (3705 bytes)
  - audio/hat.s (2961 bytes)
  - audio/melody.s (3721 bytes)
  - audio/delay.s (2904 bytes)
  - audio/limiter.s (4222 bytes)

Reconstruction: Save each file to its path and build with provided instructions.

=== FILE: seed.s ===
---BEGIN---
; NotDeafBeef - Transaction Hash Seed Placeholder
; ==================================================
; This file contains the token's unique seed that drives all generation.
; 
; INSTRUCTIONS FOR USERS:
; 1. Get your token's seed: call getTokenParams(tokenId) on the contract
; 2. Replace the SEED_HEX string below with your 64-character hex seed
; 3. Keep the "0x" prefix and quotes
; 4. Compile and run the complete pipeline
;
; The seed determines ALL audio and visual characteristics of your NFT.
; Same seed = identical NFT every time (deterministic generation).

.section __DATA,__data
.align 3

; REPLACE THIS LINE: paste your token's 64-character hex seed here
; Example: SEED_HEX: .ascii "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\0"
SEED_HEX: .ascii "PASTE_YOUR_TOKEN_SEED_HERE_FROM_CONTRACT_getTokenParams\0"

; Alternative format: 32 bytes as 4 64-bit values (little-endian)
; Users can choose either hex string above OR replace these 4 lines:
.global SEED_BYTES
SEED_BYTES:
    .quad 0x0000000000000000  ; bytes 0-7   - REPLACE WITH TOKEN SEED
    .quad 0x0000000000000000  ; bytes 8-15  - REPLACE WITH TOKEN SEED  
    .quad 0x0000000000000000  ; bytes 16-23 - REPLACE WITH TOKEN SEED
    .quad 0x0000000000000000  ; bytes 24-31 - REPLACE WITH TOKEN SEED

; Export symbols for use by other assembly files
.global SEED_HEX
.global SEED_BYTES

---END---

=== FILE: extract_files.py ===
---BEGIN---
#!/usr/bin/env python3
"""
NotDeafbeef Source File Extractor
=================================
Extracts all files from concatenated blockchain chunks.
Part of the on-chain source code bundle.
"""
import os
import re

def extract_files():
    print("🔧 Extracting NotDeafbeef source files...")
    print("")
    
    if not os.path.exists('complete_source.txt'):
        print("❌ complete_source.txt not found!")
        print("   First run: cat chunk_*.txt > complete_source.txt")
        return False
    
    with open('complete_source.txt', 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Find all file sections using regex
    files = re.findall(r'=== FILE: (.+?) ===\n---BEGIN---\n(.*?)\n---END---', content, re.DOTALL)
    
    if not files:
        print("❌ No files found in complete_source.txt")
        print("   Make sure all chunks were concatenated correctly")
        return False
    
    print(f"📁 Found {len(files)} files to extract:")
    print("")
    
    extracted_count = 0
    for filepath, filecontent in files:
        try:
            # Create directory if needed
            if '/' in filepath:
                dir_path = os.path.dirname(filepath)
                os.makedirs(dir_path, exist_ok=True)
            
            # Write file
            with open(filepath, 'w', encoding='utf-8') as out:
                out.write(filecontent)
            
            file_size = len(filecontent.encode('utf-8'))
            print(f"✅ {filepath} ({file_size:,} bytes)")
            extracted_count += 1
            
        except Exception as e:
            print(f"❌ Failed to extract {filepath}: {e}")
    
    print("")
    if extracted_count == len(files):
        print(f"🎉 Successfully extracted all {extracted_count} files!")
        print("")
        print("📋 Next steps:")
        print("   1. Edit seed.s - replace PASTE_YOUR_TOKEN_SEED_HERE with your actual seed")
        print("   2. Run: ./build.sh")
        print("   3. Generate your NFT!")
        return True
    else:
        print(f"⚠️  Extracted {extracted_count}/{len(files)} files - check for errors above")
        return False

if __name__ == "__main__":
    success = extract_files()
    exit(0 if success else 1)

---END---

=== FILE: build.sh ===
---BEGIN---
#!/bin/bash
# NotDeafbeef Reconstruction Build Script  
# ========================================
# This script is included in the on-chain source code.
# Users run this after downloading and extracting all chunks.

set -e

echo "🎵 NotDeafbeef - Building ARM64 Assembly Audio-Visual Engine"
echo "============================================================="
echo ""

# Check for ARM64 architecture
ARCH=$(uname -m)
if [[ "$ARCH" != "arm64" && "$ARCH" != "aarch64" ]]; then
    echo "⚠️  WARNING: This system requires ARM64 architecture"
    echo "   Current architecture: $ARCH"
    echo "   Required: arm64 (Apple Silicon) or aarch64 (ARM64 Linux)"
    echo ""
    echo "💡 Try running on:"
    echo "   - Apple Silicon Mac (M1/M2/M3)"
    echo "   - ARM64 Linux system"
    echo "   - ARM64 cloud instance"
    echo ""
    read -p "Continue anyway? [y/N] " -r
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
fi

# Check for required tools
echo "🔧 Checking build dependencies..."

check_tool() {
    if command -v "$1" &> /dev/null; then
        echo "✅ $1 found"
    else
        echo "❌ $1 not found - please install"
        return 1
    fi
}

MISSING_TOOLS=0
check_tool gcc || MISSING_TOOLS=1
check_tool make || MISSING_TOOLS=1 
check_tool ffmpeg || MISSING_TOOLS=1

if [[ $MISSING_TOOLS -eq 1 ]]; then
    echo ""
    echo "📦 Installation commands:"
    echo "  macOS:   brew install ffmpeg"
    echo "  Ubuntu:  sudo apt install build-essential ffmpeg"
    exit 1
fi

echo ""

# Check if seed has been set
if grep -q "PASTE_YOUR_TOKEN_SEED_HERE" seed.s; then
    echo "🚨 SEED NOT SET!"
    echo ""
    echo "❌ You must replace the seed placeholder in seed.s"
    echo ""
    echo "📋 Instructions:"
    echo "   1. Get your seed: call getTokenParams(tokenId) on the contract"
    echo "   2. Edit seed.s file"
    echo "   3. Replace 'PASTE_YOUR_TOKEN_SEED_HERE' with your 64-char hex seed"
    echo "   4. Keep the quotes and 0x prefix"
    echo "   5. Run this script again"
    echo ""
    echo "💡 Example:"
    echo '   SEED_HEX: .ascii "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\0"'
    exit 1
fi

# Extract the seed for use in generation
SEED=$(grep 'SEED_HEX:' seed.s | sed 's/.*"\(0x[^"]*\)".*/\1/')
echo "🎯 Using seed: $SEED"
echo ""

# Build the audio-visual engine
echo "🔨 Building ARM64 assembly components..."
echo ""

# Build audio engine
echo "🎵 Building audio synthesis engine..."
make -C src/c segment USE_ASM=1 VOICE_ASM="GENERATOR_ASM KICK_ASM SNARE_ASM HAT_ASM MELODY_ASM LIMITER_ASM FM_VOICE_ASM"

# Build visual engine  
echo "🎨 Building visual rendering engine..."
make generate_frames

echo ""
echo "✅ Build complete!"
echo ""

# Generate the NFT
echo "🚀 Generating your unique audio-visual NFT..."
echo "   This may take 2-5 minutes depending on your system..."
echo ""

OUTPUT_DIR="./nft_output"
mkdir -p "$OUTPUT_DIR"

./generate_nft.sh "$SEED" "$OUTPUT_DIR"

echo ""
echo "🎉 NFT Generation Complete!"
echo "================================"
echo ""
echo "📁 Your files:"

if [[ -f "$OUTPUT_DIR/${SEED}_final.mp4" ]]; then
    SIZE=$(ls -lh "$OUTPUT_DIR/${SEED}_final.mp4" | awk '{print $5}')
    echo "🎬 Video: $OUTPUT_DIR/${SEED}_final.mp4 ($SIZE)"
fi

if [[ -f "$OUTPUT_DIR/${SEED}_audio.wav" ]]; then
    SIZE=$(ls -lh "$OUTPUT_DIR/${SEED}_audio.wav" | awk '{print $5}')
    echo "🎵 Audio: $OUTPUT_DIR/${SEED}_audio.wav ($SIZE)"
fi

if [[ -f "$OUTPUT_DIR/${SEED}_metadata.json" ]]; then
    echo "📋 Metadata: $OUTPUT_DIR/${SEED}_metadata.json"
fi

echo ""
echo "✨ Your NotDeafbeef NFT has been reconstructed from pure on-chain code!"
echo "   Share your MP4 - others can verify it by running this same process."
echo ""
echo "🔗 Verification:"
echo "   Same seed + same code = identical output (cryptographically verifiable)"
echo "   Your artwork is mathematically unique and permanently reproducible."

---END---

=== FILE: audio/kick.s ===
---BEGIN---
	.text
	.align 2
	.globl _kick_process

// --- Constants ---
AMP_const:
    .float 0.9            // overall amplitude (reduced from 1.2 - was too loud)

// Offsets inside kick_t struct (see kick.h)
.equ K_SR,         0     // float sr
.equ K_POS,        4     // uint32 pos
.equ K_LEN,        8     // uint32 len
.equ K_ENV,        12    // float env
.equ K_ENV_COEF,   16    // float env_coef
.equ K_Y_PREV,     28    // float y_prev (sin(theta[n-1]))
.equ K_Y_PREV2,    32    // float y_prev2 (sin(theta[n-2]))
.equ K_K1,         36    // float k1 = 2*cos(delta)

// void kick_process(kick_t *k, float *L, float *R, uint32_t n)
// x0 = kick*, x1 = L*, x2 = R*, w3 = n
_kick_process:
    // Prologue (minimal – leaf function, no lib calls)
    stp x29, x30, [sp, #-16]!
    mov x29, sp
    // Preserve callee-saved x22 (used as loop counter)
    str x22, [sp, #-16]!

    // early-out: inactive or n==0
    ldr w9, [x0, #K_POS]
    ldr w10,[x0, #K_LEN]
    cmp w9, w10
    b.ge Ldone          // pos >= len
    cbz w3, Ldone       // n==0

    // Load state into FP regs
    ldr s4,  [x0, #K_ENV]       // env
    ldr s5,  [x0, #K_ENV_COEF]  // env_coef
    ldr s6,  [x0, #K_Y_PREV]    // y_prev
    ldr s7,  [x0, #K_Y_PREV2]   // y_prev2
    ldr s8,  [x0, #K_K1]        // k1 = 2*cos(delta)

    // Load AMP constant once
    adrp x11, AMP_const@PAGE
    add  x11, x11, AMP_const@PAGEOFF
    ldr  s15, [x11]

    mov w22, wzr                // i counter

Lloop:
    // Check end conditions
    cmp w22, w3
    b.ge Lend
    cmp w9, w10
    b.ge Lend

    // env *= env_coef
    fmul s4, s4, s5

    // y = k1*y_prev - y_prev2  (use s9 temps)
    fmul s9, s8, s6     // k1*y_prev
    fsub s9, s9, s7     // - y_prev2 -> y

    // sample = env * y * AMP
    fmul s0, s4, s9
    fmul s0, s0, s15

    // L[i] += sample
    ldr s1, [x1, w22, sxtw #2]
    fadd s1, s1, s0
    str s1, [x1, w22, sxtw #2]

    // R[i] += sample
    ldr s2, [x2, w22, sxtw #2]
    fadd s2, s2, s0
    str s2, [x2, w22, sxtw #2]

    // Update sine recurrence state
    fmov s7, s6         // y_prev2 = old y_prev
    fmov s6, s9         // y_prev  = y

    // Increment counters
    add w9, w9, #1      // pos++
    add w22, w22, #1    // i++
    b   Lloop

Lend:
    // Store back updated state
    str s4,  [x0, #K_ENV]
    str s6,  [x0, #K_Y_PREV]
    str s7,  [x0, #K_Y_PREV2]
    str w9,  [x0, #K_POS]

Ldone:
    ldr x22, [sp], #16
    ldp x29, x30, [sp], #16
    ret 
---END---

=== FILE: audio/snare.s ===
---BEGIN---
	.text
	.align 2
	.globl _snare_process

// Lightweight Snare – envelope recurrence + inline SplitMix64 noise
//   void snare_process(snare_t *s, float *L, float *R, uint32_t n)
//     x0 = snare_t*
//     x1 = L buffer
//     x2 = R buffer
//     w3 = n samples
//
// snare_t layout (see snare.h)
//   uint32_t pos        @ 0
//   uint32_t len        @ 4
//   float    sr         @ 8   (unused here)
//   float    env        @ 12
//   float    env_coef   @ 16
//   <padding>           @ 20
//   uint64_t rng.state  @ 24

// --- Struct Offsets ---
.equ S_POS,        0
.equ S_LEN,        4
.equ S_ENV,       12
.equ S_ENV_COEF,  16
.equ S_RNG_STATE, 24

// --- Constants ---
AMP_const:
    .float 0.4                    // overall amplitude

floats_inv24_two_one:
    .float 5.9604644775390625e-8  // 1/2^24
    .float 2.0
    .float 1.0

rng64_consts:
    .quad 0x9E3779B97F4A7C15      // GAMMA
    .quad 0xBF58476D1CE4E5B9      // MUL1
    .quad 0x94D049BB133111EB      // MUL2

// ------------------------------------------------------------
// Main routine
// ------------------------------------------------------------
_snare_process:
    // Prologue (leaf function ‑ minimal stack)
    stp x29, x30, [sp, #-16]!
    mov x29, sp
    // Save callee-saved x22 which we use as loop counter
    str x22, [sp, #-16]!

    // Early exit if inactive or n==0
    ldr w8, [x0, #S_POS]   // pos
    ldr w9, [x0, #S_LEN]   // len
    cmp w8, w9
    b.ge Ldone             // already finished
    cbz w3, Ldone          // n == 0

    // Load mutable state
    ldr s4,  [x0, #S_ENV]        // env
    ldr s5,  [x0, #S_ENV_COEF]   // env_coef
    ldr x10, [x0, #S_RNG_STATE]  // rng.state

    // Load constants
    adrp x11, AMP_const@PAGE
    add  x11, x11, AMP_const@PAGEOFF
    ldr  s15, [x11]              // AMP

    adrp x12, floats_inv24_two_one@PAGE
    add  x12, x12, floats_inv24_two_one@PAGEOFF
    ldr  s12, [x12]              // inv24
    ldr  s13, [x12, #4]          // 2.0
    ldr  s14, [x12, #8]          // 1.0

    adrp x13, rng64_consts@PAGE
    add  x13, x13, rng64_consts@PAGEOFF

    mov w22, wzr                 // loop counter i

// ------------------------------------------------------------
Lloop:
    // Break conditions: i>=n  OR  pos>=len
    cmp w22, w3
    b.ge Lend
    cmp w8, w9
    b.ge Lend

    // env *= env_coef
    fmul s4, s4, s5

    // --- SplitMix64 ---
    ldr x14, [x13]         // GAMMA
    add x10, x10, x14      // state += GAMMA

    mov x15, x10           // z = state copy
    lsr x16, x15, #30
    eor x15, x15, x16
    ldr x16, [x13, #8]     // MUL1
    mul x15, x15, x16

    lsr x16, x15, #27
    eor x15, x15, x16
    ldr x16, [x13, #16]    // MUL2
    mul x15, x15, x16

    lsr x16, x15, #31
    eor x15, x15, x16      // final z

    // Convert to float in [-1,1)
    mov w16, w15           // low 32 bits
    lsr w16, w16, #8       // 24-bit mantissa
    ucvtf s0, w16          // to float
    fmul  s0, s0, s12      // *inv24
    fmul  s0, s0, s13      // *2
    fsub  s0, s0, s14      // -1

    // sample = env * noise * AMP
    fmul s0, s0, s4
    fmul s0, s0, s15

    // L[i] += sample
    ldr s1, [x1, w22, sxtw #2]
    fadd s1, s1, s0
    str s1, [x1, w22, sxtw #2]

    // R[i] += sample
    ldr s2, [x2, w22, sxtw #2]
    fadd s2, s2, s0
    str s2, [x2, w22, sxtw #2]

    // Advance indices
    add w8, w8, #1      // pos++
    add w22, w22, #1    // i++
    b   Lloop

// ------------------------------------------------------------
Lend:
    // Store updated state back to struct
    str s4,  [x0, #S_ENV]
    str w8,  [x0, #S_POS]
    str x10, [x0, #S_RNG_STATE]

Ldone:
    ldr x22, [sp], #16
    ldp x29, x30, [sp], #16
    ret 
---END---

=== FILE: audio/hat.s ===
---BEGIN---
	.text
	.align 2
	.globl _hat_process

// Lightweight Hat – fast-decay envelope + white noise (SplitMix64)
//   void hat_process(hat_t *h, float *L, float *R, uint32_t n)
//     x0 = hat_t*
//     x1 = L buffer
//     x2 = R buffer
//     w3 = n samples
//
// hat_t layout (see hat.h)
//   uint32_t pos        @ 0
//   uint32_t len        @ 4
//   float    sr         @ 8 (unused)
//   float    env        @ 12
//   float    env_coef   @ 16
//   rng_t    rng        @ 24 (state 64-bit)

// --- Struct Offsets ---
.equ H_POS,        0
.equ H_LEN,        4
.equ H_ENV,       12
.equ H_ENV_COEF,  16
.equ H_RNG_STATE, 24

// --- Constants ---
H_AMP_const:
    .float 0.15                    // hat amplitude

f_inv24_two_one:
    .float 5.9604644775390625e-8   // 1/2^24
    .float 2.0
    .float 1.0

rng64_consts_hat:
    .quad 0x9E3779B97F4A7C15       // GAMMA
    .quad 0xBF58476D1CE4E5B9       // MUL1
    .quad 0x94D049BB133111EB       // MUL2

// ------------------------------------------------------------
_hat_process:
    // Prologue: minimal stack frame
    stp x29, x30, [sp, #-16]!
    mov x29, sp
    // Preserve callee-saved x22
    str x22, [sp, #-16]!

    // Early exits
    ldr w8, [x0, #H_POS]
    ldr w9, [x0, #H_LEN]
    cmp w8, w9
    b.ge Ldone          // inactive
    cbz w3, Ldone       // n == 0

    // Load state
    ldr s4,  [x0, #H_ENV]
    ldr s5,  [x0, #H_ENV_COEF]
    ldr x10, [x0, #H_RNG_STATE]

    // Constants
    adrp x11, H_AMP_const@PAGE
    add  x11, x11, H_AMP_const@PAGEOFF
    ldr  s15, [x11]              // AMP

    adrp x12, f_inv24_two_one@PAGE
    add  x12, x12, f_inv24_two_one@PAGEOFF
    ldr  s12, [x12]
    ldr  s13, [x12, #4]
    ldr  s14, [x12, #8]

    adrp x13, rng64_consts_hat@PAGE
    add  x13, x13, rng64_consts_hat@PAGEOFF

    mov w22, wzr                 // loop counter i

// --- Main Loop ---
Lloop:
    cmp w22, w3
    b.ge Lend
    cmp w8, w9
    b.ge Lend

    // env *= env_coef
    fmul s4, s4, s5

    // SplitMix64
    ldr x14, [x13]         // GAMMA
    add x10, x10, x14
    mov x15, x10
    lsr x16, x15, #30
    eor x15, x15, x16
    ldr x16, [x13, #8]     // MUL1
    mul x15, x15, x16
    lsr x16, x15, #27
    eor x15, x15, x16
    ldr x16, [x13, #16]    // MUL2
    mul x15, x15, x16
    lsr x16, x15, #31
    eor x15, x15, x16

    mov w16, w15
    lsr w16, w16, #8
    ucvtf s0, w16
    fmul  s0, s0, s12
    fmul  s0, s0, s13
    fsub  s0, s0, s14

    // sample = env*noise*AMP
    fmul s0, s0, s4
    fmul s0, s0, s15

    // L[i] += sample
    ldr s1, [x1, w22, sxtw #2]
    fadd s1, s1, s0
    str s1, [x1, w22, sxtw #2]

    // R[i] += sample
    ldr s2, [x2, w22, sxtw #2]
    fadd s2, s2, s0
    str s2, [x2, w22, sxtw #2]

    // Advance
    add w8, w8, #1
    add w22, w22, #1
    b   Lloop

// --- Exit ---
Lend:
    str s4,  [x0, #H_ENV]
    str w8,  [x0, #H_POS]
    str x10, [x0, #H_RNG_STATE]

Ldone:
    ldr x22, [sp], #16
    ldp x29, x30, [sp], #16
    ret 
---END---

=== FILE: audio/melody.s ===
---BEGIN---
	.text
	.align 2
	.globl _melody_process

// Simplified melody implementation avoiding libm calls
// Uses polynomial approximation for exponential decay
melody_constants:
    .float 6.2831853071795864769      // [0] TAU
    .float 5.0                        // [4] DECAY_RATE  
    .float 0.07                       // [8] AMP
    .float 2.0                        // [12] TWO
    .float 1.0                        // [16] ONE
    .float 1.2                        // [20] DRIVE_GAIN
    .float 1.5                        // [24] SOFT_A
    .float 0.5                        // [28] SOFT_B

_melody_process:
    // Prologue - simpler frame
    stp x29, x30, [sp, #-80]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]

    // Save arguments
    mov x19, x0      // melody*
    mov x23, x1      // L*
    mov x24, x2      // R*
    mov w22, w3      // n

    // Load melody struct members
    ldr s0, [x19]        // phase
    ldr w20, [x19, #4]   // pos
    ldr w21, [x19, #8]   // len
    ldr s1, [x19, #12]   // sr
    ldr s2, [x19, #16]   // freq

    // Early exit checks
    cmp w20, w21
    b.ge Ldone
    cbz w22, Ldone

    // Load constants
    adrp x4, melody_constants@PAGE
    add  x4, x4, melody_constants@PAGEOFF
    ldr  s10, [x4]       // TAU
    ldr  s11, [x4, #4]   // DECAY_RATE
    ldr  s12, [x4, #8]   // AMP
    ldr  s13, [x4, #12]  // TWO
    ldr  s14, [x4, #16]  // ONE
    ldr  s15, [x4, #20]  // DRIVE_GAIN
    ldr  s16, [x4, #24]  // SOFT_A
    ldr  s17, [x4, #28]  // SOFT_B

    // Calculate phase increment: TAU * freq / sr
    fmul s3, s10, s2     // TAU * freq
    fdiv s3, s3, s1      // / sr -> phase_inc in s3

    mov w4, wzr          // loop counter i

Lloop:
    // Loop bounds check
    cmp w4, w22
    b.ge Lend
    cmp w20, w21
    b.ge Lend

    // Calculate time: t = pos / sr
    ucvtf s4, w20
    fdiv s4, s4, s1      // t in s4

    // Simple exponential decay approximation: env = 1.0 / (1.0 + decay_rate * t)
    fmul s5, s11, s4     // decay_rate * t
    fadd s5, s14, s5     // 1.0 + decay_rate * t
    fdiv s5, s14, s5     // env = 1.0 / (1.0 + decay_rate * t)

    // Calculate sawtooth: frac = phase / TAU
    fdiv s6, s0, s10     // frac

    // raw = 2*frac - 1
    fmul s7, s6, s13     // 2*frac
    fsub s7, s7, s14     // -1 -> raw sawtooth

    // Apply drive: driven = 1.2 * raw
    fmul s8, s15, s7     // driven

    // Soft clipping: soft = 1.5*driven - 0.5*driven^3
    fmul s9, s8, s8      // driven^2
    fmul s9, s9, s8      // driven^3
    fmul s18, s16, s8    // 1.5*driven
    fmul s19, s17, s9    // 0.5*driven^3
    fsub s18, s18, s19   // soft = 1.5*driven - 0.5*driven^3

    // Final sample: sample = soft * env * amp
    fmul s18, s18, s5    // * env
    fmul s18, s18, s12   // * amp

    // Add to L[i] and R[i]
    ldr s19, [x23, w4, sxtw #2]
    fadd s19, s19, s18
    str s19, [x23, w4, sxtw #2]

    ldr s19, [x24, w4, sxtw #2]
    fadd s19, s19, s18
    str s19, [x24, w4, sxtw #2]

    // Update counters and phase
    add w4, w4, #1       // i++
    add w20, w20, #1     // pos++
    fadd s0, s0, s3      // phase += phase_inc

    // Wrap phase properly in both directions
    fcmp s0, s10
    b.lt .check_negative_wrap
    fsub s0, s0, s10     // phase -= TAU if phase >= TAU
    b Lloop

.check_negative_wrap:
    fmov s16, wzr        // 0.0
    fcmp s0, s16
    b.ge Lloop
    fadd s0, s0, s10     // phase += TAU if phase < 0
    b Lloop

Lend:
    // Store back state
    str s0, [x19]        // phase
    str w20, [x19, #4]   // pos

Ldone:
    // Epilogue
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #80
    ret

---END---

=== FILE: audio/delay.s ===
---BEGIN---
.text
.align 2
.globl _delay_process_block

// -----------------------------------------------------------------------------
// void delay_process_block(delay_t *d, float *L, float *R, uint32_t n, float feedback)
//    x0 = delay_t* { float *buf; uint32_t size; uint32_t idx; }
//    x1 = L buffer
//    x2 = R buffer
//    w3 = n samples
//    s0 = feedback amount
// Stereo ping-pong delay: L feeds R, R feeds L
// -----------------------------------------------------------------------------
_delay_process_block:
    // Prologue – use 512-byte frame; save x27/x28 at offset #480 (512-64) giving
    // the maximum distance LLDP allows (>=480 <=504) to avoid overlapping caller
    // memory even in fast execution.
    stp x29, x30, [sp, #-512]!
    stp q8,  q9,  [sp, #112]
    stp q10, q11, [sp, #144]
    stp q12, q13, [sp, #176]
    stp q14, q15, [sp, #208]
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    stp x25, x26, [sp, #64]
    stp x27, x28, [sp, #480]

    // Load struct members (buf,size,idx) into convenient regs
    ldr x4, [x0]       // buf*
    ldr w5, [x0, #8]   // size
    ldr w6, [x0, #12]  // idx

    // Early-out if n==0
    cbz w3, Ldone

    // --- PRE-WRAP BUG FIX ----------------------------------------------------
    // Make absolutely sure idx is in range BEFORE first buffer access.
    cmp w6, w5          // idx >= size ?
    csel w6, wzr, w6, hs// if so wrap to 0
    // ------------------------------------------------------------------------

    mov w7, wzr        // loop counter i

Lloop:
    // Break conditions
    cmp w7, w3
    b.hs Lstore_idx     // i >= n → exit loop

    // Calculate &buf[idx*2]
    // (each sample is float = 4 bytes, stereo interleaved)
    // addr = buf + idx*8
    lsl w8, w6, #3      // w8 = idx*8
    add x9, x4, x8      // x9 = &buf[idx*2]

    // Load delayed samples
    ldp s1, s2, [x9]    // s1 = yl, s2 = yr

    // Load input samples (post-increment L/R ptrs)
    ldr s3, [x1]        // L[i]
    ldr s4, [x2]        // R[i]

    // buf[idx*2]   = L + yr*feedback
    fmadd s5, s2, s0, s3
    // buf[idx*2+1] = R + yl*feedback
    fmadd s6, s1, s0, s4
    stp  s5, s6, [x9]

    // Add delayed signal to dry samples
    fadd s3, s3, s1     // L[i] = dryL + yl
    fadd s4, s4, s2     // R[i] = dryR + yr
    str  s3, [x1], #4   // write & advance L*
    str  s4, [x2], #4   // write & advance R*

    // Increment and wrap idx
    add w6, w6, #1
    cmp w6, w5
    csel w6[CHUNK 2 OF 2]
BUNDLE_0_CORE - PART 2
Concatenate all chunks in order to reconstruct.

, wzr, w6, hs

    // Next sample
    add w7, w7, #1
    b    Lloop

Lstore_idx:
    // Store updated idx back to struct
    str w6, [x0, #12]

Ldone:
    // Epilogue – mirror prologue order
    ldp x27, x28, [sp, #480]
    ldp q14, q15, [sp, #208]
    ldp q12, q13, [sp, #176]
    ldp q10, q11, [sp, #144]
    ldp q8,  q9,  [sp, #112]
    ldp x29, x30, [sp]
    add sp, sp, #512
    ret
---END---

=== FILE: audio/limiter.s ===
---BEGIN---
// AArch64 assembly implementation of soft-knee limiter
// void limiter_process(limiter_t *l, float *L, float *R, uint32_t n)
//   l: x0 = pointer to limiter_t { attack_coeff, release_coeff, envelope, threshold, knee_width }
//   L: x1 = left channel buffer
//   R: x2 = right channel buffer
//   n: w3 = number of samples
//
// Uses soft-knee compression with envelope follower

	.text
	.align 2
	.globl _limiter_process

limiter_consts:
	.float 20.0
	.float 2.0
	.float 10.0
	.float -0.5
	.float 1.0

_limiter_process:
	// Save registers we'll use
	stp x29, x30, [sp, #-96]!
	stp x19, x20, [sp, #16]
	stp x21, x22, [sp, #32]
	mov x29, sp
	
	// Early exit if n == 0
	cbz w3, done
	
	// Save arguments
	mov x19, x0              // limiter struct
	mov x20, x1              // L pointer
	mov x21, x2              // R pointer
	mov w22, w3              // n
	
	// Load limiter parameters
	ldr s0, [x19]            // attack_coeff
	ldr s1, [x19, #4]        // release_coeff
	ldr s2, [x19, #8]        // envelope
	ldr s3, [x19, #12]       // threshold
	ldr s4, [x19, #16]       // knee_width
	
	// Store parameters on stack for reloading after function calls
	str s0, [sp, #48]        // attack_coeff
	str s1, [sp, #52]        // release_coeff
	str s3, [sp, #56]        // threshold
	str s4, [sp, #60]        // knee_width
	str s2, [sp, #64]        // envelope (will be updated)
	
	// Calculate knee bounds and store
	fmov s5, #-0.5
	fmul s5, s4, s5          // -knee_width/2
	str s5, [sp, #68]
	fneg s6, s5              // knee_width/2
	str s6, [sp, #72]
	
	// Main loop
	mov w23, wzr             // i = 0
	
loop:
	// Break conditions
	cmp w23, w22
	b.hs Lstore_env     // i >= n → exit loop
	
	// Load samples
	ldr s7, [x20, w23, sxtw #2]   // L[i]
	ldr s8, [x21, w23, sxtw #2]   // R[i]
	
	// Get absolute values and peak
	fabs s9, s7              // |L[i]|
	fabs s10, s8             // |R[i]|
	fmax s11, s9, s10        // peak = max(|L|, |R|)
	
	// Load current envelope
	ldr s2, [sp, #64]
	
	// Envelope follower
	fcmp s11, s2
	b.le 1f
	
	// Attack: env = peak + att * (env - peak)
	ldr s0, [sp, #48]        // attack_coeff
	fsub s12, s2, s11
	fmadd s2, s0, s12, s11
	b 2f
	
1:	// Release: env = peak + rel * (env - peak)
	ldr s1, [sp, #52]        // release_coeff
	fsub s12, s2, s11
	fmadd s2, s1, s12, s11
	
2:	// Store updated envelope
	str s2, [sp, #64]
	
	// Calculate overshoot_db = 20 * log10(env / thresh)
	ldr s3, [sp, #56]        // threshold
	fdiv s0, s2, s3          // env / thresh
	
	// Save sample values before function call
	str s7, [sp, #76]        // L[i]
	str s8, [sp, #80]        // R[i]
	
	// Call log10f
	bl _log10f
	fmov s12, #20.0
	fmul s13, s0, s12        // overshoot_db = 20 * log10(...)
	
	// Reload samples
	ldr s7, [sp, #76]
	ldr s8, [sp, #80]
	
	// Calculate gain_reduction_db
	fmov s14, wzr            // gain_reduction_db = 0
	
	ldr s5, [sp, #68]        // -knee_width/2
	fcmp s13, s5
	b.le 3f                  // no reduction if below knee
	
	ldr s6, [sp, #72]        // knee_width/2
	fcmp s13, s6
	b.ge 4f                  // hard limit if above knee
	
	// Soft knee calculation
	fsub s15, s13, s5        // overshoot_db + knee_width/2
	fmul s15, s15, s15       // square it
	ldr s4, [sp, #60]        // knee_width
	fmov s16, #2.0
	fmul s16, s16, s4        // 2 * knee_width
	fdiv s14, s15, s16       // gain_reduction_db
	b 3f
	
4:	// Hard limiting
	fmov s14, s13
	
3:	// Convert to linear gain
	fneg s15, s14            // -gain_reduction_db
	fmov s16, #20.0
	fdiv s1, s15, s16        // -gain_reduction_db / 20
	
	// Save before powf
	str s7, [sp, #76]
	str s8, [sp, #80]
	
	// Call powf(10, exponent)
	fmov s0, #10.0
	bl _powf
	fmov s17, s0             // gain
	
	// Reload samples
	ldr s7, [sp, #76]
	ldr s8, [sp, #80]
	
	// Apply gain if < 1.0
	fmov s18, #1.0
	fcmp s17, s18
	b.ge 5f
	
	fmul s7, s7, s17
	fmul s8, s8, s17
	
5:	// Store processed samples
	str s7, [x20, w23, sxtw #2]
	str s8, [x21, w23, sxtw #2]
	
	// Loop control
	add w23, w23, #1
	cmp w23, w22
	b.lo loop
	
Lstore_env:
	// Store final envelope
	ldr s2, [sp, #64]
	str s2, [x19, #8]
	
	// Fallthrough
	done:
	// Restore registers
	ldp x19, x20, [sp, #16]
	ldp x21, x22, [sp, #32]
	ldp x29, x30, [sp], #96
	ret 
---END---

[CHUNK 1 OF 2]
BUNDLE_1_GENERATOR - PART 1
Concatenate all chunks in order to reconstruct.

[NOTDEAFBEEF BLOCKCHAIN BUNDLE - BUNDLE_1_GENERATOR]
=============================================================
Main audio generator (large file)
Generated for on-chain storage following deafbeef methodology.

[MANIFEST]
Bundle: bundle_1_generator
Total files: 1
Files included:
  - audio/generator.s (34206 bytes)

Reconstruction: Save each file to its path and build with provided instructions.

=== FILE: audio/generator.s ===
---BEGIN---
	.text
	.align 2
	.globl _generator_mix_buffers_asm

// Assembly stubs – we override only generator_process; keep C generator_init
	.globl _generator_process
	// (no _generator_init symbol here; C version remains)

_generator_process:
	// Args: x0 = g, x1 = L, x2 = R, w3 = num_frames

	// Prologue – save frame pointer & callee-saved regs (x19-x22)
	stp x29, x30, [sp, #-128]!   // reserve 128-byte fixed frame (was 96)
	mov x29, sp
	stp x19, x20, [sp, #16]
	stp x21, x22, [sp, #32]
	stp x23, x24, [sp, #48]
	stp x25, x26, [sp, #64]
	stp x27, x28, [sp, #80]

	// Early exit if no frames
	cbz w3, .Lgp_epilogue

	// Preserve output buffer pointers before we repurpose argument regs
	mov x19, x1            // L
	mov x20, x2            // R
	mov x24, x0            // g pointer
	// (dup line removed)
	// (generator pointer already preserved earlier)

	// Preserve num_frames in callee-saved x21 for later reuse
	mov x21, x3            // x21 = num_frames (32-bit valid)

	// ---------------------------------------------------------------------
	// Allocate contiguous scratch block on heap instead of stack
	// scratch_size = (num_frames * 16 + 15) & ~15      // 16-byte alignment
	lsl x22, x21, #4       // x22 = num_frames * 16  (bytes for 4 buffers)
	add x22, x22, #15
	bic x22, x22, #15      // align to 16 bytes

	// malloc(scratch_size)
	mov x0, x22
	bl _malloc
	mov x25, x0            // x25 = Ld base (scratch start)
	
	// TEMP: Check if malloc failed
	cbz x25, .Lgp_epilogue  // if malloc returned NULL, exit immediately

	// bytes_per_buffer = num_frames * 4
	lsl x5, x21, #2        // x5 = bytes per buffer

	// Compute remaining scratch pointers
	add x26, x25, x5       // Rd = Ld + size
	add x27, x26, x5       // Ls
	add x28, x27, x5       // Rs

	// Prepare arguments for generator_clear_buffers_asm
	mov x0, x25            // Ld
	add x1, x0, x5         // Rd = Ld + bytes_per_buffer
	add x2, x1, x5         // Ls
	add x3, x2, x5         // Rs
	mov w4, w21            // num_frames

	stp x21, x22, [sp, #96]     // save frames_rem & x22 inside fixed frame
	bl _generator_clear_buffers_asm
	ldp x21, x22, [sp, #96]     // restore w21, x22 (sp unchanged)

	// ---------------------------------------------------------------------
	// Skip explicit memset on L/R since they will be fully overwritten by
	// subsequent processing/mixing.

	// ---------------------------------------------------------------------
	// Slice-2: Outer frame loop over musical steps (state advance only)

	// Register assignments:
	//   x24 = g (generator*) – set now
	// Use x10 as pointer to timing/event fields (base = g + 4352)
	add x10, x24, #0x1000    // x10 = g + 4096
	add x10, x10, #0x128     // +296 => g + 4392 (event_idx)

	ldr w9, [x24, #12]      // w9 = step_samples (offset 12 bytes)
	ldr w8, [x10, #8]       // w8 = pos_in_step (event base + 8)

	// TOTAL_STEPS constant
	mov w13, #32           // for wrap-around comparison

	// After generator_clear_buffers_asm call and before outer loop label
	// Save scratch base pointers for later voice processing
	// x25..x28 already set to scratch pointers
	
	mov w23, wzr            // frames_done = 0 (will live in w23/x23)

.Lgp_loop:
	ldr w9, [x24, #12]           // reload step_samples each iteration
	cbz w21, .Lgp_after_loop      // frames_rem == 0 ? done

	// ----- DEBUG: dump counters at loop start -----
.if 0
	stp x0, x1, [sp, #-16]!   // save caller-saved regs we'll clobber
	stp x2, x3, [sp, #-16]!
	adrp x0, .Ldbg_pre_fmt@PAGE
	add  x0, x0, .Ldbg_pre_fmt@PAGEOFF
	mov  w1, w21   // frames_rem
	mov  w2, w9    // step_samples
	mov  w3, w8    // pos_in_step
	bl   _printf
	ldp x2, x3, [sp], #16      // restore
	ldp x0, x1, [sp], #16      // restore
.endif
	// ---------------------------------------------

	// Slice-3: Trigger events at step start
	cbnz w8, .Lgp_trigger_skip                   // Only trigger when pos_in_step == 0
	// Preserve caller-saved x8/x9 that hold pos_in_step & scratch before calling C helper
	stp x8, x9, [sp, #112]        // save into fixed 128-byte frame (offsets 112-127)
	mov x0, x24                   // x0 = g pointer
	bl _generator_trigger_step
	ldp x8, x9, [sp, #112]        // restore registers (keeps sp constant)

.Lgp_trigger_skip:
	// Recompute event/state base pointer after external calls may clobber x10
	add x10, x24, #0x1000
	add x10, x10, #0x128    // x10 = &g->event_idx
	ldr w9, [x24, #12]

	// Reload constant step_samples in case caller-saved w9 was clobbered
	ldr w9, [x24, #12]           // w9 = step_samples (offset 12 bytes)
	// frames_to_step_boundary = step_samples - pos_in_step
	sub w10, w9, w8              // w10 = frames_to_step_boundary  (no slice-shortening)
	// FM sustain fix: if pos_in_step == 0 and frames_to_step_boundary > 1, decrement by 1 so
	// that voices (particularly fm_voice) spread notes over at least two slices. This mirrors
	// the logic added in generator.c (Round 23 fix).
	cbnz w8, 1f                 // if pos_in_step != 0, skip
	cmp  w10, #1
	ble 1f                      // if boundary <=1, nothing to shorten
	sub  w10, w10, #1           // frames_to_step_boundary -= 1
1:
	// frames_to_process = min(frames_rem, frames_to_step_boundary)
	cmp w21, w10
	b.lt 1f
	mov w11, w10
	b 2f
1:	mov w11, w21
2:
	// ---------- Slice-4: Voice processing + mixing ----------
	// Save frames_to_process into callee-saved x22 to survive C call (zero-extend to avoid garbage high bits)
	mov w22, w11               // preserve w11, zeroing upper 32 bits of x22

	// Compute byte offset into scratch/output for frames_done
	lsl x12, x23, #2            // x12 = frames_done * 4 (bytes)

	// Scratch pointers for this sub-block
	add x13, x25, x12           // Ld ptr
	add x14, x26, x12           // Rd ptr
	add x15, x27, x12           // Ls ptr
	add x16, x28, x12           // Rs ptr
	// Output pointers
	add x17, x19, x12           // L dest
	add x18, x20, x12           // R dest

	// Call voice processor (preserve x21 across call)
	stp x21, x22, [sp, #96]     // save frames_rem & x22 inside fixed frame

	// Replace C voice processing with ASM voice processing calls
	
	// Process kick into drum buffers (Ld/Rd)
	add x0, x24, #56            // kick offset (from generator_t)
	mov x1, x13                 // Ld
	mov x2, x14                 // Rd
	mov w3, w11                 // num_frames
	bl _kick_process
	
	// Remove debug for now - focus on testing audio output
	
	// Process snare into drum buffers
	add x0, x24, #96            // snare offset
	mov x1, x13                 // Ld
	mov x2, x14                 // Rd
	mov w3, w11                 // num_frames
	bl _snare_process
	
	// Process melody into synth buffers (Ls/Rs)  
	add x0, x24, #160           // melody offset
	mov x1, x15                 // Ls
	mov x2, x16                 // Rs
	mov w3, w11                 // num_frames
	bl _melody_process
	
	// Process FM voices into synth buffers
	add x0, x24, #180           // mid_fm offset
	mov x1, x15                 // Ls
	mov x2, x16                 // Rs
	mov w3, w11                 // num_frames
	bl _fm_voice_process
	
	add x0, x24, #220           // bass_fm offset
	mov x1, x15                 // Ls
	mov x2, x16                 // Rs
	mov w3, w11                 // num_frames
	bl _fm_voice_process

	ldp x21, x22, [sp, #96]     // restore w21, x22 (sp unchanged)

	// Recompute event/state base pointer after _generator_process_voices (x10 may be clobbered)
	add x10, x24, #0x1000
	add x10, x10, #0x128    // x10 = &g->event_idx

	// Restore w11 from x22 after helper
	mov w11, w22               // restore frames_to_process
	// Reload pos_in_step since w8 is caller-clobbered
	ldr w8, [x10, #8]

    // ----- TRACE1: after voice processing -----
.if 0
    stp x0, x1, [sp, #-16]!   // save regs clobbered by printf
    adrp x0, .Ldbg_post1_fmt@PAGE
    add  x0, x0, .Ldbg_post1_fmt@PAGEOFF
    mov  w1, w21   // frames_rem (remaining)
    mov  w2, w11   // frames_to_process for this slice
    mov  w3, w8    // current pos_in_step
    bl   _printf
    ldp x0, x1, [sp], #16      // restore regs
.endif

	// TEMP: Remove offset calculation to test if that's the issue
	lsl x12, x23, #2            // byte offset = frames_done * 4
	add x13, x25, x12           // Ld ptr
	add x14, x26, x12           // Rd ptr
	add x15, x27, x12           // Ls ptr
	add x16, x28, x12           // Rs ptr
	add x17, x19, x12           // L dest = L_base + offset
	add x18, x20, x12           // R dest = R_base + offset

	// Mix drums + synths into output buffers
	mov x0, x17                 // L out
	mov x1, x18                 // R out
	mov x2, x13                 // Ld
	mov x3, x14                 // Rd
	mov x4, x15                 // Ls
	mov x5, x16                 // Rs
	mov w6, w11                 // num_frames
	// Just call the mixing function (debug later)
	bl _generator_mix_buffers_asm

	// Re-enable debug check but only for first slice
	.if 0
		cbnz w23, .Lskip_output_check    // only when frames_done == 0
		// cbnz w23, .Lskip_output_check    // DISABLED: run on every slice
		
		// Check first few samples of L output buffer as integers (simpler)
		ldr w0, [x17]      // Load L[0] as int
		ldr w1, [x17, #4]  // Load L[1] as int 
		ldr w2, [x17, #8]  // Load L[2] as int
		
		// Simple check: if any sample != 0, we have audio
		orr w0, w0, w1     // w0 = L[0] | L[1]
		orr w0, w0, w2     // w0 = L[0] | L[1] | L[2]
		cbnz w0, .Loutput_has_audio
		
		// Output is silent
		adrp x0, .Loutput_silent_msg@PAGE
		add x0, x0, .Loutput_silent_msg@PAGEOFF
		mov w1, #22
		mov x2, #2  // stderr
		mov x16, #4  // sys_write
		svc #0x80
		b .Lskip_output_check
		
	.Loutput_has_audio:
		adrp x0, .Loutput_audio_msg@PAGE
		add x0, x0, .Loutput_audio_msg@PAGEOFF
		mov w1, #24
		mov x2, #2  // stderr
		mov x16, #4  // sys_write
		svc #0x80
		
	.Lskip_output_check:
	.endif

	// ----- SCRATCH RMS PROBE (debug – first slice only) -----
	.if 0
		cbnz w23, .Lskip_scratch_rms    // only when frames_done == 0

		// Save caller-saved regs we will clobber (x0-x3)
		stp x0, x1, [sp, #-16]!
		stp x2, x3, [sp, #-16]!

		// ---- drums scratch RMS (Ld/Rd) ----
		mov x0, x13      // Ld
		mov x1, x14      // Rd
		mov w2, w11      // num_frames in slice
		bl  _generator_compute_rms_asm   // s0 = RMS
		fmov w4, s0                      // raw bits -> w4

		// ---- synth scratch RMS (Ls/Rs) ----
		mov x0, x15      // Ls
		mov x1, x16      // Rs
		mov w2, w11
		bl  _generator_compute_rms_asm   // s0 = RMS
		fmov w5, s0                      // raw bits -> w5

		// printf("SCR drums=%u synth=%u n=%u\n", drums_bits, synth_bits, frames_to_process)
		adrp x0, .Ldbg_scratch_fmt@PAGE
		add  x0, x0, .Ldbg_scratch_fmt@PAGEOFF
		mov  w1, w4
		mov  w2, w5
		mov  w3, w11
		bl   _printf

		// Restore clobbered regs
		ldp x2, x3, [sp], #16
		ldp x0, x1, [sp], #16

	.Lskip_scratch_rms:
	.endif

	// ----- RMS DEBUG -----
	.if 0
	    // Save x0–x3 into unused area of 128-byte fixed frame (keeps sp constant)
	    stp x0, x1, [x29, #96]
	    stp x2, x3, [x29, #112]

	    mov x0, x17                       // L buffer pointer
	    mov x1, x18                       // R buffer pointer
	    mov w2, w11                       // num_frames this slice
	    bl _generator_compute_rms_asm     // s0 = RMS (float)

	    // Store RMS for real-time visual feedback  
	    adrp x9, _g_block_rms@PAGE
	    add  x9, x9, _g_block_rms@PAGEOFF
	    fmov s1, #0.5                     // Fixed RMS for visuals
	    str  s1, [x9]                     // g_block_rms = 0.5 (safe)

	    // Print raw IEEE bits so we avoid float formatting overhead
	    fmov w1, s0                       // RMS bits → w1
	    adrp x0, .Ldbg_rms_fmt@PAGE       // format string "%u\n"
	    add  x0, x0, .Ldbg_rms_fmt@PAGEOFF
	    bl  _printf

	    // Restore x0–x3
	    ldp x2, x3, [x29, #112]
	    ldp x0, x1, [x29, #96]
	.endif
	// ----- END RMS DEBUG -----

	// DEBUG PRINT BEGIN
.if 0
	stp x21, x22, [sp, #-16]!        // save frames_rem and spare callee-saved slot
	stp x8, x11, [sp, #-16]!         // save live regs for printf args
	adrp x0, .Ldbg_fmt@PAGE
	add  x0, x0, .Ldbg_fmt@PAGEOFF
	mov  w1, w21  // frames_rem
	mov  w2, w11  // frames_to_process
	mov  w3, w8   // pos_in_step
	bl   _printf
	ldp x8, x11, [sp], #16           // restore
	ldp x21, x22, [sp], #16          // restore frames_rem
.endif
	// DEBUG PRINT END

	// Advance counters
	add w8, w8, w11              // pos_in_step += frames_to_process
    // write back updated pos_in_step to struct
    add x10, x24, #0x1000
    add x10, x10, #0x128   // correct base for event/state block (g + 4392)
    str w8, [x10, #8]
	sub w21, w21, w11            // frames_rem  -= frames_to_process
	add w23, w23, w11            // frames_done += frames_to_process

	// Check if step boundary reached
	cmp w8, w9
	b.lt .Lgp_loop

	// Boundary reached – reset pos_in_step and advance step
	mov w8, wzr
	// Recompute event/state base pointer again (x10 may be clobbered by helpers)
	add x10, x24, #0x1000
	add x10, x10, #0x128   // x10 = &g->event_idx
	str w8, [x10, #8]       // write back pos_in_step = 0 to generator struct
	ldr w12, [x10, #4]        // w12 = step (event base + 4)
	add w12, w12, #1
	cmp w12, w13
	b.lt 3f
	mov w12, wzr
	str wzr, [x10]            // event_idx reset
3:	str w12, [x10, #4]
	b .Lgp_loop

.Lgp_after_loop:
	// Store updated pos_in_step back
	str w8, [x10, #8]

	// Deallocate scratch (free)
	mov x0, x25
	bl _free

	// TEMP: Skip delay & limiter to test if they're clearing audio
	b .Lgp_epilogue

	// ---------------------------------------------------------------------
	// Slice-5: Apply Delay & Limiter (C implementations)
	// --------------------------------------------------
	// delay_process_block(&g->delay, L, R, num_frames, 0.45f);
	// limiter_process(&g->limiter, L, R, num_frames);

	// Prepare arguments for delay_process_block
	// x24 = g (preserved), x19 = L buffer, x20 = R buffer, w23 = total num_frames

	// x0 = &g->delay  (offset 4408 bytes)
	add x0, x24, #4096        // base offset
	add x0, x0, #312          // 4096 + 312 = 4408
	mov x1, x19               // L
	mov x2, x20               // R
	mov w3, w23               // n = num_frames
	// s0 = 0.45f  (IEEE-754 0x3EE66666)
	mov w4, #0x6666
	movk w4, #0x3EE6, lsl #16
	fmov s0, w4
	bl _delay_process_block

    #ifndef SKIP_LIMITER
    // Prepare arguments for limiter_process
    // x0 = &g->limiter (offset 4424 bytes)
    add x0, x24, #4096        // base offset
    add x0, x0, #328          // 4096 + 328 = 4424
    mov x1, x19               // L
    mov x2, x20               // R
    mov w3, w23               // n = num_frames
    bl _limiter_process
    #endif

	// Existing epilogue label below handles register restore and return

.Lgp_epilogue:
	// Early-exit path: deallocate scratch skipped (not allocated)
	ldp x27, x28, [x29, #80]
	ldp x25, x26, [x29, #64]
	ldp x23, x24, [x29, #48]
	ldp x21, x22, [x29, #32]
	ldp x19, x20, [x29, #16]
	ldp x29, x30, [sp], #128    // pop full 128-byte frame
	ret

/*
 * generator_mix_buffers_asm - NEON vectorized buffer mixing
 * -------------------------------------------------------
 * void generator_mix_buffers_asm(float *L, float *R, 
 *                                 const float *Ld, const float *Rd,
 *                                 const float *Ls, const float *Rs,
 *                                 uint32_t num_frames);
 *
 * Performs: L[i] = Ld[i] + Ls[i]  (drums + synths)
 *          R[i] = Rd[i] + Rs[i]  (drums + synths)
 *
 * Uses NEON to process 4 samples per iteration for maximum throughput.
 * This is the hot path that runs every audio frame in real-time.
 */

_generator_mix_buffers_asm:
	// Arguments: x0=L, x1=R, x2=Ld, x3=Rd, x4=Ls, x5=Rs, w6=num_frames
	
	// TEMP: Check for zero frame count (common cause of silent exit)
	cbnz w6, .Lmix_continue
	ret  // Exit immediately if zero frames - but this is normal
.Lmix_continue:
	
	// Early exit if no frames to process
	cbz w6, .Lmix_done
	
	// Calculate how many complete NEON vectors (4 samples) we can process
	lsr w7, w6, #2          // w7 = num_frames / 4 (complete vectors)
	and w8, w6, #3          // w8 = num_frames % 4 (remainder samples)
	
	// Process complete 4-sample vectors with NEON
	cbz w7, .Lmix_scalar    // Skip if no complete vectors
	
.Lmix_vector_loop:
	// Load 4 samples from each source buffer
	ld1 {v0.4s}, [x2], #16  // v0 = Ld[i..i+3], advance pointer
	ld1 {v1.4s}, [x3], #16  // v1 = Rd[i..i+3], advance pointer  
	ld1 {v2.4s}, [x4], #16  // v2 = Ls[i..i+3], advance pointer
	ld1 {v3.4s}, [x5], #16  // v3 = Rs[i..i+3], advance pointer
	
	// Vector addition: drums + synths
	fadd v4.4s, v0.4s, v2.4s  // v4 = Ld + Ls
	fadd v5.4s, v1.4s, v3.4s  // v5 = Rd + Rs
	
	// Store results to output buffers
	st1 {v4.4s}, [x0], #16   // L[i..i+3] = v4, advance pointer
	st1 {v5.4s}, [x1], #16   // R[i..i+3] = v5, advance pointer
	
	// Loop control
	subs w7, w7, #1
	b.ne .Lmix_vector_loop
	
.Lmix_scalar:
	// Handle remaining samples (0-3) with scalar operations
	cbz w8, .Lmix_done
	
.Lmix_scalar_loop:
	// Load single samples
	ldr s0, [x2], #4        // s0 = Ld[i]
	ldr s1, [x3], #4        // s1 = Rd[i]
	ldr s2, [x4], #4        // s2 = Ls[i]
	ldr s3, [x5], #4        // s3 = Rs[i]
	
	// Scalar addition
	fadd s4, s0, s2         // s4 = Ld[i] + Ls[i]
	fadd s5, s1, s3         // s5 = Rd[i] + Rs[i]
	
	// Store results
	str s4, [x0], #4        // L[i] = s4
	str s5, [x1], #4        // R[i] = s5
	
	// Loop control
	subs w8, w8, #1
	b.ne .Lmix_scalar_loop
	
.Lmix_done:
	ret

.Lmix_null_error:
	// Safe debug message for NULL pointer error
	stp x0, x1, [sp, #-16]!   
	adrp x0, .Lmix_null_msg@PAGE
	add x0, x0, .Lmix_null_msg@PAGEOFF
	mov w1, #22
	mov x2, #2  // stderr
	mov x16, #4  // sys_write
	svc #0x80
	ldp x0, x1, [sp], #16
	ret

/*
 * generator_compute_rms_asm - NEON vectorized RMS calculation
 * ---------------------------------------------------------
 * float generator_compute_rms_asm(const float *L, const float *R, uint32_t num_frames);
 *
 * Computes RMS = sqrt(sum(L[i]² + R[i]²) / (num_frames * 2))
 * 
 * Uses NEON to process 4 samples per iteration:
 * - Load L[i..i+3] and R[i..i+3] 
 * - Square each (fmul)
 * - Add L² + R² (fadd)
 * - Accumulate in vector sum
 * - Final horizontal sum + sqrt in scalar
 */

	.globl _generator_compute_rms_asm

_generator_compute_rms_asm:
	// Arguments: x0=L, x1=R, w2=num_frames
	// Returns: s0 = RMS value
	
	// Early exit if no frames
	cbz w2, .Lrms_zero
	
	// Initialize accumulator vector to zero
	movi v16.4s, #0              // v16 = accumulator for vector sum
	fmov s17, wzr                // s17 = accumulator for scalar sum
	
	// Calculate how many complete NEON vectors (4 samples) we can process
	lsr w3, w2, #2               // w3 = num_frames / 4 (complete vectors)
	and w4, w2, #3               // w4 = num_frames % 4 (remainder samples)
	
	// Process complete 4-sample vectors with NEON
	cbz w3, .Lrms_scalar         // Skip if no complete vectors
	
.Lrms_vector_loop:
	// Load 4 samples from each buffer
	ld1 {v0.4s}, [x0], #16       // v0 = L[i..i+3], advance pointer
	ld1 {v1.4s}, [x1], #16       // v1 = R[i..i+3], advance pointer
	
	// Square the samples: L² and R²
	fmul v2.4s, v0.4s, v0.4s     // v2 = L[i]² for 4 samples
	fmul v3.4s, v1.4s, v1.4s     // v3 = R[i]² for 4 samples
	
	// Add L² + R² 
	fadd v4.4s, v2.4s, v3.4s     // v4 = L[i]² + R[i]² for 4 samples
	
	// Accumulate in sum vector
	fadd v16.4s, v16.4s, v4.4s   // accumulate
	
	// Loop control
	subs w3, w3, #1
	b.ne .Lrms_vector_loop
	
.Lrms_scalar:
	// Handle remaining samples (0-3) with scalar operations
	cbz w4, .Lrms_finalize
	
.Lrms_scalar_loop:
	// Load single samples
	ldr s0, [x0], #4             // s0 = L[i]
	ldr s1, [x1], #4             // s1 = R[i]
	
	// Square and add: L² + R²
	fmul s2, s0, s0              // s2 = L[i]²
	fmul s3, s1, s1              // s3 = R[i]²
	fadd s4, s2, s3              // s4 = L[i]² + R[i]²
	
	// Add to scalar accumulator  
	fadd s17, s17, s4            // accumulate scalar remainder
	
	// Loop control
	subs w4, w4, #1
	b.ne .Lrms_scalar_loop
	
.Lrms_finalize:
	// Horizontal sum of accumulator vector v16 → s0
	faddp v18.4s, v16.4s, v16.4s // pairwise add: [a+b, c+d, a+b, c+d]
	faddp s0, v18.2s             // final vector sum: (a+b) + (c+d)
	
	// Add scalar accumulator to vector sum
	fadd s0, s0, s17             // total_sum = vector_sum + scalar_sum
	
	// Convert num_frames to float and multiply by 2
	ucvtf s1, w2                 // s1 = (float)num_frames  
	fmov s2, #2.0                // s2 = 2.0
	fmul s1, s1, s2              // s1 = num_frames * 2
	
	// Divide sum by (num_frames * 2) to get mean
	fdiv s0, s0, s1              // s0 = mean = sum / (num_frames * 2)
	
	// Take square root to get RMS
	fsqrt s0, s0                 // s0 = sqrt(mean) = RMS
	
	ret
	
.Lrms_zero:
	// Return 0.0 if no frames
	fmov s0, wzr
	ret 

/*
 * generator_clear_buffers_asm - NEON vectorized buffer clearing
 * -----------------------------------------------------------
 * void generator_clear_buffers_asm(float *Ld, float *Rd, float *Ls, float *Rs, uint32_t num_frames);
 *
 * Clears (zeros) all 4 float buffers using NEON vector stores.
 * Replaces 4 memset() calls with optimized NEON operations.
 * 
 * Uses NEON to process 4 samples per iteration for maximum throughput.
 */

	.globl _generator_clear_buffers_asm

_generator_clear_buffers_asm:
	// Arguments: x0=Ld, x1=Rd, x2=Ls, x3=Rs, w4=num_frames
	
	// Early exit if no frames to process
	cbz w4, .Lclear_done
	
	// Initialize zero vector for NEON stores
	movi v0.4s, #0               // v0 = [0.0, 0.0, 0.0, 0.0]
	
	// Calculate how many complete NEON vectors (4 samples) we can process
	lsr w5, w4, #2               // w5 = num_frames / 4 (complete vectors)
	and w6, w4, #3               // w6 = num_frames % 4 (remainder samples)
	
	// Process complete 4-sample vectors with NEON
	cbz w5, .Lclear_scalar       // Skip if no complete vectors
	
.Lclear_vector_loop:
	// Store 4 zero samples to each buffer
	st1 {v0.4s}, [x0], #16       // Ld[i..i+3] = 0.0, advance pointer
	st1 {v0.4s}, [x1], #16       // Rd[i..i+3] = 0.0, advance pointer  
	st1 {v0.4s}, [x2], #16       // Ls[i..i+3] = 0.0, advance pointer
	st1 {v0.4s}, [x3], #16       // Rs[i..i+3] = 0.0, advance pointer
	
	// Loop control
	subs w5, w5, #1
	b.ne .Lclear_vector_loop
	
.Lclear_scalar:
	// Handle remaining samples (0-3) with scalar operations
	cbz w6, .Lclear_done
	
	// Zero value for scalar stores
	fmov s1, wzr                 // s1 = 0.0
	
.Lclear_scalar_loop:
	// Store single zero sample to each buffer
	str s1, [x0], #4             // Ld[i] = 0.0
	str s1, [x1], #4             // Rd[i] = 0.0
	str s1, [x2], #4             // Ls[i] = 0.0  
	str s1, [x3], #4             // Rs[i] = 0.0
	
	// Loop control
	subs w6, w6, #1
	b.ne .Lclear_scalar_loop
	
.Lclear_done:
	ret

/*
 * generator_rotate_pattern_asm - NEON vectorized pattern rotation
 * -------------------------------------------------------------
 * void generator_rotate_pattern_asm(uint8_t *pattern, uint8_t *tmp, uint32_t size, uint32_t rot);
 *
 * Rotates a uint8_t array by 'rot' positions: pattern[i] = old_pattern[(i+rot) % size]
 * Optimized for size=16 (STEPS_PER_BAR) using NEON EXT instruction.
 * 
 * For size=16: Single NEON register holds entire pattern, EXT performs rotation in one operation.
 */

	.globl _generator_rotate_pattern_asm

_generator_rotate_pattern_asm:
	// Arguments: x0=pattern, x1=tmp, w2=size, w3=rot
	
	// Early exit if no rotation needed
	cbz w3, .Lrot_done
	
	// Optimize for STEPS_PER_BAR =[CHUNK 2 OF 2]
BUNDLE_1_GENERATOR - PART 2
Concatenate all chunks in order to reconstruct.

 16 case
	cmp w2, #16
	b.eq .Lrot_neon16
	
	// Fallback for other sizes: scalar implementation
	b .Lrot_scalar
	
.Lrot_neon16:
	// NEON optimization for 16-byte patterns (STEPS_PER_BAR)
	// Load entire 16-byte pattern into single NEON register
	ld1 {v0.16b}, [x0]
	
	// Build rotation index table: [rot, rot+1, rot+2, ..., rot+15] % 16
	and w3, w3, #15          // Ensure rot is 0-15 (rot % 16)
	
	// Build index table on stack
	sub sp, sp, #16          // Allocate 16 bytes on stack
	mov w4, wzr              // w4 = loop counter
	
.Lrot_build_indices:
	add w5, w4, w3           // w5 = i + rot
	and w5, w5, #15          // w5 = (i + rot) % 16
	strb w5, [sp, w4, uxtw]  // Store index to stack
	add w4, w4, #1           // i++
	cmp w4, #16
	b.lt .Lrot_build_indices
	
	// Load index table and use TBL for rotation
	ld1 {v2.16b}, [sp]       // Load index table
	tbl v1.16b, {v0.16b}, v2.16b  // Perform table lookup rotation
	
	// Store rotated pattern back and clean up stack
	st1 {v1.16b}, [x0]
	add sp, sp, #16          // Restore stack
	
	b .Lrot_done
	
.Lrot_scalar:
	// Scalar fallback for arbitrary sizes
	// Copy pattern to tmp buffer
	mov w4, wzr              // w4 = loop counter for memcpy
	
.Lrot_copy_loop:
	cmp w4, w2
	b.ge .Lrot_rotate_start
	ldrb w5, [x0, w4, uxtw]  // Load pattern[i]
	strb w5, [x1, w4, uxtw]  // Store to tmp[i]
	add w4, w4, #1
	b .Lrot_copy_loop
	
.Lrot_rotate_start:
	// Rotate: pattern[i] = tmp[(i+rot) % size]
	mov w4, wzr              // w4 = i (loop counter)
	
.Lrot_rotate_loop:
	cmp w4, w2
	b.ge .Lrot_done
	
	// Calculate src_index = (i + rot) % size
	add w5, w4, w3           // w5 = i + rot
	udiv w6, w5, w2          // w6 = (i + rot) / size
	msub w5, w6, w2, w5      // w5 = (i + rot) - (w6 * size) = (i + rot) % size
	
	// pattern[i] = tmp[src_index]
	ldrb w6, [x1, w5, uxtw]  // Load tmp[src_index]
	strb w6, [x0, w4, uxtw]  // Store to pattern[i]
	
	add w4, w4, #1           // i++
	b .Lrot_rotate_loop
	
.Lrot_done:
	ret 

/*
 * generator_build_events_asm - Pre-compute entire event queue in assembly
 * ----------------------------------------------------------------------
 * void generator_build_events_asm(event_queue_t *q, rng_t *rng, 
 *                                  const uint8_t *kick_pat, const uint8_t *snare_pat, const uint8_t *hat_pat,
 *                                  uint32_t step_samples);
 *
 * Converts the event queue building loop from C to assembly for ultimate performance.
 * This is the final orchestration step - building the complete musical timeline.
 *
 * Event generation rules:
 * - Drums: kick/snare/hat based on euclidean patterns
 * - Melody: triggers at specific bar positions (0, 8, 16, 24) 
 * - Mid: stochastic triggers with 10% probability on certain beats
 * - Bass: triggers at beginning of each bar (step 0)
 *
 * Constants:
 * - TOTAL_STEPS = 32, STEPS_PER_BAR = 16
 * - Event types: KICK=0, SNARE=1, HAT=2, MELODY=3, MID=4, FM_BASS=5
 */

	.globl _generator_build_events_asm

_generator_build_events_asm:
	// Arguments: x0=q, x1=rng, x2=kick_pat, x3=snare_pat, x4=hat_pat, w5=step_samples
	
	// Save callee-saved registers
	stp x19, x20, [sp, #-80]!
	stp x21, x22, [sp, #16]
	stp x23, x24, [sp, #32]
	stp x25, x26, [sp, #48]
	stp x27, x28, [sp, #64]
	
	// Initialize event queue: q->count = 0
	str wzr, [x0, #4096]        // q->count = 0 (events array is 4096 bytes)
	
	// Register assignments for loop
	mov x19, x0                 // x19 = q (event queue)
	mov x20, x1                 // x20 = rng
	mov x21, x2                 // x21 = kick_pat
	mov x22, x3                 // x22 = snare_pat
	mov x23, x4                 // x23 = hat_pat
	mov w24, w5                 // w24 = step_samples
	mov w25, wzr                // w25 = step (loop counter)
	
	// Constants
	mov w26, #32                // w26 = TOTAL_STEPS
	mov w27, #16                // w27 = STEPS_PER_BAR
	
	// RNG_FLOAT constants - removed unused constant
	
.Lbuild_loop:
	// Check loop condition: step < TOTAL_STEPS
	cmp w25, w26
	b.ge .Lbuild_done
	
	// Calculate t = step * step_samples
	mul w6, w25, w24            // w6 = t = step * step_samples
	
	// Calculate bar_step = step % STEPS_PER_BAR
	udiv w7, w25, w27           // w7 = step / STEPS_PER_BAR
	msub w8, w7, w27, w25       // w8 = bar_step = step - (w7 * STEPS_PER_BAR)
	
	// Check kick pattern: if(kick_pat[step % STEPS_PER_BAR])
	ldrb w9, [x21, w8, uxtw]    // w9 = kick_pat[bar_step]
	cbz w9, .Lcheck_snare
	
	// Push kick event: eq_push(q, t, EVT_KICK, 0)
	mov w10, #0                 // EVT_KICK = 0
	mov w11, #0                 // aux = 0
	bl _generator_eq_push_helper_asm
	
.Lcheck_snare:
	// Check snare pattern: if(snare_pat[step % STEPS_PER_BAR])
	ldrb w9, [x22, w8, uxtw]    // w9 = snare_pat[bar_step]
	cbz w9, .Lcheck_hat
	
	// Push snare event: eq_push(q, t, EVT_SNARE, 0)
	mov w10, #1                 // EVT_SNARE = 1
	mov w11, #0                 // aux = 0
	bl _generator_eq_push_helper_asm
	
.Lcheck_hat:
	// Check hat pattern: if(hat_pat[step % STEPS_PER_BAR])
	ldrb w9, [x23, w8, uxtw]    // w9 = hat_pat[bar_step]
	cbz w9, .Lcheck_melody
	
	// Push hat event: eq_push(q, t, EVT_HAT, 0)
	mov w10, #2                 // EVT_HAT = 2
	mov w11, #0                 // aux = 0
	bl _generator_eq_push_helper_asm
	
.Lcheck_melody:
	// Check melody triggers: if(bar_step==0 || bar_step==8 || bar_step==16 || bar_step==24)
	cbz w8, .Lmelody_trigger    // bar_step == 0
	cmp w8, #8
	b.eq .Lmelody_trigger
	cmp w8, #16
	b.eq .Lmelody_trigger
	cmp w8, #24
	b.eq .Lmelody_trigger
	b .Lcheck_mid
	
.Lmelody_trigger:
	// Push melody event: eq_push(q, t, EVT_MELODY, bar_step/8)
	lsr w11, w8, #3             // w11 = aux = bar_step / 8
	mov w10, #3                 // EVT_MELODY = 3
	bl _generator_eq_push_helper_asm
	
.Lcheck_mid:
	// Check mid triggers: if(bar_step % 4 == 2 || ((bar_step%4==1 || bar_step%4==3) && RNG_FLOAT < 0.1))
	and w9, w8, #3              // w9 = bar_step % 4
	cmp w9, #2
	b.eq .Lmid_trigger          // bar_step % 4 == 2
	
	// Check if bar_step % 4 == 1 or 3
	cmp w9, #1
	b.eq .Lmid_rng_check
	cmp w9, #3
	b.ne .Lcheck_bass
	
.Lmid_rng_check:
	// Generate RNG_FLOAT and compare with 0.1
	bl _generator_rng_next_float_asm   // Returns float in s0
	
	// Compare with 0.1f
	mov w12, #0x3dcc
	movk w12, #0xcccd, lsl #16  // 0.1f in IEEE 754
	fmov s1, w12
	fcmp s0, s1
	b.ge .Lcheck_bass           // if RNG_FLOAT >= 0.1, skip
	
.Lmid_trigger:
	// Generate random aux value: rng_next_u32() % 7
	bl _generator_rng_next_u32_asm   // Returns uint32_t in w0
	mov w12, #7
	udiv w13, w0, w12
	msub w11, w13, w12, w0      // w11 = aux = w0 % 7
	
	// Push mid event: eq_push(q, t, EVT_MID, aux)
	mov w10, #4                 // EVT_MID = 4
	bl _generator_eq_push_helper_asm
	
.Lcheck_bass:
	// Check bass trigger: if(bar_step == 0)
	cbnz w8, .Lloop_next
	
	// Push bass event: eq_push(q, t, EVT_FM_BASS, 0)
	mov w10, #5                 // EVT_FM_BASS = 5
	mov w11, #0                 // aux = 0
	bl _generator_eq_push_helper_asm
	
.Lloop_next:
	// Increment step and continue loop
	add w25, w25, #1
	b .Lbuild_loop
	
.Lbuild_done:
	// Restore callee-saved registers
	ldp x27, x28, [sp, #64]
	ldp x25, x26, [sp, #48]
	ldp x23, x24, [sp, #32]
	ldp x21, x22, [sp, #16]
	ldp x19, x20, [sp], #80
	ret

/*
 * Helper function: eq_push equivalent
 * Inputs: w6=time, w10=type, w11=aux
 * Uses: x19=q
 */
	.globl _generator_eq_push_helper_asm
_generator_eq_push_helper_asm:
	// Load current count
	ldr w12, [x19, #4096]       // w12 = q->count
	
	// Check if count < MAX_EVENTS (512)
	cmp w12, #512
	b.ge .Leq_push_ret          // Skip if queue full
	
	// Calculate event address: &q->events[count]
	mov w13, #8                 // sizeof(event_t) = 8 bytes
	mul w14, w12, w13           // w14 = count * sizeof(event_t)
	add x15, x19, w14, uxtw     // x15 = &q->events[count]
	
	// Store event: {time, type, aux, padding}
	str w6, [x15]               // event.time = time
	strb w10, [x15, #4]         // event.type = type
	strb w11, [x15, #5]         // event.aux = aux
	
	// Increment count
	add w12, w12, #1
	str w12, [x19, #4096]       // q->count++
	
.Leq_push_ret:
	ret

/*
 * Helper function: rng_next_u32 equivalent
 * Inputs: x20=rng
 * Returns: w0=random uint32_t
 * Preserves: x20 (rng pointer)
 */
	.globl _generator_rng_next_u32_asm  
_generator_rng_next_u32_asm:
	// Save link register and preserve registers
	stp x29, x30, [sp, #-16]!
	
	// Implementation of SplitMix64 algorithm
	// uint64_t z = (r->state += 0x9E3779B97F4A7C15ULL);
	ldr x0, [x20]               // x0 = rng->state
	movz x1, #0x7C15, lsl #0
	movk x1, #0x7F4A, lsl #16
	movk x1, #0xB979, lsl #32
	movk x1, #0x9E37, lsl #48   // x1 = 0x9E3779B97F4A7C15
	add x0, x0, x1              // x0 = state + increment
	str x0, [x20]               // rng->state = new state
	
	// z = (z ^ (z >> 30)) * 0xBF58476D1CE4E5B9ULL;
	lsr x1, x0, #30
	eor x0, x0, x1
	movz x1, #0xE5B9, lsl #0
	movk x1, #0x1CE4, lsl #16
	movk x1, #0x476D, lsl #32
	movk x1, #0xBF58, lsl #48   // x1 = 0xBF58476D1CE4E5B9
	mul x0, x0, x1
	
	// z = (z ^ (z >> 27)) * 0x94D049BB133111EBULL;
	lsr x1, x0, #27
	eor x0, x0, x1
	movz x1, #0x11EB, lsl #0
	movk x1, #0x3311, lsl #16
	movk x1, #0x49BB, lsl #32
	movk x1, #0x94D0, lsl #48   // x1 = 0x94D049BB133111EB
	mul x0, x0, x1
	
	// return z ^ (z >> 31);
	lsr x1, x0, #31
	eor x0, x0, x1
	
	// Return lower 32 bits
	mov w0, w0
	
	// Restore and return
	ldp x29, x30, [sp], #16
	ret

/*
 * Helper function: rng_next_float equivalent  
 * Inputs: x20=rng
 * Returns: s0=random float [0,1)
 */
	.globl _generator_rng_next_float_asm
_generator_rng_next_float_asm:
	// Save link register and floating-point context
	stp x29, x30, [sp, #-16]!
	
	// Call rng_next_u32
	bl _generator_rng_next_u32_asm   // w0 = random uint32_t
	
	// Implement: (rng_next_u32(r) >> 8) * (1.0f / 16777216.0f)
	lsr w0, w0, #8              // w0 = w0 >> 8
	ucvtf s0, w0                // s0 = (float)w0
	
	// Multiply by 1.0f / 16777216.0f = 5.960464477539063e-08
	movz w1, #0x0000, lsl #0
	movk w1, #0x3380, lsl #16   // IEEE 754 representation of 1.0f/16777216.0f
	fmov s1, w1
	fmul s0, s0, s1             // s0 = s0 * (1.0f/16777216.0f)
	
	// Restore and return
	ldp x29, x30, [sp], #16
	ret 

.section __TEXT,__cstring
.Ldbg_fmt:
	.asciz "ASM: rem=%u proc=%u pos=%u\n"
.Ldbg_pre_fmt:
	.asciz "PRE: rem=%u step=%u pos=%u\n"
.Ldbg_post1_fmt:
    .asciz "P1:  rem=%u proc=%u pos=%u\n" 
.Ldbg_rms_fmt:
	.asciz "RMSraw=%u\n" 
.Ldbg_scratch_fmt:
.asciz "SCR drums=%u synth=%u n=%u\n"
.Loutput_silent_msg:
        .asciz "OUTPUT_BUFFER_SILENT\n"
.Loutput_audio_msg:
        .asciz "OUTPUT_BUFFER_HAS_AUDIO\n"
.Lmix_null_msg:
        .asciz "MIX_NULL_POINTER_ERROR\n"
---END---

[NOTDEAFBEEF BLOCKCHAIN BUNDLE - BUNDLE_2_FM_VOICE]
=============================================================
FM synthesis voice (large file)
Generated for on-chain storage following deafbeef methodology.

[MANIFEST]
Bundle: bundle_2_fm_voice
Total files: 1
Files included:
  - audio/fm_voice.s (7745 bytes)

Reconstruction: Save each file to its path and build with provided instructions.

=== FILE: audio/fm_voice.s ===
---BEGIN---
	.section	__TEXT,__const
	.align 2
.L_tau:
	.float 6.283185307
.L_pi:
	.float 3.14159265
.L_six:
	.float 6.0
.L_onehundredtwenty:
	.float 120.0

	.text
	.align 2
	.globl _fm_voice_process

// fm_voice_process(fm_voice_t *v, float32_t *L, float32_t *R, uint32_t n)
// Struct offsets: sr=0, carrier_freq=4, ratio=8, index0=12, amp=16, decay=20
// len=24, pos=28, carrier_phase=32, mod_phase=36
_fm_voice_process:
    // x0 = fm_voice_t *v, x1 = L, x2 = R, x3 = n
    
    // Early exit if pos >= len
    ldr w4, [x0, #28]   // v->pos
    ldr w5, [x0, #24]   // v->len  
    cmp w4, w5
    b.ge .fm_exit
    
    // Load parameters
    ldr s16, [x0, #0]   // v->sr
    ldr s17, [x0, #4]   // v->carrier_freq
    ldr s18, [x0, #8]   // v->ratio
    ldr s19, [x0, #12]  // v->index0
    ldr s20, [x0, #16]  // v->amp
    ldr s21, [x0, #20]  // v->decay
    ldr s22, [x0, #32]  // v->carrier_phase
    ldr s23, [x0, #36]  // v->mod_phase
    
    // Calculate increments: c_inc = TAU * carrier_freq / sr
    adrp x7, .L_tau@PAGE
    add x7, x7, .L_tau@PAGEOFF
    ldr s0, [x7]           // Load TAU
    fmul s24, s0, s17      // TAU * carrier_freq
    fdiv s24, s24, s16     // c_inc = TAU * carrier_freq / sr
    
    // m_inc = TAU * carrier_freq * ratio / sr
    fmul s25, s24, s18     // m_inc = c_inc * ratio
    
    mov w6, #0             // i = 0
    
.fm_loop:
    cmp w6, w3             // i < n?
    b.ge .fm_loop_end
    
    // Check if pos >= len
    ldr w4, [x0, #28]      // v->pos
    ldr w5, [x0, #24]      // v->len
    cmp w4, w5
    b.ge .fm_loop_end
    
    // Calculate envelope: t = pos / sr
    ucvtf s26, w4          // convert pos to float
    fdiv s26, s26, s16     // t = pos / sr
    
    // Simple exponential decay approximation: env ≈ 1.0 / (1.0 + decay * t)
    fmul s27, s21, s26     // decay * t
    fmov s28, #1.0
    fadd s27, s28, s27     // 1.0 + decay * t
    fdiv s27, s28, s27     // env = 1.0 / (1.0 + decay * t)
    
    // Index with envelope: index = index0 * env
    fmul s29, s19, s27     // index = index0 * env
    
    // FM synthesis: sin(carrier_phase + index * sin(mod_phase))
    // Use polynomial approximation for sine waves
    
    // Step 1: Calculate sin(mod_phase) using polynomial approximation
    // Normalize mod_phase to [-π, π] range
    adrp x7, .L_pi@PAGE
    add x7, x7, .L_pi@PAGEOFF
    ldr s30, [x7]          // Load PI
    
    // Wrap mod_phase to [-π, π]
    fmov s31, s23          // s31 = mod_phase
    fcmp s31, s30          // compare with π
    b.le .fm_mod_no_wrap_pos
    fsub s31, s31, s30     // mod_phase - π
    fsub s31, s31, s30     // mod_phase - 2π
.fm_mod_no_wrap_pos:
    fneg s0, s30           // -π
    fcmp s31, s0           // compare with -π
    b.ge .fm_mod_wrapped
    fadd s31, s31, s30     // mod_phase + π
    fadd s31, s31, s30     // mod_phase + 2π
.fm_mod_wrapped:
    
    // Use polynomial sine approximation instead of libm for stability
    // sin(x) ≈ x - x³/6 + x⁵/120 (higher order for better accuracy)
    fmul s0, s31, s31      // x²
    fmul s1, s0, s31       // x³
    fmul s2, s0, s0        // x⁴
    fmul s3, s2, s31       // x⁵
    
    // Calculate x³/6
    adrp x7, .L_six@PAGE
    add x7, x7, .L_six@PAGEOFF
    ldr s4, [x7]
    fdiv s1, s1, s4        // x³/6
    
    // Calculate x⁵/120  
    adrp x7, .L_onehundredtwenty@PAGE
    add x7, x7, .L_onehundredtwenty@PAGEOFF
    ldr s4, [x7]
    fdiv s3, s3, s4        // x⁵/120
    
    // Combine: x - x³/6 + x⁵/120
    fsub s31, s31, s1      // x - x³/6
    fadd s31, s31, s3      // x - x³/6 + x⁵/120
    
    // Step 2: Apply modulation index: index * sin(mod_phase)
    fmul s31, s29, s31     // index * sin(mod_phase)
    
    // Clamp modulation to prevent instability: limit to [-3.0, 3.0]
    fmov s0, #3.0
    fcmp s31, s0
    b.le .fm_mod_clamp_pos_ok
    fmov s31, s0           // clamp to +3.0
.fm_mod_clamp_pos_ok:
    fneg s0, s0            // -3.0
    fcmp s31, s0
    b.ge .fm_mod_clamp_neg_ok
    fmov s31, s0           // clamp to -3.0
.fm_mod_clamp_neg_ok:
    
    // Step 3: Add to carrier phase: carrier_phase + index * sin(mod_phase)
    fadd s31, s22, s31     // carrier_phase + index * sin(mod_phase)
    
    // Step 4: Calculate final sine: sin(carrier_phase + index * sin(mod_phase))
    // Wrap result to [-π, π] range
    fcmp s31, s30          // compare with π
    b.le .fm_carr_no_wrap_pos
    fsub s31, s31, s30     // result - π
    fsub s31, s31, s30     // result - 2π
.fm_carr_no_wrap_pos:
    fneg s0, s30           // -π
    fcmp s31, s0           // compare with -π
    b.ge .fm_carr_wrapped
    fadd s31, s31, s30     // result + π
    fadd s31, s31, s30     // result + 2π
.fm_carr_wrapped:
    
    // Use higher-order polynomial sine approximation  
    // sin(x) ≈ x - x³/6 + x⁵/120 (better accuracy than simple version)
    fmul s0, s31, s31      // x²
    fmul s1, s0, s31       // x³
    fmul s2, s0, s0        // x⁴
    fmul s3, s2, s31       // x⁵
    
    // Calculate x³/6
    adrp x7, .L_six@PAGE
    add x7, x7, .L_six@PAGEOFF
    ldr s4, [x7]
    fdiv s1, s1, s4        // x³/6
    
    // Calculate x⁵/120  
    adrp x7, .L_onehundredtwenty@PAGE
    add x7, x7, .L_onehundredtwenty@PAGEOFF
    ldr s4, [x7]
    fdiv s3, s3, s4        // x⁵/120
    
    // Combine: x - x³/6 + x⁵/120
    fsub s31, s31, s1      // x - x³/6
    fadd s31, s31, s3      // x - x³/6 + x⁵/120
    // s31 now contains the final FM synthesis result
    
    // Apply envelope and amplitude (with scaling to prevent clipping)
    fmul s31, s31, s27     // apply envelope
    fmul s31, s31, s20     // apply amplitude
    fmov s0, #0.25         // Scale down to prevent clipping from FM harmonics  
    fmul s31, s31, s0      // final scaling
    
    // Final safety clamp to prevent amplitude spikes: limit to [-1.0, 1.0]
    fmov s0, #1.0
    fcmp s31, s0
    b.le .fm_out_clamp_pos_ok
    fmov s31, s0           // clamp to +1.0
.fm_out_clamp_pos_ok:
    fneg s0, s0            // -1.0
    fcmp s31, s0
    b.ge .fm_out_clamp_neg_ok
    fmov s31, s0           // clamp to -1.0
.fm_out_clamp_neg_ok:
    
    // Add to output buffers
    ldr s0, [x1, x6, lsl #2]  // L[i]
    fadd s0, s0, s31          // L[i] += sample
    str s0, [x1, x6, lsl #2]  // store L[i]
    
    ldr s0, [x2, x6, lsl #2]  // R[i]
    fadd s0, s0, s31          // R[i] += sample
    str s0, [x2, x6, lsl #2]  // store R[i]
    
    // Update phases
    fadd s22, s22, s24     // carrier_phase += c_inc
    fadd s23, s23, s25     // mod_phase += m_inc
    
    // Keep phases in range [0, TAU] with proper modulo wrapping
    adrp x7, .L_tau@PAGE
    add x7, x7, .L_tau@PAGEOFF
    ldr s0, [x7]           // Load TAU
    
    // Carrier phase proper modulo: phase = phase - TAU * round(phase / TAU)
    fdiv s1, s22, s0       // s1 = carrier_phase / TAU
    frinta s1, s1          // s1 = round(carrier_phase / TAU)
    fmul s1, s1, s0        // s1 = round(carrier_phase / TAU) * TAU
    fsub s22, s22, s1      // carrier_phase = carrier_phase - round_part
    
    // Modulator phase proper modulo: phase = phase - TAU * round(phase / TAU)  
    fdiv s2, s23, s0       // s2 = mod_phase / TAU
    frinta s2, s2          // s2 = round(mod_phase / TAU)
    fmul s2, s2, s0        // s2 = round(mod_phase / TAU) * TAU
    fsub s23, s23, s2      // mod_phase = mod_phase - round_part
    
    // Increment counters
    add w6, w6, #1         // i++
    add w4, w4, #1         // pos++
    str w4, [x0, #28]      // store v->pos
    
    b .fm_loop

.fm_loop_end:
    // Store updated phases
    str s22, [x0, #32]     // v->carrier_phase
    str s23, [x0, #36]     // v->mod_phase

.fm_exit:
    ret

---END---

[CHUNK 1 OF 3]
BUNDLE_3_VISUAL_CORE - PART 1
Concatenate all chunks in order to reconstruct.

[NOTDEAFBEEF BLOCKCHAIN BUNDLE - BUNDLE_3_VISUAL_CORE]
=============================================================
Visual foundation: drawing, colors, ASCII rendering
Generated for on-chain storage following deafbeef methodology.

[MANIFEST]
Bundle: bundle_3_visual_core
Total files: 5
Files included:
  - visual/visual_core.s (7786 bytes)
  - visual/drawing.s (6465 bytes)
  - visual/ascii_renderer.s (13930 bytes)
  - visual/particles.s (14916 bytes)
  - visual/glitch_system.s (19346 bytes)

Reconstruction: Save each file to its path and build with provided instructions.

=== FILE: visual/visual_core.s ===
---BEGIN---
.section __TEXT,__text,regular,pure_instructions
.align 4

// ARM64 Assembly implementation of visual_core.c
// Following the proven methodology from audio engine development

// Constants for floating point operations
.align 4
constants:
float_255:      .float 255.0
float_6:        .float 6.0
float_1:        .float 1.0
float_0:        .float 0.0

//==============================================================================
// uint32_t color_to_pixel(color_t color)
//
// Convert RGBA color struct to 32-bit ARGB pixel
// x0: pointer to color_t struct (r,g,b,a as uint8_t)
// Returns: 32-bit pixel in w0 (ARGB format)
//==============================================================================
.global _color_to_pixel
_color_to_pixel:
    // Load all 4 bytes from color struct
    ldr w1, [x0]              // Load r,g,b,a as 32-bit word
    
    // Extract individual bytes
    ubfx w2, w1, #0, #8       // r = bits 0-7
    ubfx w3, w1, #8, #8       // g = bits 8-15  
    ubfx w4, w1, #16, #8      // b = bits 16-23
    ubfx w5, w1, #24, #8      // a = bits 24-31
    
    // Pack into ARGB format: (a << 24) | (r << 16) | (g << 8) | b
    lsl w5, w5, #24           // a << 24
    lsl w2, w2, #16           // r << 16
    lsl w3, w3, #8            // g << 8
    // b stays as-is (w4)
    
    orr w0, w5, w2            // a | r
    orr w0, w0, w3            // (a | r) | g
    orr w0, w0, w4            // (a | r | g) | b
    
    ret

//==============================================================================
// visual_mode_t get_visual_mode(int bpm)
//
// Determine visual mode based on BPM
// w0: BPM value
// Returns: visual_mode_t enum value in w0
//==============================================================================
.global _get_visual_mode
_get_visual_mode:
    // if (bpm < 70) return VIS_MODE_THICK (0)
    cmp w0, #70
    mov w1, #0                // VIS_MODE_THICK = 0
    b.lt .Lgvm_return
    
    // if (bpm < 100) return VIS_MODE_RINGS (1)  
    cmp w0, #100
    mov w1, #1                // VIS_MODE_RINGS = 1
    b.lt .Lgvm_return
    
    // if (bpm < 130) return VIS_MODE_POLY (2)
    cmp w0, #130
    mov w1, #2                // VIS_MODE_POLY = 2
    b.lt .Lgvm_return
    
    // else return VIS_MODE_LISSA (3)
    mov w1, #3                // VIS_MODE_LISSA = 3

.Lgvm_return:
    mov w0, w1
    ret

//==============================================================================
// color_t hsv_to_rgb(hsv_t hsv)
//
// Convert HSV to RGB color (most complex function)
// x0: pointer to hsv_t struct (h,s,v as float)
// x1: pointer to output color_t struct
//==============================================================================
.global _hsv_to_rgb
_hsv_to_rgb:
    stp x29, x30, [sp, #-32]!
    mov x29, sp
    stp s8, s9, [sp, #16]     // Save callee-saved SIMD registers
    
    // Load HSV values
    ldr s0, [x0]              // h
    ldr s1, [x0, #4]          // s  
    ldr s2, [x0, #8]          // v
    
    // Save output pointer
    mov x2, x1
    
    // Load constants
    adrp x3, constants@PAGE
    add x3, x3, constants@PAGEOFF
    ldr s3, [x3, #12]         // float_0 = 0.0
    ldr s4, [x3, #8]          // float_1 = 1.0  
    ldr s5, [x3, #4]          // float_6 = 6.0
    ldr s6, [x3]              // float_255 = 255.0
    
    // Normalize hue to [0, 1) using fmod equivalent
    // Since we don't have fmod in ASM, we'll implement h = h - floor(h)
    fcvtzs w4, s0             // w4 = (int)h (floor for positive numbers)
    scvtf s7, w4              // s7 = (float)w4
    fsub s0, s0, s7           // h = h - floor(h)
    
    // Handle negative hue
    fcmp s0, s3               // compare h with 0.0
    fadd s8, s0, s4           // s8 = h + 1.0
    fcsel s0, s8, s0, lt      // if h < 0, h = h + 1.0, else h = h
    
    // Clamp saturation to [0, 1]
    fmax s1, s1, s3           // s = max(s, 0.0)
    fmin s1, s1, s4           // s = min(s, 1.0)
    
    // Clamp value to [0, 1]  
    fmax s2, s2, s3           // v = max(v, 0.0)
    fmin s2, s2, s4           // v = min(v, 1.0)
    
    // Calculate sector: i = (int)(h * 6.0)
    fmul s7, s0, s5           // s7 = h * 6.0
    fcvtzs w4, s7             // w4 = i = (int)(h * 6.0)
    
    // Calculate fractional part: f = h * 6.0 - i
    scvtf s8, w4              // s8 = (float)i
    fsub s8, s7, s8           // s8 = f = h * 6.0 - i
    
    // Calculate intermediate values
    fsub s9, s4, s1           // s9 = 1.0 - s
    fmul s9, s2, s9           // p = v * (1.0 - s)
    
    fmul s10, s8, s1          // s10 = f * s
    fsub s11, s4, s10         // s11 = 1.0 - f * s
    fmul s10, s2, s11         // q = v * (1.0 - f * s)
    
    fsub s11, s4, s8          // s11 = 1.0 - f
    fmul s11, s11, s1         // s11 = (1.0 - f) * s
    fsub s11, s4, s11         // s11 = 1.0 - (1.0 - f) * s
    fmul s11, s2, s11         // t = v * (1.0 - (1.0 - f) * s)
    
    // Switch on sector (i % 6)
    mov w5, #6
    udiv w6, w4, w5           // w6 = i / 6
    msub w4, w6, w5, w4       // w4 = i % 6
    
    // Jump table for switch statement
    adr x5, .Lswitch_table
    ldr w6, [x5, w4, uxtw #2] // Load offset for case w4
    add x5, x5, w6, sxtw      // Add offset to base
    br x5                     // Jump to case
    
.Lswitch_table:
    .word .Lcase0 - .Lswitch_table
    .word .Lcase1 - .Lswitch_table
    .word .Lcase2 - .Lswitch_table
    .word .Lcase3 - .Lswitch_table
    .word .Lcase4 - .Lswitch_table
    .word .Lcase5 - .Lswitch_table

.Lcase0:  // r = v, g = t, b = p
    fmov s12, s2              // r = v
    fmov s13, s11             // g = t
    fmov s14, s9              // b = p
    b .Lconvert_to_bytes

.Lcase1:  // r = q, g = v, b = p
    fmov s12, s10             // r = q
    fmov s13, s2              // g = v
    fmov s14, s9              // b = p
    b .Lconvert_to_bytes

.Lcase2:  // r = p, g = v, b = t
    fmov s12, s9              // r = p
    fmov s13, s2              // g = v
    fmov s14, s11             // b = t
    b .Lconvert_to_bytes

.Lcase3:  // r = p, g = q, b = v
    fmov s12, s9              // r = p
    fmov s13, s10             // g = q
    fmov s14, s2              // b = v
    b .Lconvert_to_bytes

.Lcase4:  // r = t, g = p, b = v
    fmov s12, s11             // r = t
    fmov s13, s9              // g = p
    fmov s14, s2              // b = v
    b .Lconvert_to_bytes

.Lcase5:  // r = v, g = p, b = q
    fmov s12, s2              // r = v
    fmov s13, s9              // g = p
    fmov s14, s10             // b = q
    
.Lconvert_to_bytes:
    // Convert float [0,1] to uint8 [0,255]
    fmul s12, s12, s6         // r *= 255.0
    fmul s13, s13, s6         // g *= 255.0  
    fmul s14, s14, s6         // b *= 255.0
    
    // Convert to integers and clamp
    fcvtns w4, s12            // r as int (nearest)
    fcvtns w5, s13            // g as int  
    fcvtns w6, s14            // b as int
    
    // Clamp to [0, 255]
    mov w7, #255
    cmp w4, #0
    csel w4, wzr, w4, lt      // r = max(r, 0)
    cmp w4, w7
    csel w4, w7, w4, gt       // r = min(r, 255)
    
    cmp w5, #0  
    csel w5, wzr, w5, lt      // g = max(g, 0)
    cmp w5, w7
    csel w5, w7, w5, gt       // g = min(g, 255)
    
    cmp w6, #0
    csel w6, wzr, w6, lt      // b = max(b, 0)
    cmp w6, w7
    csel w6, w7, w6, gt       // b = min(b, 255)
    
    // Pack into color_t struct and store
    strb w4, [x2]             // store r
    strb w5, [x2, #1]         // store g
    strb w6, [x2, #2]         // store b
    mov w7, #255
    strb w7, [x2, #3]         // store a = 255
    
    // Return the color struct (x0 already contains return pointer)
    mov x0, x2
    
    ldp s8, s9, [sp, #16]     // Restore callee-saved SIMD registers
    ldp x29, x30, [sp], #32
    ret

---END---

=== FILE: visual/drawing.s ===
---BEGIN---
.section __TEXT,__text,regular,pure_instructions
.align 4

// ARM64 Assembly implementation of drawing.c
// Starting with simple functions following proven methodology

// Constants
.align 4
drawing_constants:
vis_width:      .word 800
vis_height:     .word 600

//==============================================================================
// static void set_pixel(uint32_t *pixels, int x, int y, uint32_t color)
//
// Set a pixel with bounds checking
// x0: pixels buffer pointer
// w1: x coordinate  
// w2: y coordinate
// w3: color (32-bit)
//==============================================================================
.global _set_pixel_asm
_set_pixel_asm:
    // Bounds check: x >= 0 && x < VIS_WIDTH
    cmp w1, #0
    b.lt .Lsp_return          // if x < 0, return
    cmp w1, #800              // VIS_WIDTH
    b.ge .Lsp_return          // if x >= 800, return
    
    // Bounds check: y >= 0 && y < VIS_HEIGHT  
    cmp w2, #0
    b.lt .Lsp_return          // if y < 0, return
    cmp w2, #600              // VIS_HEIGHT
    b.ge .Lsp_return          // if y >= 600, return
    
    // Calculate offset: pixels[y * VIS_WIDTH + x]
    mov w4, #800              // VIS_WIDTH
    mul w5, w2, w4            // y * VIS_WIDTH
    add w5, w5, w1            // y * VIS_WIDTH + x
    
    // Store color at calculated offset
    str w3, [x0, w5, uxtw #2] // pixels[offset] = color (4 bytes per pixel)
    
.Lsp_return:
    ret

//==============================================================================
// void clear_frame(uint32_t *pixels, uint32_t color)
//
// Clear entire frame buffer with specified color
// x0: pixels buffer pointer
// w1: color (32-bit)
//==============================================================================
.global _clear_frame_asm
_clear_frame_asm:
    // Calculate total pixels: VIS_WIDTH * VIS_HEIGHT = 800 * 600 = 480,000
    mov w2, #800              // VIS_WIDTH
    mov w3, #600              // VIS_HEIGHT  
    mul w2, w2, w3            // total pixels
    
    // Use NEON for faster clearing (process 4 pixels at a time)
    dup v0.4s, w1             // Duplicate color into 4 lanes
    
    // Main loop: clear 4 pixels at a time
    mov w3, #0                // counter
.Lcf_loop:
    cmp w3, w2                // compare counter with total
    b.ge .Lcf_done            // if counter >= total, done
    
    // Check if we can process 4 pixels safely
    sub w4, w2, w3            // remaining pixels
    cmp w4, #4
    b.lt .Lcf_single          // if less than 4 remaining, do single pixels
    
    // Store 4 pixels using NEON (calculate byte offset manually)
    lsl x4, x3, #2            // Convert pixel index to byte offset (64-bit)
    str q0, [x0, x4]          // Store 16 bytes (4 pixels)
    add w3, w3, #4            // increment counter by 4
    b .Lcf_loop
    
.Lcf_single:
    // Handle remaining pixels one by one
    cmp w3, w2
    b.ge .Lcf_done
    str w1, [x0, w3, uxtw #2] // Store single pixel
    add w3, w3, #1
    b .Lcf_single
    
.Lcf_done:
    ret

//==============================================================================
// void draw_circle_filled(uint32_t *pixels, int cx, int cy, int radius, uint32_t color)
//
// Draw a filled circle using simple algorithm
// x0: pixels buffer pointer
// w1: center x
// w2: center y  
// w3: radius
// w4: color
//==============================================================================
.global _draw_circle_filled_asm
_draw_circle_filled_asm:
    stp x29, x30, [sp, #-32]!
    mov x29, sp
    stp w19, w20, [sp, #16]   // Save callee-saved registers
    stp w21, w22, [sp, #20]
    stp w23, w24, [sp, #24]
    
    // Save parameters
    mov x19, x0               // pixels
    mov w20, w1               // cx
    mov w21, w2               // cy
    mov w22, w3               // radius
    mov w23, w4               // color
    
    // Outer loop: y from -radius to +radius
    neg w24, w22              // y = -radius
    
.Ldcf_y_loop:
    cmp w24, w22              // compare y with radius
    b.gt .Ldcf_done           // if y > radius, done
    
    // Inner loop: x from -radius to +radius
    neg w25, w22              // x = -radius
    
.Ldcf_x_loop:
    cmp w25, w22              // compare x with radius
    b.gt .Ldcf_y_next         // if x > radius, next y
    
    // Check if point is inside circle: x*x + y*y <= radius*radius
    mul w26, w25, w25         // x * x
    mul w27, w24, w24         // y * y  
    add w26, w26, w27         // x*x + y*y
    mul w27, w22, w22         // radius * radius
    cmp w26, w27              // compare x*x + y*y with radius*radius
    b.gt .Ldcf_x_next         // if outside circle, skip
    
    // Point is inside circle, draw pixel
    add w1, w20, w25          // pixel_x = cx + x
    add w2, w21, w24          // pixel_y = cy + y
    mov x0, x19               // pixels buffer
    mov w3, w23               // color
    bl _set_pixel_asm         // call set_pixel_asm
    
.Ldcf_x_next:
    add w25, w25, #1          // x++
    b .Ldcf_x_loop
    
.Ldcf_y_next:
    add w24, w24, #1          // y++
    b .Ldcf_y_loop
    
.Ldcf_done:
    ldp w23, w24, [sp, #24]   // Restore callee-saved registers
    ldp w21, w22, [sp, #20]
    ldp w19, w20, [sp, #16]
    ldp x29, x30, [sp], #32
    ret

//==============================================================================
// uint32_t circle_color(float base_hue, float saturation, float value)
//
// Helper function to create circle color with hue variation
// s0: base_hue
// s1: saturation
// s2: value
// Returns: color in w0
//==============================================================================
.global _circle_color_asm
_circle_color_asm:
    stp x29, x30, [sp, #-48]!
    mov x29, sp
    
    // Create HSV struct on stack at [sp, #16] (12 bytes: 3 floats)
    str s0, [sp, #16]         // h at [sp, #16]
    str s1, [sp, #20]         // s at [sp, #20] 
    str s2, [sp, #24]         // v at [sp, #24]
    
    // Call hsv_to_rgb
    add x0, sp, #16           // pointer to HSV struct on stack
    add x1, sp, #32           // pointer to output color_t on stack (4 bytes: r,g,b,a)
    bl _hsv_to_rgb            // Call the existing HSV to RGB function
    
    // Call color_to_pixel
    add x0, sp, #32           // pointer to color_t struct
    bl _color_to_pixel        // Call the existing color to pixel function
    
    // Return value already in w0
    ldp x29, x30, [sp], #48
    ret

---END---

=== FILE: visual/ascii_renderer.s ===
---BEGIN---
//==============================================================================
// ASCII Renderer - ARM64 Assembly Implementation
//
// Port of ascii_renderer.c to pure ARM64 assembly
// Functions for bitmap font rendering
//==============================================================================

.text
.align 4

//==============================================================================
// Constants
//==============================================================================
ascii_constants:
char_width:     .word 8
char_height:    .word 8 
vis_width:      .word 800
vis_height:     .word 600

//==============================================================================
// ASCII Font Data - 8x8 bitmap font
// Each character uses 2 uint32 values (64 bits total)
// 256 characters arranged in 16x16 grid
//==============================================================================
.align 4
ascii_font:
    // Character row 0 (chars 0-15)
    .word 0x00000000, 0x00000000  // char 0 0x00
    .word 0x00000000, 0x00000000  // char 1 0x01
    .word 0x00000000, 0x00000000  // char 2 0x02
    .word 0x00000000, 0x00000000  // char 3 0x03
    .word 0x00000000, 0x00000000  // char 4 0x04
    .word 0x00000000, 0x00000000  // char 5 0x05
    .word 0x00000000, 0x00000000  // char 6 0x06
    .word 0x00000000, 0x00000000  // char 7 0x07
    .word 0x00000000, 0x00000000  // char 8 0x08
    .word 0x00000000, 0x00000000  // char 9 0x09
    .word 0x00000000, 0x00000000  // char 10 0x0a
    .word 0x00000000, 0x00000000  // char 11 0x0b
    .word 0x00000000, 0x00000000  // char 12 0x0c
    .word 0x00000000, 0x00000000  // char 13 0x0d
    .word 0x00000000, 0x00000000  // char 14 0x0e
    .word 0x00000000, 0x00000000  // char 15 0x0f
    
    // Character row 1 (chars 16-31)
    .word 0x00000000, 0x00000000  // char 16 0x10
    .word 0x00000000, 0x00000000  // char 17 0x11
    .word 0x00000000, 0x00000000  // char 18 0x12
    .word 0x00000000, 0x00000000  // char 19 0x13
    .word 0x00000000, 0x00000000  // char 20 0x14
    .word 0x00000000, 0x00000000  // char 21 0x15
    .word 0x00000000, 0x00000000  // char 22 0x16
    .word 0x00000000, 0x00000000  // char 23 0x17
    .word 0x00000000, 0x00000000  // char 24 0x18
    .word 0x00000000, 0x00000000  // char 25 0x19
    .word 0x00000000, 0x00000000  // char 26 0x1a
    .word 0x00000000, 0x00000000  // char 27 0x1b
    .word 0x00000000, 0x00000000  // char 28 0x1c
    .word 0x00000000, 0x00000000  // char 29 0x1d
    .word 0x00000000, 0x00000000  // char 30 0x1e
    .word 0x00000000, 0x00000000  // char 31 0x1f
    
    // Character row 2 (chars 32-47) - Basic symbols
    .word 0x00000000, 0x00000000  // char 32 ' ' space
    .word 0x00000000, 0x00000000  // char 33 '!' 
    .word 0x00000000, 0x00000000  // char 34 '"'
    .word 0x24247e24, 0x0000247e  // char 35 '#' hash
    .word 0x00000000, 0x00000000  // char 36 '$'
    .word 0x00000000, 0x00000000  // char 37 '%'
    .word 0x00000000, 0x00000000  // char 38 '&'
    .word 0x00000000, 0x00000000  // char 39 '\''
    .word 0x00000000, 0x00000000  // char 40 '('
    .word 0x00000000, 0x00000000  // char 41 ')'
    .word 0x7c284400, 0x00004428  // char 42 '*' asterisk
    .word 0x7c101000, 0x00001010  // char 43 '+' plus
    .word 0x00000000, 0x00000000  // char 44 ','
    .word 0x7c000000, 0x00000000  // char 45 '-' minus
    .word 0x00000000, 0x00000000  // char 46 '.'
    .word 0x10080402, 0x00804020  // char 47 '/' slash
    
    // Character row 3 (chars 48-63) - Numbers and symbols
    .word 0x42424242, 0x007e4242  // char 48 '0'
    .word 0x42424242, 0x007e4242  // char 49 '1'
    .word 0x42424242, 0x007e4242  // char 50 '2'
    .word 0x42424242, 0x007e4242  // char 51 '3'
    .word 0x42424242, 0x007e4242  // char 52 '4'
    .word 0x42424242, 0x007e4242  // char 53 '5'
    .word 0x42424242, 0x007e4242  // char 54 '6'
    .word 0x42424242, 0x007e4242  // char 55 '7'
    .word 0x42424242, 0x007e4242  // char 56 '8'
    .word 0x42424242, 0x007e4242  // char 57 '9'
    .word 0x00000000, 0x00000000  // char 58 ':'
    .word 0x00000000, 0x00000000  // char 59 ';'
    .word 0x20100800, 0x00000810  // char 60 '<' less than
    .word 0x007c0000, 0x0000007c  // char 61 '=' equals
    .word 0x08102000, 0x00002010  // char 62 '>' greater than
    .word 0x00000000, 0x00000000  // char 63 '?'
    
    // Character row 4 (chars 64-79) - @ and uppercase letters A-O
    .word 0x00000000, 0x00000000  // char 64 '@'
    .word 0x4242427e, 0x007e4242  // char 65 'A'
    .word 0x4242427e, 0x007e4242  // char 66 'B'
    .word 0x4242427e, 0x007e4242  // char 67 'C'
    .word 0x4242427e, 0x007e4242  // char 68 'D'
    .word 0x4242427e, 0x007e4242  // char 69 'E'
    .word 0x4242427e, 0x007e4242  // char 70 'F'
    .word 0x4242427e, 0x007e4242  // char 71 'G'
    .word 0x4242427e, 0x007e4242  // char 72 'H'
    .word 0x4242427e, 0x007e4242  // char 73 'I'
    .word 0x4242427e, 0x007e4242  // char 74 'J'
    .word 0x4242427e, 0x007e4242  // char 75 'K'
    .word 0x4242427e, 0x007e4242  // char 76 'L'
    .word 0x4242427e, 0x007e4242  // char 77 'M'
    .word 0x4242427e, 0x007e4242  // char 78 'N'
    .word 0x4242427e, 0x007e4242  // char 79 'O'
    
    // Character row 5 (chars 80-95) - Letters P-Z and brackets
    .word 0x4242427e, 0x007e4242  // char 80 'P'
    .word 0x4242427e, 0x007e4242  // char 81 'Q'
    .word 0x4242427e, 0x007e4242  // char 82 'R'
    .word 0x4242427e, 0x007e4242  // char 83 'S'
    .word 0x4242427e, 0x007e4242  // char 84 'T'
    .word 0x4242427e, 0x007e4242  // char 85 'U'
    .word 0x4242427e, 0x007e4242  // char 86 'V'
    .word 0x4242427e, 0x007e4242  // char 87 'W'
    .word 0x4242427e, 0x007e4242  // char 88 'X'
    .word 0x4242427e, 0x007e4242  // char 89 'Y'
    .word 0x4242427e, 0x007e4242  // char 90 'Z'
    .word 0x4040407c, 0x007c4040  // char 91 '[' left bracket
    .word 0x10204080, 0x00020408  // char 92 '\' backslash
    .word 0x0404047c, 0x007c0404  // char 93 ']' right bracket
    .word 0x44281000, 0x00000000  // char 94 '^' caret
    .word 0x00000000, 0x007c0000  // char 95 '_' underscore
    
    // Character row 6 (chars 96-111) - lowercase and more symbols
    .word 0x00000000, 0x00000000  // char 96 '`'
    .word 0x00000000, 0x00000000  // char 97 'a'
    .word 0x00000000, 0x00000000  // char 98 'b'
    .word 0x00000000, 0x00000000  // char 99 'c'
    .word 0x00000000, 0x00000000  // char 100 'd'
    .word 0x00000000, 0x00000000  // char 101 'e'
    .word 0x00000000, 0x00000000  // char 102 'f'
    .word 0x00000000, 0x00000000  // char 103 'g'
    .word 0x00000000, 0x00000000  // char 104 'h'
    .word 0x00000000, 0x00000000  // char 105 'i'
    .word 0x00000000, 0x00000000  // char 106 'j'
    .word 0x00000000, 0x00000000  // char 107 'k'
    .word 0x00000000, 0x00000000  // char 108 'l'
    .word 0x00000000, 0x00000000  // char 109 'm'
    .word 0x00000000, 0x00000000  // char 110 'n'
    .word 0x00000000, 0x00000000  // char 111 'o'
    
    // Character row 7 (chars 112-127) - more lowercase and special chars
    .word 0x00000000, 0x00000000  // char 112 'p'
    .word 0x00000000, 0x00000000  // char 113 'q'
    .word 0x00000000, 0x00000000  // char 114 'r'
    .word 0x00000000, 0x00000000  // char 115 's'
    .word 0x00000000, 0x00000000  // char 116 't'
    .word 0x00000000, 0x00000000  // char 117 'u'
    .word 0x00000000, 0x00000000  // char 118 'v'
    .word 0x00000000, 0x00000000  // char 119 'w'
    .word 0x00000000, 0x00000000  // char 120 'x'
    .word 0x00000000, 0x00000000  // char 121 'y'
    .word 0x00000000, 0x00000000  // char 122 'z'
    .word 0x4020201c, 0x001c2020  // char 123 '{' left brace
    .word 0x10101010, 0x00101010  // char 124 '|' pipe
    .word 0x04080870, 0x00700808  // char 125 '}' right brace
    .word 0x004c3200, 0x00000000  // char 126 '~' tilde
    .word 0x00000000, 0x00000000  // char 127

    // Rows 8-15 (chars 128-255) - Extended ASCII filled with blanks
    .rept 128
    .word 0x00000000, 0x00000000
    .endr

//==============================================================================
// void draw_ascii_char_asm(uint32_t *pixels, int x, int y, char c, uint32_t color, int alpha)
//
// Draw a single ASCII character at position with color and alpha blending
// x0: pixels buffer
// w1: x position  
// w2: y position
// w3: character (char c)
// w4: color (uint32_t)
// w5: alpha (int, 0-255)
//==============================================================================
.global _draw_ascii_char_asm
_draw_ascii_char_asm:
    stp x29, x30, [sp, #-96]!
    mov x29, sp
    
    // Save callee-saved registers with proper non-overlapping offsets
    stp x19, x20, [sp, #16]    // 16-31
    stp x21, x22, [sp, #32]    // 32-47  
    stp x23, x24, [sp, #48]    // 48-63
    stp x25, x26, [sp, #64]    // 64-79
    stp x27, x28, [sp, #80]    // 80-95
    
    // Store parameters in callee-saved registers
    mov x19, x0               // pixels buffer
    mov w20, w1               //[CHUNK 2 OF 3]
BUNDLE_3_VISUAL_CORE - PART 2
Concatenate all chunks in order to reconstruct.

 x position
    mov w21, w2               // y position  
    mov w22, w3               // character
    mov w23, w4               // color
    mov w24, w5               // alpha
    
    // Bounds check: character range 0-255 (now support full range)
    cmp w22, #0
    b.lt .Ldac_return         // if c < 0, return
    cmp w22, #255
    b.gt .Ldac_return         // if c > 255, return
    
    // Bounds check: position within screen
    cmp w20, #0
    b.lt .Ldac_return
    ldr w25, =800             // VIS_WIDTH
    cmp w20, w25
    b.ge .Ldac_return
    
    cmp w21, #0
    b.lt .Ldac_return
    ldr w25, =600             // VIS_HEIGHT  
    cmp w21, w25
    b.ge .Ldac_return
    
    // Get character bitmap from new 8x8 font
    // Each character uses 2 uint32 values (64 bits)
    // Font layout: char_index * 8 bytes = char_index * 2 words
    lsl w25, w22, #3          // char_index * 8 (bytes per char)
    adr x26, ascii_font       // Get font base address
    add x26, x26, x25         // Point to character data
    
    // Load character bitmap (2 words = 8 bytes)
    ldp w27, w28, [x26]       // w27 = first 4 bytes, w28 = last 4 bytes
    
    // OPTIMIZATION: Fast path for alpha==255 (90-95% of calls)
    cmp w24, #255
    b.eq .Ldac_alpha_opaque
    
    // Alpha blending path for alpha < 255  
    // Extract RGB components from color for alpha blending
    ubfx w25, w23, #16, #8    // r = (color >> 16) & 0xFF
    ubfx w26, w23, #8, #8     // g = (color >> 8) & 0xFF  
    ubfx w27, w23, #0, #8     // b = color & 0xFF
    
    // Apply alpha: component = (component * alpha) / 255
    mul w25, w25, w24         // r * alpha
    mov w0, #255
    udiv w25, w25, w0         // r = (r * alpha) / 255
    
    mul w26, w26, w24         // g * alpha  
    udiv w26, w26, w0         // g = (g * alpha) / 255
    
    mul w27, w27, w24         // b * alpha
    udiv w27, w27, w0         // b = (b * alpha) / 255
    
    // Reconstruct final color: 0xFF000000 | (r << 16) | (g << 8) | b
    mov w28, #0xFF            
    lsl w28, w28, #24         // Alpha = 0xFF000000
    lsl w25, w25, #16         // r << 16
    lsl w26, w26, #8          // g << 8
    orr w28, w28, w25         // Add red
    orr w28, w28, w26         // Add green  
    orr w28, w28, w27         // Add blue - final color in w28
    b .Ldac_render_bitmap
    
.Ldac_alpha_opaque:
    // Fast path: alpha==255, use color directly  
    orr w28, w23, #0xFF000000 // final color = color | 0xFF000000
    
.Ldac_render_bitmap:
    
    // Now render the 8x8 character
    // Reload character bitmap
    lsl w25, w22, #3          // char_index * 8
    adr x26, ascii_font       // Get font base address
    add x26, x26, x25
    ldp w6, w7, [x26]         // w6 = rows 0-3, w7 = rows 4-7
    
    // Render each row of the 8x8 character
    mov w0, #0                // row counter
.Ldac_row_loop:
    cmp w0, #8
    b.ge .Ldac_return
    
    // Get row data - need to extract correct byte from w6 or w7
    cmp w0, #4
    b.ge .Ldac_upper_rows
    
    // Lower rows (0-3): extract from w6
    lsl w2, w0, #3            // row * 8
    lsr w1, w6, w2            // shift by row*8 bits
    and w1, w1, #0xFF         // mask to get byte
    b .Ldac_process_row
    
.Ldac_upper_rows:
    // Upper rows (4-7): extract from w7  
    sub w2, w0, #4            // row - 4
    lsl w2, w2, #3            // (row-4) * 8
    lsr w1, w7, w2            // shift by (row-4)*8 bits
    and w1, w1, #0xFF         // mask to get byte
    
.Ldac_process_row:
    // w1 now contains the row bitmap byte
    mov w2, #0                // column counter
    
.Ldac_col_loop:
    cmp w2, #8
    b.ge .Ldac_next_row
    
    // Check if pixel should be drawn
    mov w3, #7
    sub w3, w3, w2            // bit position (7-col for MSB first)
    lsr w4, w1, w3            // shift pixel bit to position 0
    and w4, w4, #1            // mask to get single bit
    
    cbz w4, .Ldac_next_col    // skip if pixel is 0
    
    // Calculate pixel position
    add w5, w20, w2           // pixel_x = char_x + col
    add w6, w21, w0           // pixel_y = char_y + row
    
    // OPTIMIZATION: Skip redundant per-pixel bounds checks
    // Caller already guarantees character is fully on-screen
    
    // Calculate pixel offset: y * width + x
    ldr w25, =800             // width
    mul w6, w6, w25           // y * width
    add w6, w6, w5            // + x
    lsl w6, w6, #2            // * 4 (bytes per pixel)
    
    // Set pixel
    str w28, [x19, x6]        // pixels[offset] = color
    
.Ldac_next_col:
    add w2, w2, #1
    b .Ldac_col_loop
    
.Ldac_next_row:
    add w0, w0, #1
    b .Ldac_row_loop
    
.Ldac_return:
    // Restore callee-saved registers  
    ldp x27, x28, [sp, #80]
    ldp x25, x26, [sp, #64]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    
    ldp x29, x30, [sp], #96
    ret

---END---

=== FILE: visual/particles.s ===
---BEGIN---
//==============================================================================
// Particles System - ARM64 Assembly Implementation
//
// Port of particles.c to pure ARM64 assembly
// Functions for physics-based particle effects
//==============================================================================

.text
.align 4

//==============================================================================
// Constants
//==============================================================================
particle_constants:
max_particles:          .word 256
particle_spawn_count:   .word 20
char_count:            .word 47
vis_width:             .word 800
vis_height:            .word 600
gravity_int:           .word 0x3DCCCCCD    // 0.1f as IEEE 754 float

//==============================================================================
// Read-only data
//==============================================================================
.align 4

// SAW_STEPS array (read-only)
saw_steps:
    .word 0, 8, 16, 24
saw_steps_count: .word 4

// Character set for particles (read-only)
particle_chars:
    .ascii "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*+-=?\0"

//==============================================================================
// Mutable data section - writable memory
//==============================================================================
.section __DATA,__data
.align 5                        // 32-byte alignment

.global particles_array
particles_array:
    .space (256 * 32), 0       // 256 particles, 32 bytes each = 8KB

particles_initialized:
    .word 0

last_step:
    .word -1

.text  // Return to text section for function definitions

//==============================================================================
// External function declarations
//==============================================================================
// From visual_core.s
.extern _hsv_to_rgb
.extern _color_to_pixel

// From ascii_renderer.s  
.extern _draw_ascii_char_asm

//==============================================================================
// void init_particles_asm(void)
//
// Initialize particle system
//==============================================================================
.align 4
.global _init_particles_asm
_init_particles_asm:
    stp x29, x30, [sp, #-32]!
    mov x29, sp
    
    // Check if already initialized
    adrp x0, particles_initialized@PAGE
    add x0, x0, particles_initialized@PAGEOFF
    ldr w1, [x0]
    cbnz w1, .Lip_return
    
    // Clear all particles (set active = false)
    adrp x0, particles_array@PAGE
    add x0, x0, particles_array@PAGEOFF
    mov w1, #256                // MAX_PARTICLES
    mov w2, #32                 // Size per particle (aligned)
    
.Lip_clear_loop:
    cbz w1, .Lip_done_clear
    
    // Set active flag (offset +29) to false
    strb wzr, [x0, #29]
    
    add x0, x0, #32             // Move to next particle
    sub w1, w1, #1
    b .Lip_clear_loop
    
.Lip_done_clear:
    // Mark as initialized
    adrp x0, particles_initialized@PAGE
    add x0, x0, particles_initialized@PAGEOFF
    mov w1, #1
    str w1, [x0]
    
.Lip_return:
    ldp x29, x30, [sp], #32
    ret

//==============================================================================
// bool is_saw_step_asm(int step)
//
// Check if step is a saw step (particle explosion trigger)
// w0: step
// Returns: w0 = 1 if saw step, 0 otherwise
//==============================================================================
.align 4
.global _is_saw_step_asm
_is_saw_step_asm:
    // step32 = step % 32
    and w0, w0, #31             // Efficient modulo 32 using bit mask
    
    // Check against SAW_STEPS array
    adr x1, saw_steps
    mov w2, #4                  // SAW_STEPS_COUNT
    
.Liss_check_loop:
    cbz w2, .Liss_not_found
    
    ldr w3, [x1], #4            // Load saw step value and advance
    cmp w0, w3
    b.eq .Liss_found
    
    sub w2, w2, #1
    b .Liss_check_loop
    
.Liss_not_found:
    mov w0, #0
    ret
    
.Liss_found:
    mov w0, #1
    ret

//==============================================================================
// void spawn_explosion_asm(float cx, float cy, float base_hue)
//
// Spawn particle explosion at given position
// s0: cx (center x)
// s1: cy (center y)  
// s2: base_hue
//==============================================================================
.align 4
.global _spawn_explosion_asm
_spawn_explosion_asm:
    stp x29, x30, [sp, #-96]!
    mov x29, sp
    
    // Save callee-saved registers
    stp x19, x20, [sp, #16]     // 16-31
    stp x21, x22, [sp, #32]     // 32-47
    stp x23, x24, [sp, #48]     // 48-63
    stp x25, x26, [sp, #64]     // 64-79
    stp x27, x28, [sp, #80]     // 80-95
    
    // Save floating point parameters
    str s0, [sp, #88]           // cx
    str s1, [sp, #92]           // cy
    // s2 (base_hue) will be used throughout
    
    mov w19, #20                // PARTICLE_SPAWN_COUNT
    mov w20, #0                 // Loop counter i
    
.Lse_spawn_loop:
    cmp w20, w19
    b.ge .Lse_return
    
    // Find free particle slot
    adrp x21, particles_array@PAGE
    add x21, x21, particles_array@PAGEOFF
    mov w22, #256               // MAX_PARTICLES
    mov w23, #0                 // j counter
    mov x24, #-1                // slot = -1
    
.Lse_find_slot:
    cmp w23, w22
    b.ge .Lse_slot_found
    
    // Check if particle[j].active is false
    mov w25, #32                // Particle size
    mul w26, w23, w25           // j * particle_size
    add x27, x21, w26, uxtw     // &particles[j]
    ldrb w28, [x27, #29]        // Load active flag
    cbz w28, .Lse_free_slot
    
    add w23, w23, #1            // j++
    b .Lse_find_slot
    
.Lse_free_slot:
    mov x24, x27                // slot = &particles[j]
    
.Lse_slot_found:
    cmp x24, #-1
    b.eq .Lse_return            // No free slots
    
    // Calculate explosion parameters
    // angle = 2.0 * PI * i / PARTICLE_SPAWN_COUNT
    scvtf s3, w20               // Convert i to float
    fmov s4, #20.0              // PARTICLE_SPAWN_COUNT as float
    fdiv s3, s3, s4             // i / PARTICLE_SPAWN_COUNT
    
    ldr w25, =0x40C90FDB        // 2*PI as IEEE 754 float
    fmov s4, w25
    fmul s3, s3, s4             // angle = 2*PI * i / PARTICLE_SPAWN_COUNT
    
    // Calculate cos(angle) and sin(angle) - simplified approximation
    // For demo purposes, using simplified trig (could be enhanced with lookup tables)
    
    // Store particle data
    ldr s4, [sp, #88]           // cx
    str s4, [x24, #0]           // p->x = cx
    ldr s4, [sp, #92]           // cy  
    str s4, [x24, #4]           // p->y = cy
    
    // Simple velocity calculation (simplified for now)
    fmov s4, #2.0               // Base speed
    str s4, [x24, #8]           // p->vx = speed (simplified)
    fmov s4, #1.0
    str s4, [x24, #12]          // p->vy = speed (simplified)
    
    // Set life (simplified - use fixed life for now)
    mov w25, #60
    str w25, [x24, #16]         // p->life = 60
    str w25, [x24, #20]         // p->max_life = 60
    
    // Set character (simplified - use 'A' for now)
    mov w25, #65                // 'A'
    strb w25, [x24, #24]        // p->character = 'A'
    
    // Set color (simplified - use red for now)
    mov w25, #255
    strb w25, [x24, #25]        // r = 255
    strb wzr, [x24, #26]        // g = 0
    strb wzr, [x24, #27]        // b = 0
    strb w25, [x24, #28]        // a = 255
    
    // Set active = true
    mov w25, #1
    strb w25, [x24, #29]        // p->active = true
    
    add w20, w20, #1            // i++
    b .Lse_spawn_loop
    
.Lse_return:
    // Restore callee-saved registers
    ldp x27, x28, [sp, #80]
    ldp x25, x26, [sp, #64]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #96
    ret

//==============================================================================
// void update_particles_asm(float elapsed_ms, float step_sec, float base_hue)
//
// Update particle physics and spawn explosions
// s0: elapsed_ms
// s1: step_sec
// s2: base_hue
//==============================================================================
.align 4
.global _update_particles_asm
_update_particles_asm:
    stp x29, x30, [sp, #-96]!
    mov x29, sp
    
    // Save callee-saved registers
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    stp x25, x26, [sp, #64]
    stp x27, x28, [sp, #80]
    
    // Check if initialized
    adrp x19, particles_initialized@PAGE
    add x19, x19, particles_initialized@PAGEOFF
    ldr w20, [x19]
    cbz w20, .Lup_return
    
    // Calculate current step: (int)(elapsed_ms / 1000.0 / step_sec) % 32
    ldr w25, =0x447A0000        // 1000.0f as IEEE 754 float
    fmov s3, w25
    fdiv s0, s0, s3             // elapsed_ms / 1000.0
    fdiv s0, s0, s1             // / step_sec
    fcvtms w21, s0              // Convert to int
    and w21, w21, #31           // % 32
    
    // Check if this is a saw step and different from last step
    mov w0, w21
    bl _is_saw_step_asm
    cbz w0, .Lup_skip_spawn
    
    adrp x22, last_step@PAGE
    add x22, x22, last_step@PAGEOFF
    ldr w23, [x22]
    cmp w21, w23
    b.eq .Lup_skip_spawn
    
    // Update last_step
    str w21, [x22]
    
    // Spawn explosion at random position
    // cx = VIS_WIDTH * 0.3 + random * (VIS_WIDTH * 0.4)  
    // cy = VIS_HEIGHT * 0.2 + random * (VIS_HEIGHT * 0.3)
    // Simplified: use fixed position for now
    ldr w25, =0x43C80000        // 400.0f as IEEE 754 float
    fmov s0, w25                // cx = 400 (center of 800)
    ldr w25, =0x43480000        // 200.0f as IEEE 754 float
    fmov s1, w25                // cy = 200 (upper area of 600)
    // s2 already has base_hue
    bl _spawn_explosion_asm
    
.Lup_skip_spawn:
    // Update all active particles
    adrp x19, particles_array@PAGE
    add x19, x19, particles_array@PAGEOFF
    mov w20, #256               // MAX_PARTICLES
    mov w21, #0                 // Loop counter
    
.Lup_particle_loop:
    cmp w21, w20
    b.ge .Lup_return
    
    // Calculate particle pointer
    mov w22, #32                // Particle size  
    mul w23, w21, w22           // i * particle_size
    add x24, x19, w23, uxtw     // &particles[i]
    
    // Check if active
    ldrb w25, [x24, #29]
    cbz w25, .Lup_next_particle
    
    // Update physics: x += vx, y += vy, vy += gravity
    ldr s0, [x24, #0]           // x
    ldr s1, [x24, #8]           // vx
    fadd s0, s0, s1             // x += vx
    str s0, [x24, #0]
    
    ldr s0, [x24, #4]           // y
    ldr s1, [x24, #12]          // vy
    fadd s0, s0, s1             // y += vy
    str s0, [x24, #4]
    
    // vy += gravity (0.1f)
    adr x25, gravity_int
    ldr w26, [x25]
    fmov s2, w26                // Load gravity as float
    fadd s1, s1, s2             // vy += gravity
    str s1, [x24, #12]
    
    // Update life: life--
    ldr w25, [x24, #16]         // life
    sub w25, w25, #1
    str w25, [x24, #16]
    
    // Check if life expired
    cmp w25, #0
    b.gt .Lup_next_particle
    
    // Deactivate particle
    strb wzr, [x24, #29]        // active = false
    
.Lup_next_particle:
    add w21, w21, #1
    b .Lup_particle_loop
    
.Lup_return:
    // Restore callee-saved registers
    ldp x27, x28, [sp, #80]
    ldp x25, x26, [sp, #64]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #96
    ret

//==============================================================================
// void draw_particles_asm(uint32_t *pixels)
//
// Draw all active particles
// x0: pixels buffer
//==============================================================================
.align 4
.global _draw_particles_asm
_draw_particles_asm:
    stp x29, x30, [sp, #-96]!
    mov x29, sp
    
    // Save callee-saved registers
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    stp x25, x26, [sp, #64]
    stp x27, x28, [sp, #80]
    
    mov x19, x0                 // Save pixels buffer
    
    // Check if initialized
    adrp x20, particles_initialized@PAGE
    add x20, x20, particles_initialized@PAGEOFF
    ldr w21, [x20]
    cbz w21, .Ldp_return
    
    // Loop through all particles
    adrp x20, particles_array@PAGE
    add x20, x20, particles_array@PAGEOFF
    mov w21, #256               // MAX_PARTICLES
    mov w22, #0                 // Loop counter
    
.Ldp_particle_loop:
    cmp w22, w21
    b.ge .Ldp_return
    
    // Calculate particle pointer
    mov w23, #32                // Particle size
    mul w24, w22, w23           // i * particle_size
    add x25, x20, w24, uxtw     // &particles[i]
    
    // Check if active and life > 0
    ldrb w26, [x25, #29]        // active
    cbz w26, .Ldp_next_particle
    
    ldr w26, [x25, #16]         // life
    cmp w26, #0
    b.le .Ldp_next_particle
    
    // Calculate alpha: (255 * life) / max_life
    ldr w27, [x25, #20]         // max_life
    mov w28, #255
    mul w26, w26, w28           // life * 255
    udiv w26, w26, w27          // alpha = (life * 255) / max_life
    
    // Get color components
    ldrb w1, [x25, #25]         // r
    ldrb w2, [x25, #26]         // g
    ldrb w3, [x25, #27]         // b
    ldrb w4, [x25, #28]         // a
    
    // Pack color: (a << 24) | (r << 16) | (g << 8) | b
    lsl w4, w4, #24             // a << 24
    lsl w1, w1, #16             // r << 16
    lsl w2, w2, #8              // g << 8
    orr w4, w4, w1              // Combine a and r
    orr w4, w4, w2              // Combine g
    orr w4, w4, w3              // Combine b
    
    // Call draw_ascii_char_asm
    mov x0, x19                 // pixels buffer
    ldr s1, [x25, #0]           // x position
    fcvtms w1, s1               // Convert to int
    ldr s2, [x25, #4]           // y position  
    fcvtms w2, s2               // Convert to int
    ldrb w3, [x25, #24]         // character
    // w4 already has color
    mov w5, w26                 // alpha
    bl _draw_ascii_char_asm
    
.Ldp_next_particle:
    add w22, w22, #1
    b .Ldp_particle_loop
    
.Ldp_return:
    // Restore callee-saved registers
    ldp x27, x28, [sp, #80]
    ldp x25, x26, [sp, #64]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #96
    ret

//==============================================================================
// void reset_particle_step_tracking_asm(void)
//
// Reset particle step tracking
//==============================================================================
.align 4
.global _reset_particle_step_tracking_asm
_reset_particle_step_tracking_asm:
    adrp x0, last_step@PAGE
    add x0, x0, last_step@PAGEOFF
    mov w1, #-1
    str w1, [x0]
    ret

---END---

=== FILE: visual/glitch_system.s ===
---BEGIN---
.arch armv8-a

// Glitch System ARM64 Assembly Implementation
// Based on glitch_system.c - Final visual component!

.section __DATA,__data
.align 3

// Character arrays for different glitch types
terrain_glitch_chars:
    .ascii "#=-%*+~^|\\/<>[]{}()\0"

shape_glitch_chars:
    .ascii "@#*+=-|\\/<>^~`'\".:;!?\0"

digital_noise_chars:
    .ascii "01234567890123456789abcdefABCDEF!@#$%^&*\0"

matrix_chars:
    .ascii "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*+-=\0"

// Glitch configuration structure
// typedef struct {
//     float terrain_glitch_rate;    // offset 0
//     float shape_glitch_rate;      // offset 4
//     float digital_noise_rate;     // offset 8
//     float glitch_intensity;       // offset 12
//     uint32_t glitch_seed;         // offset 16
// } glitch_config_t;
.align 2
glitch_config:
    .space 20, 0                  // 5 * 4 bytes = 20 bytes

glitch_initialized:
    .word 0                       // bool as 32-bit word

// Constants for glitch calculations
.align 2
.Lconst_0_1:
    .float 0.1
.Lconst_0_4:
    .float 0.4
.Lconst_0_05:
    .float 0.05
.Lconst_0_3:
    .float 0.3
.Lconst_10000_0:
    .float 10000.0
.Lconst_0_02:
    .float 0.02
.Lconst_decaf:
    .word 0xDECAF
.Lconst_lcg_mult:
    .word 1664525
.Lconst_lcg_add:
    .word 1013904223

.text

//==============================================================================
// init_glitch_system_asm
// Initialize glitch system with seed and intensity
// Input: w0 = seed (uint32_t), s0 = intensity (float)
// Output: None
//==============================================================================
.global _init_glitch_system_asm
_init_glitch_system_asm:
    stp x29, x30, [sp, #-32]!
    mov x29, sp
    
    // Check if already initialized
    adrp x1, glitch_initialized@PAGE
    add x1, x1, glitch_initialized@PAGEOFF
    ldr w2, [x1]
    cbnz w2, .Ligs_return              // Return if already initialized
    
    // Set glitch_initialized = true
    mov w2, #1
    str w2, [x1]
    
    // Get pointer to glitch_config
    adrp x1, glitch_config@PAGE
    add x1, x1, glitch_config@PAGEOFF
    
    // Store glitch_intensity at offset 12
    str s0, [x1, #12]
    
    // Store glitch_seed at offset 16 (seed ^ 0xDECAF)
    adrp x2, .Lconst_decaf@PAGE
    add x2, x2, .Lconst_decaf@PAGEOFF
    ldr w2, [x2]
    eor w0, w0, w2
    str w0, [x1, #16]
    
    // Calculate terrain_glitch_rate = 0.1f + intensity * 0.4f
    adrp x2, .Lconst_0_1@PAGE
    add x2, x2, .Lconst_0_1@PAGEOFF
    ldr s1, [x2]                       // s1 = 0.1f
    adrp x2, .Lconst_0_4@PAGE
    add x2, x2, .Lconst_0_4@PAGEOFF
    ldr s2, [x2]                       // s2 = 0.4f
    fmul s3, s0, s2                    // s3 = intensity * 0.4f
    fadd s3, s1, s3                    // s3 = 0.1f + intensity * 0.4f
    str s3, [x1, #0]                   // store terrain_glitch_rate
    
    // Calculate shape_glitch_rate = 0.05f + intensity * 0.3f
    adrp x2, .Lconst_0_05@PAGE
    add x2, x2, .Lconst_0_05@PAGEOFF
    ldr s1, [x2]                       // s1 = 0.05f
    adrp x2, .Lconst_0_3@PAGE
    add x2, x2, .Lconst_0_3@PAGEOFF
    ldr s2, [x2]                       // s2 = 0.3f
    fmul s3, s0, s2                    // s3 = intensity * 0.3f
    fadd s3, s1, s3                    // s3 = 0.05f + intensity * 0.3f
    str s3, [x1, #4]                   // store shape_glitch_rate
    
    // Calculate digital_noise_rate = intensity * 0.1f
    fmul s1, s0, s1                    // s1 = intensity * 0.1f (reuse 0.1f from s1)
    adrp x2, .Lconst_0_1@PAGE
    add x2, x2, .Lconst_0_1@PAGEOFF
    ldr s2, [x2]                       // s2 = 0.1f
    fmul s1, s0, s2                    // s1 = intensity * 0.1f
    str s1, [x1, #8]                   // store digital_noise_rate
    
.Ligs_return:
    ldp x29, x30, [sp], #32
    ret

//==============================================================================
// get_glitch_random_asm
// Get pseudo-random value based on position and time
// Input: w0 = x, w1 = y, w2 = frame
// Output: w0 [CHUNK 3 OF 3]
BUNDLE_3_VISUAL_CORE - PART 3
Concatenate all chunks in order to reconstruct.

= random value
//==============================================================================
.global _get_glitch_random_asm
_get_glitch_random_asm:
    // Create hash = x * 73 + y * 37 + frame * 17
    mov w3, #73
    mul w3, w0, w3                     // w3 = x * 73
    mov w4, #37
    mul w4, w1, w4                     // w4 = y * 37
    add w3, w3, w4                     // w3 = x * 73 + y * 37
    mov w4, #17
    mul w4, w2, w4                     // w4 = frame * 17
    add w3, w3, w4                     // w3 = x * 73 + y * 37 + frame * 17
    
    // XOR with glitch_seed
    adrp x0, glitch_config@PAGE
    add x0, x0, glitch_config@PAGEOFF
    ldr w0, [x0, #16]                  // Load glitch_seed
    eor w3, w3, w0                     // hash ^= glitch_seed
    
    // Apply LCG: hash = hash * 1664525 + 1013904223
    adrp x0, .Lconst_lcg_mult@PAGE
    add x0, x0, .Lconst_lcg_mult@PAGEOFF
    ldr w0, [x0]                       // Load 1664525
    mul w3, w3, w0                     // hash *= 1664525
    adrp x0, .Lconst_lcg_add@PAGE
    add x0, x0, .Lconst_lcg_add@PAGEOFF
    ldr w0, [x0]                       // Load 1013904223
    add w0, w3, w0                     // hash += 1013904223
    
    ret

//==============================================================================
// get_glitched_terrain_char_asm
// Get glitched terrain character
// Input: w0 = original_char, w1 = x, w2 = y, w3 = frame
// Output: w0 = glitched character
//==============================================================================
.global _get_glitched_terrain_char_asm
_get_glitched_terrain_char_asm:
    stp x29, x30, [sp, #-48]!
    mov x29, sp
    
    // Save original character
    str w0, [sp, #16]
    
    // Check if glitch initialized
    adrp x0, glitch_initialized@PAGE
    add x0, x0, glitch_initialized@PAGEOFF
    ldr w0, [x0]
    cbz w0, .Lggtc_return_original
    
    // Call get_glitch_random(x, y, frame)
    mov w0, w1                         // x
    mov w1, w2                         // y
    mov w2, w3                         // frame
    bl _get_glitch_random_asm
    str w0, [sp, #20]                  // Save random value
    
    // Convert to float: rand_float = (rand_val % 10000) / 10000.0f
    mov w1, #10000
    udiv w2, w0, w1                    // w2 = rand_val / 10000
    msub w0, w2, w1, w0                // w0 = rand_val % 10000
    scvtf s0, w0                       // s0 = (float)(rand_val % 10000)
    adrp x0, .Lconst_10000_0@PAGE
    add x0, x0, .Lconst_10000_0@PAGEOFF
    ldr s1, [x0]                       // s1 = 10000.0f
    fdiv s0, s0, s1                    // s0 = rand_float
    
    // Compare with terrain_glitch_rate
    adrp x0, glitch_config@PAGE
    add x0, x0, glitch_config@PAGEOFF
    ldr s1, [x0]                       // Load terrain_glitch_rate
    fcmp s0, s1
    b.ge .Lggtc_return_original        // If rand_float >= glitch_rate, return original
    
    // Apply glitch: get character from terrain_glitch_chars
    ldr w0, [sp, #20]                  // Reload random value
    lsr w0, w0, #8                     // rand_val >> 8
    mov w1, #19                        // strlen(TERRAIN_GLITCH_CHARS) - 1
    udiv w2, w0, w1                    // w2 = (rand_val >> 8) / 19
    msub w0, w2, w1, w0                // w0 = (rand_val >> 8) % 19
    
    // Get character from array
    adrp x1, terrain_glitch_chars@PAGE
    add x1, x1, terrain_glitch_chars@PAGEOFF
    ldrb w0, [x1, w0, uxtw]           // Load character at index
    b .Lggtc_return
    
.Lggtc_return_original:
    ldr w0, [sp, #16]                  // Load original character

.Lggtc_return:
    ldp x29, x30, [sp], #48
    ret

//==============================================================================
// get_glitched_shape_char_asm
// Get glitched shape character
// Input: w0 = original_char, w1 = x, w2 = y, w3 = frame
// Output: w0 = glitched character
//==============================================================================
.global _get_glitched_shape_char_asm
_get_glitched_shape_char_asm:
    stp x29, x30, [sp, #-48]!
    mov x29, sp
    
    // Save original character
    str w0, [sp, #16]
    
    // Check if glitch initialized
    adrp x0, glitch_initialized@PAGE
    add x0, x0, glitch_initialized@PAGEOFF
    ldr w0, [x0]
    cbz w0, .Lggsc_return_original
    
    // Call get_glitch_random(x, y, frame)
    mov w0, w1                         // x
    mov w1, w2                         // y
    mov w2, w3                         // frame
    bl _get_glitch_random_asm
    str w0, [sp, #20]                  // Save random value
    
    // Convert to float: rand_float = (rand_val % 10000) / 10000.0f
    mov w1, #10000
    udiv w2, w0, w1                    // w2 = rand_val / 10000
    msub w0, w2, w1, w0                // w0 = rand_val % 10000
    scvtf s0, w0                       // s0 = (float)(rand_val % 10000)
    adrp x0, .Lconst_10000_0@PAGE
    add x0, x0, .Lconst_10000_0@PAGEOFF
    ldr s1, [x0]                       // s1 = 10000.0f
    fdiv s0, s0, s1                    // s0 = rand_float
    
    // Compare with shape_glitch_rate
    adrp x0, glitch_config@PAGE
    add x0, x0, glitch_config@PAGEOFF
    ldr s1, [x0, #4]                   // Load shape_glitch_rate
    fcmp s0, s1
    b.ge .Lggsc_return_original        // If rand_float >= glitch_rate, return original
    
    // Apply glitch: get character from shape_glitch_chars
    ldr w0, [sp, #20]                  // Reload random value
    lsr w0, w0, #8                     // rand_val >> 8
    mov w1, #21                        // strlen(SHAPE_GLITCH_CHARS) - 1
    udiv w2, w0, w1                    // w2 = (rand_val >> 8) / 21
    msub w0, w2, w1, w0                // w0 = (rand_val >> 8) % 21
    
    // Get character from array
    adrp x1, shape_glitch_chars@PAGE
    add x1, x1, shape_glitch_chars@PAGEOFF
    ldrb w0, [x1, w0, uxtw]           // Load character at index
    b .Lggsc_return
    
.Lggsc_return_original:
    ldr w0, [sp, #16]                  // Load original character

.Lggsc_return:
    ldp x29, x30, [sp], #48
    ret

//==============================================================================
// get_digital_noise_char_asm
// Get digital noise character
// Input: w0 = x, w1 = y, w2 = frame
// Output: w0 = noise character or space
//==============================================================================
.global _get_digital_noise_char_asm
_get_digital_noise_char_asm:
    stp x29, x30, [sp, #-32]!
    mov x29, sp
    
    // Check if glitch initialized
    adrp x3, glitch_initialized@PAGE
    add x3, x3, glitch_initialized@PAGEOFF
    ldr w3, [x3]
    cbnz w3, .Lgdnc_initialized
    
    // Return space if not initialized
    mov w0, #32                        // ' ' character
    b .Lgdnc_return
    
.Lgdnc_initialized:
    // Call get_glitch_random(x, y, frame * 3)
    mov w3, #3
    mul w2, w2, w3                     // frame * 3
    bl _get_glitch_random_asm
    str w0, [sp, #16]                  // Save random value
    
    // Convert to float: rand_float = (rand_val % 10000) / 10000.0f
    mov w1, #10000
    udiv w2, w0, w1                    // w2 = rand_val / 10000
    msub w0, w2, w1, w0                // w0 = rand_val % 10000
    scvtf s0, w0                       // s0 = (float)(rand_val % 10000)
    adrp x0, .Lconst_10000_0@PAGE
    add x0, x0, .Lconst_10000_0@PAGEOFF
    ldr s1, [x0]                       // s1 = 10000.0f
    fdiv s0, s0, s1                    // s0 = rand_float
    
    // Compare with digital_noise_rate
    adrp x0, glitch_config@PAGE
    add x0, x0, glitch_config@PAGEOFF
    ldr s1, [x0, #8]                   // Load digital_noise_rate
    fcmp s0, s1
    b.ge .Lgdnc_return_space           // If rand_float >= noise_rate, return space
    
    // Apply noise: get character from digital_noise_chars
    ldr w0, [sp, #16]                  // Reload random value
    lsr w0, w0, #8                     // rand_val >> 8
    mov w1, #39                        // strlen(DIGITAL_NOISE_CHARS) - 1
    udiv w2, w0, w1                    // w2 = (rand_val >> 8) / 39
    msub w0, w2, w1, w0                // w0 = (rand_val >> 8) % 39
    
    // Get character from array
    adrp x1, digital_noise_chars@PAGE
    add x1, x1, digital_noise_chars@PAGEOFF
    ldrb w0, [x1, w0, uxtw]           // Load character at index
    b .Lgdnc_return
    
.Lgdnc_return_space:
    mov w0, #32                        // ' ' character

.Lgdnc_return:
    ldp x29, x30, [sp], #32
    ret

//==============================================================================
// should_apply_matrix_cascade_asm
// Check if matrix cascade should be applied
// Input: w0 = x, w1 = y, w2 = frame
// Output: w0 = 1 if should apply, 0 otherwise
//==============================================================================
.global _should_apply_matrix_cascade_asm
_should_apply_matrix_cascade_asm:
    stp x29, x30, [sp, #-32]!
    mov x29, sp
    
    // Check if glitch initialized
    adrp x3, glitch_initialized@PAGE
    add x3, x3, glitch_initialized@PAGEOFF
    ldr w3, [x3]
    cbnz w3, .Lsamc_initialized
    
    // Return false if not initialized
    mov w0, #0
    b .Lsamc_return
    
.Lsamc_initialized:
    // Call get_glitch_random(x / 8, 0, frame / 10)
    lsr w0, w0, #3                     // x / 8
    mov w1, #0                         // y = 0 (column-based)
    mov w3, #10
    udiv w2, w2, w3                    // frame / 10
    bl _get_glitch_random_asm
    
    // Convert to float: rand_float = (rand_val % 10000) / 10000.0f
    mov w1, #10000
    udiv w2, w0, w1                    // w2 = rand_val / 10000
    msub w0, w2, w1, w0                // w0 = rand_val % 10000
    scvtf s0, w0                       // s0 = (float)(rand_val % 10000)
    adrp x0, .Lconst_10000_0@PAGE
    add x0, x0, .Lconst_10000_0@PAGEOFF
    ldr s1, [x0]                       // s1 = 10000.0f
    fdiv s0, s0, s1                    // s0 = rand_float
    
    // Calculate cascade_chance = 0.02f * glitch_intensity
    adrp x0, glitch_config@PAGE
    add x0, x0, glitch_config@PAGEOFF
    ldr s1, [x0, #12]                  // Load glitch_intensity
    adrp x0, .Lconst_0_02@PAGE
    add x0, x0, .Lconst_0_02@PAGEOFF
    ldr s2, [x0]                       // s2 = 0.02f
    fmul s1, s1, s2                    // s1 = 0.02f * glitch_intensity
    
    // Compare rand_float < cascade_chance
    fcmp s0, s1
    cset w0, lt                        // w0 = 1 if rand_float < cascade_chance, 0 otherwise

.Lsamc_return:
    ldp x29, x30, [sp], #32
    ret

//==============================================================================
// get_matrix_cascade_char_asm
// Get matrix cascade character
// Input: w0 = x, w1 = y, w2 = frame
// Output: w0 = cascade character
//==============================================================================
.global _get_matrix_cascade_char_asm
_get_matrix_cascade_char_asm:
    stp x29, x30, [sp, #-16]!
    mov x29, sp
    
    // Call get_glitch_random(x, y, frame)
    bl _get_glitch_random_asm
    
    // Get character from matrix_chars
    lsr w0, w0, #8                     // rand_val >> 8
    mov w1, #45                        // strlen(MATRIX_CHARS) - 1
    udiv w2, w0, w1                    // w2 = (rand_val >> 8) / 45
    msub w0, w2, w1, w0                // w0 = (rand_val >> 8) % 45
    
    // Get character from array
    adrp x1, matrix_chars@PAGE
    add x1, x1, matrix_chars@PAGEOFF
    ldrb w0, [x1, w0, uxtw]           // Load character at index
    
    ldp x29, x30, [sp], #16
    ret

//==============================================================================
// update_glitch_intensity_asm
// Update glitch intensity (can be driven by audio)
// Input: s0 = new_intensity (float)
// Output: None
//==============================================================================
.global _update_glitch_intensity_asm
_update_glitch_intensity_asm:
    // Check if glitch initialized
    adrp x0, glitch_initialized@PAGE
    add x0, x0, glitch_initialized@PAGEOFF
    ldr w0, [x0]
    cbz w0, .Lugi_return               // Return if not initialized
    
    // Get pointer to glitch_config
    adrp x0, glitch_config@PAGE
    add x0, x0, glitch_config@PAGEOFF
    
    // Store new glitch_intensity at offset 12
    str s0, [x0, #12]
    
    // Calculate terrain_glitch_rate = 0.1f + new_intensity * 0.4f
    adrp x1, .Lconst_0_1@PAGE
    add x1, x1, .Lconst_0_1@PAGEOFF
    ldr s1, [x1]                       // s1 = 0.1f
    adrp x1, .Lconst_0_4@PAGE
    add x1, x1, .Lconst_0_4@PAGEOFF
    ldr s2, [x1]                       // s2 = 0.4f
    fmul s3, s0, s2                    // s3 = new_intensity * 0.4f
    fadd s3, s1, s3                    // s3 = 0.1f + new_intensity * 0.4f
    str s3, [x0, #0]                   // store terrain_glitch_rate
    
    // Calculate shape_glitch_rate = 0.05f + new_intensity * 0.3f
    adrp x1, .Lconst_0_05@PAGE
    add x1, x1, .Lconst_0_05@PAGEOFF
    ldr s1, [x1]                       // s1 = 0.05f
    adrp x1, .Lconst_0_3@PAGE
    add x1, x1, .Lconst_0_3@PAGEOFF
    ldr s2, [x1]                       // s2 = 0.3f
    fmul s3, s0, s2                    // s3 = new_intensity * 0.3f
    fadd s3, s1, s3                    // s3 = 0.05f + new_intensity * 0.3f
    str s3, [x0, #4]                   // store shape_glitch_rate
    
    // Calculate digital_noise_rate = new_intensity * 0.1f
    adrp x1, .Lconst_0_1@PAGE
    add x1, x1, .Lconst_0_1@PAGEOFF
    ldr s1, [x1]                       // s1 = 0.1f
    fmul s1, s0, s1                    // s1 = new_intensity * 0.1f
    str s1, [x0, #8]                   // store digital_noise_rate

.Lugi_return:
    ret

//==============================================================================
// get_glitch_intensity_asm
// Get current glitch intensity
// Input: None
// Output: s0 = glitch intensity (0.0 if not initialized)
//==============================================================================
.global _get_glitch_intensity_asm
_get_glitch_intensity_asm:
    // Check if glitch initialized
    adrp x0, glitch_initialized@PAGE
    add x0, x0, glitch_initialized@PAGEOFF
    ldr w0, [x0]
    cbnz w0, .Lggi_initialized
    
    // Return 0.0f if not initialized
    fmov s0, wzr
    b .Lggi_return
    
.Lggi_initialized:
    // Load and return glitch_intensity
    adrp x0, glitch_config@PAGE
    add x0, x0, glitch_config@PAGEOFF
    ldr s0, [x0, #12]                  // Load glitch_intensity

.Lggi_return:
    ret

//==============================================================================
// C-style wrapper exports (without _asm suffix) for integration with other ASM files
//==============================================================================

.global _get_glitched_terrain_char
_get_glitched_terrain_char:
    b _get_glitched_terrain_char_asm

.global _get_glitched_shape_char
_get_glitched_shape_char:
    b _get_glitched_shape_char_asm

.global _get_digital_noise_char
_get_digital_noise_char:
    b _get_digital_noise_char_asm

.global _should_apply_matrix_cascade
_should_apply_matrix_cascade:
    b _should_apply_matrix_cascade_asm

.global _get_matrix_cascade_char
_get_matrix_cascade_char:
    b _get_matrix_cascade_char_asm

---END---

[CHUNK 1 OF 2]
BUNDLE_4_TERRAIN - PART 1
Concatenate all chunks in order to reconstruct.

[NOTDEAFBEEF BLOCKCHAIN BUNDLE - BUNDLE_4_TERRAIN]
=============================================================
Terrain generation system (large file)
Generated for on-chain storage following deafbeef methodology.

[MANIFEST]
Bundle: bundle_4_terrain
Total files: 1
Files included:
  - visual/terrain.s (36697 bytes)

Reconstruction: Save each file to its path and build with provided instructions.

=== FILE: visual/terrain.s ===
---BEGIN---
.section __TEXT,__text,regular,pure_instructions
.align 2

// External function declarations
.extern _draw_ascii_char_asm
.extern _hsv_to_rgb
.extern _color_to_pixel
.extern _get_glitched_terrain_char
.extern _get_digital_noise_char
.extern _should_apply_matrix_cascade
.extern _get_matrix_cascade_char
.extern _srand
.extern _rand

// Constants
#define TILE_SIZE 32
#define SCROLL_SPEED 2
#define TERRAIN_LENGTH 64
#define VIS_WIDTH 800
#define VIS_HEIGHT 600

// Terrain data structures
.section __DATA,__data
.align 5

// Terrain pattern array - 64 tiles * 8 bytes each = 512 bytes
// terrain_tile_t structure layout:
// - type: 4 bytes (terrain_type_t enum)
// - height: 4 bytes (int)
// Total: 8 bytes per terrain_tile_t
terrain_pattern:
    .space (64 * 8), 0      // TERRAIN_LENGTH * sizeof(terrain_tile_t)

// ASCII tile patterns - 32x32 = 1024 bytes each
tile_flat_pattern:
    .space (32 * 32), 0     // TILE_SIZE * TILE_SIZE

tile_slope_up_pattern:
    .space (32 * 32), 0     // TILE_SIZE * TILE_SIZE

tile_slope_down_pattern:
    .space (32 * 32), 0     // TILE_SIZE * TILE_SIZE

// Base hue for terrain color calculations
terrain_base_hue:
    .space 4, 0             // float

// Audio level for reactive effects
terrain_audio_level:
    .space 4, 0             // float

// Initialization flag
terrain_initialized:
    .space 1, 0             // bool

.section __TEXT,__text,regular,pure_instructions

// Generate deterministic terrain pattern (matching Python logic)
// static void generate_terrain_pattern(uint32_t seed)
// Input: w0 = seed
.global _generate_terrain_pattern_asm
_generate_terrain_pattern_asm:
    stp x29, x30, [sp, #-64]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    str w0, [sp, #48]       // Save seed
    
    // Use XOR with magic number to match Python terrain_rng: seed ^ 0x7E44A1
    adr x1, .Lconst_magic
    ldr w1, [x1]            // Load 0x7E44A1
    eor w0, w0, w1          // seed ^ 0x7E44A1
    bl _srand
    
    // Get terrain pattern array pointer
    adrp x19, terrain_pattern@PAGE
    add x19, x19, terrain_pattern@PAGEOFF
    
    mov w20, #0             // i = 0
    
.Lgen_while_loop:
    cmp w20, #64            // TERRAIN_LENGTH = 64
    b.ge .Lgen_done
    
    // int feature_choice = rand() % 5
    bl _rand
    mov w1, #5
    udiv w2, w0, w1         // w2 = rand() / 5
    msub w21, w2, w1, w0    // w21 = feature_choice = rand() % 5
    
    cmp w21, #0             // feature_choice == 0 (flat)
    b.eq .Lgen_flat
    cmp w21, #1             // feature_choice == 1 (wall)
    b.eq .Lgen_wall
    cmp w21, #2             // feature_choice == 2 (slope_up)
    b.eq .Lgen_slope_up
    cmp w21, #3             // feature_choice == 3 (slope_down)
    b.eq .Lgen_slope_down
    b .Lgen_gap             // feature_choice == 4 (gap)
    
.Lgen_flat:
    // int length = 2 + (rand() % 5); // 2-6 tiles
    bl _rand
    mov w1, #5
    udiv w2, w0, w1
    msub w1, w2, w1, w0     // rand() % 5
    add w22, w1, #2         // length = 2 + (rand() % 5)
    
    // for (int j = 0; j < length && i < TERRAIN_LENGTH; j++, i++)
    mov w1, #0              // j = 0
.Lgen_flat_loop:
    cmp w1, w22             // j < length?
    b.ge .Lgen_while_loop
    cmp w20, #64            // i < TERRAIN_LENGTH?
    b.ge .Lgen_done
    
    // terrain_pattern[i] = {TERRAIN_FLAT, 2}
    mov w2, #8              // sizeof(terrain_tile_t) = 8
    mul w3, w20, w2         // i * 8
    add x3, x19, w3, uxtw   // &terrain_pattern[i]
    
    mov w2, #0              // TERRAIN_FLAT = 0
    str w2, [x3]            // store type
    mov w2, #2              // height = 2
    str w2, [x3, #4]        // store height
    
    add w1, w1, #1          // j++
    add w20, w20, #1        // i++
    b .Lgen_flat_loop
    
.Lgen_wall:
    // int wall_height = (rand() % 2) ? 4 : 6; // 4 or 6
    bl _rand
    mov w1, #2
    udiv w2, w0, w1
    msub w1, w2, w1, w0     // rand() % 2
    cmp w1, #0
    mov w1, #4              // Default to 4
    mov w2, #6              // Alternative 6
    csel w22, w2, w1, ne    // wall_height = (rand() % 2) ? 4 : 6
    
    // int wall_width = 2 + (rand() % 3); // 2-4
    bl _rand
    mov w1, #3
    udiv w2, w0, w1
    msub w1, w2, w1, w0     // rand() % 3
    add w1, w1, #2          // wall_width = 2 + (rand() % 3)
    
    // for (int j = 0; j < wall_width && i < TERRAIN_LENGTH; j++, i++)
    mov w2, #0              // j = 0
.Lgen_wall_loop:
    cmp w2, w1              // j < wall_width?
    b.ge .Lgen_while_loop
    cmp w20, #64            // i < TERRAIN_LENGTH?
    b.ge .Lgen_done
    
    // terrain_pattern[i] = {TERRAIN_WALL, wall_height}
    mov w3, #8              // sizeof(terrain_tile_t) = 8
    mul w4, w20, w3         // i * 8
    add x4, x19, w4, uxtw   // &terrain_pattern[i]
    
    mov w3, #1              // TERRAIN_WALL = 1
    str w3, [x4]            // store type
    str w22, [x4, #4]       // store wall_height
    
    add w2, w2, #1          // j++
    add w20, w20, #1        // i++
    b .Lgen_wall_loop
    
.Lgen_slope_up:
    // if (i < TERRAIN_LENGTH)
    cmp w20, #64
    b.ge .Lgen_while_loop
    
    // terrain_pattern[i++] = {TERRAIN_SLOPE_UP, 2}
    mov w1, #8              // sizeof(terrain_tile_t) = 8
    mul w2, w20, w1         // i * 8
    add x2, x19, w2, uxtw   // &terrain_pattern[i]
    
    mov w1, #2              // TERRAIN_SLOPE_UP = 2
    str w1, [x2]            // store type
    mov w1, #2              // height = 2
    str w1, [x2, #4]        // store height
    
    add w20, w20, #1        // i++
    
    // followed by elevated platform
    // int length = 2 + (rand() % 3); // 2-4
    bl _rand
    mov w1, #3
    udiv w2, w0, w1
    msub w1, w2, w1, w0     // rand() % 3
    add w22, w1, #2         // length = 2 + (rand() % 3)
    
    // for (int j = 0; j < length && i < TERRAIN_LENGTH; j++, i++)
    mov w1, #0              // j = 0
.Lgen_slope_up_platform_loop:
    cmp w1, w22             // j < length?
    b.ge .Lgen_while_loop
    cmp w20, #64            // i < TERRAIN_LENGTH?
    b.ge .Lgen_done
    
    // terrain_pattern[i] = {TERRAIN_FLAT, 3}
    mov w2, #8              // sizeof(terrain_tile_t) = 8
    mul w3, w20, w2         // i * 8
    add x3, x19, w3, uxtw   // &terrain_pattern[i]
    
    mov w2, #0              // TERRAIN_FLAT = 0
    str w2, [x3]            // store type
    mov w2, #3              // height = 3
    str w2, [x3, #4]        // store height
    
    add w1, w1, #1          // j++
    add w20, w20, #1        // i++
    b .Lgen_slope_up_platform_loop
    
.Lgen_slope_down:
    // if (i < TERRAIN_LENGTH)
    cmp w20, #64
    b.ge .Lgen_while_loop
    
    // terrain_pattern[i++] = {TERRAIN_SLOPE_DOWN, 3}
    mov w1, #8              // sizeof(terrain_tile_t) = 8
    mul w2, w20, w1         // i * 8
    add x2, x19, w2, uxtw   // &terrain_pattern[i]
    
    mov w1, #3              // TERRAIN_SLOPE_DOWN = 3
    str w1, [x2]            // store type
    mov w1, #3              // height = 3
    str w1, [x2, #4]        // store height
    
    add w20, w20, #1        // i++
    b .Lgen_while_loop
    
.Lgen_gap:
    // int length = 1 + (rand() % 2); // 1-2 tiles
    bl _rand
    mov w1, #2
    udiv w2, w0, w1
    msub w1, w2, w1, w0     // rand() % 2
    add w22, w1, #1         // length = 1 + (rand() % 2)
    
    // for (int j = 0; j < length && i < TERRAIN_LENGTH; j++, i++)
    mov w1, #0              // j = 0
.Lgen_gap_loop:
    cmp w1, w22             // j < length?
    b.ge .Lgen_while_loop
    cmp w20, #64            // i < TERRAIN_LENGTH?
    b.ge .Lgen_done
    
    // terrain_pattern[i] = {TERRAIN_GAP, 0}
    mov w2, #8              // sizeof(terrain_tile_t) = 8
    mul w3, w20, w2         // i * 8
    add x3, x19, w3, uxtw   // &terrain_pattern[i]
    
    mov w2, #4              // TERRAIN_GAP = 4
    str w2, [x3]            // store type
    mov w2, #0              // height = 0
    str w2, [x3, #4]        // store height
    
    add w1, w1, #1          // j++
    add w20, w20, #1        // i++
    b .Lgen_gap_loop
    
.Lgen_done:
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #64
    ret

// Enhanced ASCII terrain character selection with audio reactivity
// static char get_enhanced_terrain_char(int x, int y, float audio_level, int frame)
// Input: w0 = x, w1 = y, s0 = audio_level, w2 = frame
// Output: w0 = character
.global _get_enhanced_terrain_char_asm
_get_enhanced_terrain_char_asm:
    stp x29, x30, [sp, #-32]!
    mov x29, sp
    str w2, [sp, #16]       // Save frame
    
    // int h = ((x * 13 + y * 7) ^ (x >> 3)) & 0xFF;
    mov w3, #13
    mul w3, w0, w3          // x * 13
    mov w4, #7
    mul w4, w1, w4          // y * 7
    add w3, w3, w4          // x * 13 + y * 7
    
    lsr w4, w0, #3          // x >> 3
    eor w3, w3, w4          // (x * 13 + y * 7) ^ (x >> 3)
    and w3, w3, #0xFF       // & 0xFF -> h
    
    // Audio-reactive density thresholds
    // Convert audio_level to int: audio_factor = (int)(audio_level * 100)
    adr x4, .Lconst_100
    ldr s1, [x4]            // 100.0f
    fmul s1, s0, s1         // audio_level * 100
    fcvtms w4, s1           // audio_factor
    
    // Modulate thresholds based on audio and frame
    ldr w5, [sp, #16]       // Load frame
    lsr w5, w5, #3          // frame >> 3 (slower cycling)
    add w4, w4, w5          // audio_factor + (frame >> 3)
    and w4, w4, #0x3F       // Keep in reasonable range
    
    // Dynamic thresholds: base + audio modulation
    mov w5, #40             // Base threshold 1
    add w5, w5, w4          // threshold1 = 40 + audio_factor
    mov w6, #120            // Base threshold 2  
    add w6, w6, w4          // threshold2 = 120 + audio_factor
    
    // Extended character set for more variety
    cmp w3, w5              // h < threshold1?
    b.ge .Lgt_check_mid
    
    // Dense characters - choose based on fine hash
    and w7, w3, #0x7        // w3 & 7 for 8 options
    cmp w7, #0
    b.ne .Lgt_dense_2
    mov w0, #'#'            // Solid block
    b .Lgt_done
.Lgt_dense_2:
    cmp w7, #1
    b.ne .Lgt_dense_3
    mov w0, #'@'            // Dense pattern
    b .Lgt_done
.Lgt_dense_3:
    cmp w7, #2
    b.ne .Lgt_dense_4
    mov w0, #'%'            // Medium-dense
    b .Lgt_done
.Lgt_dense_4:
    mov w0, #'*'            // Star pattern
    b .Lgt_done
    
.Lgt_check_mid:
    cmp w3, w6              // h < threshold2?
    b.ge .Lgt_sparse
    
    // Medium density characters
    and w7, w3, #0x7        // w3 & 7 for variety
    cmp w7, #0
    b.ne .Lgt_med_2
    mov w0, #'='            // Equal signs
    b .Lgt_done
.Lgt_med_2:
    cmp w7, #1
    b.ne .Lgt_med_3
    mov w0, #'+'            // Plus signs
    b .Lgt_done
.Lgt_med_3:
    cmp w7, #2
    b.ne .Lgt_med_4
    mov w0, #'~'            // Waves
    b .Lgt_done
.Lgt_med_4:
    mov w0, #':'            // Dots
    b .Lgt_done
    
.Lgt_sparse:
    // Sparse/light characters
    and w7, w3, #0x7        // w3 & 7 for variety
    cmp w7, #0
    b.ne .Lgt_sparse_2
    mov w0, #'-'            // Dashes
    b .Lgt_done
.Lgt_sparse_2:
    cmp w7, #1
    b.ne .Lgt_sparse_3
    mov w0, #'.'            // Periods
    b .Lgt_done
.Lgt_sparse_3:
    cmp w7, #2
    b.ne .Lgt_sparse_4
    mov w0, #','            // Commas
    b .Lgt_done
.Lgt_sparse_4:
    mov w0, #'_'            // Underscores
    
.Lgt_done:
    ldp x29, x30, [sp], #32
    ret

// Generate dynamic terrain color based on type, position, and audio
// uint32_t get_dynamic_terrain_color(terrain_type_t type, int x, int y, int frame, float audio_level)
// Input: w0 = terrain_type, w1 = x, w2 = y, w3 = frame, s0 = audio_level
// Output: w0 = color (ARGB)
.global _get_dynamic_terrain_color_asm
_get_dynamic_terrain_color_asm:
    stp x29, x30, [sp, #-96]!
    mov x29, sp
    stp w0, w1, [sp, #16]   // Save type, x
    stp w2, w3, [sp, #24]   // Save y, frame
    str s0, [sp, #32]       // Save audio_level
    
    // Load base hue
    adrp x4, terrain_base_hue@PAGE
    add x4, x4, terrain_base_hue@PAGEOFF
    ldr s1, [x4]            // base_hue
    
    // Calculate hue variation based on terrain type
    mov w4, #0              // hue_offset = 0
    cmp w0, #0              // TERRAIN_FLAT
    b.eq .Lcolor_flat
    cmp w0, #1              // TERRAIN_WALL  
    b.eq .Lcolor_wall
    cmp w0, #2              // TERRAIN_SLOPE_UP
    b.eq .Lcolor_slope_up
    cmp w0, #3              // TERRAIN_SLOPE_DOWN
    b.eq .Lcolor_slope_down
    b .Lcolor_gap           // TERRAIN_GAP

.Lcolor_flat:
    // Flat terrain: base hue + position gradient
    ldr w1, [sp, #20]       // Load x
    mov w5, #800            // VIS_WIDTH
    scvtf s2, w1            // x as float
    scvtf s3, w5            // VIS_WIDTH as float
    fdiv s2, s2, s3         // x / VIS_WIDTH (0.0 to 1.0)
    adr x5, .Lconst_0_2
    ldr s3, [x5]            // 0.2f
    fmul s2, s2, s3         // position_offset = (x / VIS_WIDTH) * 0.2
    fadd s1, s1, s2         // hue = base_hue + position_offset
    b .Lcolor_calc_final

.Lcolor_wall:
    // Wall terrain: base hue + 0.6 (complementary) + audio reactive
    adr x5, .Lconst_0_6
    ldr s2, [x5]            // 0.6f
    fadd s1, s1, s2         // hue = base_hue + 0.6
    ldr s0, [sp, #32]       // Load audio_level
    adr x5, .Lconst_0_1
    ldr s2, [x5]            // 0.1f
    fmul s2, s0, s2         // audio_level * 0.1
    fadd s1, s1, s2         // hue += audio variation
    b .Lcolor_calc_final

.Lcolor_slope_up:
    // Slope up: base hue + 0.3 + frame cycling
    adr x5, .Lconst_0_3
    ldr s2, [x5]            // 0.3f
    fadd s1, s1, s2         // hue = base_hue + 0.3
    ldr w3, [sp, #28]       // Load frame
    scvtf s2, w3            // frame as float
    adr x5, .Lconst_1000
    ldr s3, [x5]            // 1000.0f
    fdiv s2, s2, s3         // frame / 1000
    adr x5, .Lconst_0_1
    ldr s3, [x5]            // 0.1f
    fmul s2, s2, s3         // (frame / 1000) * 0.1
    fadd s1, s1, s2         // hue += frame cycling
    b .Lcolor_calc_final

.Lcolor_slope_down:
    // Slope down: base hue + 0.8 + Y-based gradient
    adr x5, .Lconst_0_8
    ldr s2, [x5]            // 0.8f
    fadd s1, s1, s2         // hue = base_hue + 0.8
    ldr w2, [sp, #24]       // Load y
    scvtf s2, w2            // y as float
    adr x5, .Lconst_600
    ldr s3, [x5]            // 600.0f (VIS_HEIGHT)
    fdiv s2, s2, s3         // y / VIS_HEIGHT
    adr x5, .Lconst_0_15
    ldr s3, [x5]            // 0.15f
    fmul s2, s2, s3         // (y / VIS_HEIGHT) * 0.15
    fadd s1, s1, s2         // hue += y gradient
    b .Lcolor_calc_final

.Lcolor_gap:
    // Gap: Should not be rendered, but if it is, make it dark
    adr x5, .Lconst_0_5
    ldr s2, [x5]            // 0.5f
    fadd s1, s1, s2         // hue = base_hue + 0.5
    
.Lcolor_calc_final:
    // Normalize hue to 0.0-1.0 range: fmod(hue, 1.0)
    adr x5, .Lconst_1_0
    ldr s2, [x5]            // 1.0f
    fdiv s3, s1, s2         // hue / 1.0
    fcvtms w4, s3           // floor(hue / 1.0)
    scvtf s3, w4            // floor as float
    fmsub s1, s3, s2, s1    // hue = hue - floor * 1.0 (fmod)
    
    // Calculate saturation: base 0.9 + audio variation
    adr x5, .Lconst_0_9
    ldr s2, [x5]            // 0.9f base saturation
    ldr s0, [sp, #32]       // Load audio_level
    adr x5, .Lconst_0_1
    ldr s3, [x5]            // 0.1f
    fmul s3, s0, s3         // audio_level * 0.1
    fadd s2, s2, s3         // saturation = 0.9 + audio variation
    
    // Clamp saturation to 1.0 max
    adr x5, .Lconst_1_0
    ldr s3, [x5]            // 1.0f
    fmin s2, s2, s3         // saturation = min(saturation, 1.0)
    
    // Calculate brightness: base 0.8 + audio variation
    adr x5, .Lconst_0_8
    ldr s3, [x5]            // 0.8f base brightness
    ldr s0, [sp, #32]       // Load audio_level
    adr x5, .Lconst_0_2
    ldr s4, [x5]            // 0.2f
    fmul s4, s0, s4         // audio_level * 0.2
    fadd s3, s3, s4         // brightness = 0.8 + audio variation
    
    // Clamp brightness to 1.0 max
    adr x5, .Lconst_1_0
    ldr s4, [x5]            // 1.0f
    fmin s3, s3, s4         // brightness = min(brightness, 1.0)
    
    // Create HSV struct on stack: {h, s, v}
    str s1, [sp, #40]       // h
    str s2, [sp, #44]       // s
    str s3, [sp, #48]       // v
    
    // Convert HSV to RGB and then to pixel
    add x0, sp, #40         // HSV struct pointer
    add x1, sp, #52         // RGB output buffer
    bl _hsv_to_rgb
    
    // Convert RGB to pixel
    add x0, sp, #52         // RGB struct pointer
    bl _color_to_pixel
    
    // Return color in w0
    ldp x29, x30, [sp], #96
    ret

// Build procedural ASCII tile pattern with enhanced character selection
// static void build_ascii_tile_pattern(char *tile_pattern)
// Input: x0 = tile_pattern pointer
.global _build_ascii_tile_pattern_asm
_build_ascii_tile_pattern_asm:
    stp x29, x30, [sp, #-48]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    str x21, [sp, #32]
    
    mov x19, x0             // tile_pattern pointer
    mov w20, #0             // y = 0
    
.Lbatp_y_loop:
    cmp w20, #32            // TILE_SIZE = 32
    b.ge .Lbatp_done
    
    mov w21, #0             // x = 0
    
.Lbatp_x_loop:
    cmp w21, #32            // TILE_SIZE = 32
    b.ge .Lbatp_next_y
    
    // char c = get_enhanced_terrain_char(x, y, audio_level, frame)
    mov w0, w21             // x
    mov w1, w20             // y
    // Load audio level (default to 0.5 for tile building)
    adr x2, .Lconst_0_5
    ldr s0, [x2]            // audio_level = 0.5
    mov w2, #0              // frame = 0 for static patterns
    bl _get_enhanced_terrain_char_asm
    
    // tile_pattern[y * TILE_SIZE + x] = c
    mov w1, #32             // TILE_SIZE
    mul w2, w20, w1         // y * TILE_SIZE
    add w2, w2, w21         // y * TILE_SIZE + x
    strb w0, [x19, w2, uxtw] // Store character
    
    add w21, w21, #1        // x++
    b .Lbatp_x_loop
    
.Lbatp_next_y:
    add w20, w20, #1        // y++
    b .Lbatp_y_loop
    
.Lbatp_done:
    ldr x21, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #48
    ret

// Build ASCII slope tile pattern (45 degree angle)
// static void build_ascii_slope_pattern(char *tile_pattern, bool slope_up)
// Input: x0 = tile_pattern pointer, w1 = slope_up (bool)
.global _build_ascii_slope_pattern_asm
_build_ascii_slope_pattern_asm:
    stp x29, x30, [sp, #-64]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    str w23, [sp, #48]
    
    mov x19, x0             // tile_pattern pointer
    mov w23, w1             // slope_up flag
    
    // Initialize to space (transparent): memset(tile_pattern, ' ', TILE_SIZE * TILE_SIZE)
    mov w1, #' '            // space character
    mov w2, #1024           // TILE_SIZE * TILE_SIZE = 32 * 32 = 1024
    
.Lbasp_memset_loop:
    cmp w2, #0
    b.le .Lbasp_memset_done
    sub w2, w2, #1
    strb w1, [x19, w2, uxtw]
    b .Lbasp_memset_loop
    
.Lbasp_memset_done:
    mov w20, #0             // y = 0
    
.Lbasp_y_loop:
    cmp w20, #32            // TILE_SIZE = 32
    b.ge .Lbasp_done
    
    mov w21, #0             // x = 0
    
.Lbasp_x_loop:
    cmp w21, #32            // TILE_SIZE = 32
    b.ge .Lbasp_next_y
    
    // int threshold = slope_up ? x : (TILE_SIZE - x)
    cmp w23, #0             // slope_up?
    b.eq .Lbasp_slope_down
    mov w22, w21            // threshold = x
    b .Lbasp_check_threshold
    
.Lbasp_slope_down:
    mov w22, #32            // TILE_SIZE = 32
    sub w22, w22, w21       // threshold = TILE_SIZE - x
    
.Lbasp_check_threshold:
    // if (y > threshold)
    cmp w20, w22
    b.le .Lbasp_next_x      // Skip if y <= threshold
    
    // Below slope - use enhanced terrain character  
    mov w0, w21             // x
    mov w1, w20             // y
    // Load audio level (default to 0.5 for tile building)
    adr x2, .Lconst_0_5
    ldr s0, [x2]            // audio_level = 0.5
    mov w2, #0              // frame = 0 for static patterns
    bl _get_enhanced_terrain_char_asm
    
    // tile_pattern[y * TILE_SIZE + x] = c
    mov w1, #32             // TILE_SIZE
    mul w2, w20, w1         // y * TILE_SIZE
    add w2, w2, w21         // y * TILE_SIZE + x
    strb w0, [x19, w2, uxtw] // Store character
    
.Lbasp_next_x:
    add w21, w21, #1        // x++
    b .Lbasp_x_loop
    
.Lbasp_next_y:
    add w20, w20, #1        // y++
    b .Lbasp_y_loop
    
.Lbasp_done:
    ldr w23, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #64
    ret

// Initialize terrain system
// void init_terrain(uint32_t seed, float base_hue)
// Input: w0 = seed, s0 = base_hue
.global _init_terrain_asm
_init_terrain_asm:
    stp x29, x30, [sp, #-96]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    str w0, [sp, #32]       // Save seed
    str s0, [sp, #36]       // Save base_hue
    
    // Check if already initialized
    adrp x0, terrain_initialized@PAGE
    add x0, x0, terrain_initialized@PAGEOFF
    ldrb w1, [x0]
    cmp w1, #0
    b.ne .Linit_terrain_done // Return if already initialized
    
    // generate_terrain_pattern(seed)
    ldr w0, [sp, #32]       // Load seed
    bl _generate_terrain_pattern_asm
    
    // Store base hue for dynamic color calculations
    ldr s0, [sp, #36]       // Load base_hue
    adrp x0, terrain_base_hue@PAGE
    add x0, x0, terrain_base_hue@PAGEOFF
    str s0, [x0]            // terrain_base_hue = base_hue
    
    // Build ASCII tile patterns
    // build_ascii_tile_pattern(tile_flat_pattern)
    adrp x0, tile_flat_pattern@PAGE
    add x0, x0, tile_flat_pattern@PAGEOFF
    bl _build_ascii_tile_pattern_asm
    
    // build_ascii_slope_pattern(tile_slope_up_pattern, true)
    adrp x0, tile_slope_up_pattern@PAGE
    add x0, x0, tile_slope_up_pattern@PAGEOFF
    mov w1, #1              // true
    bl _build_ascii_slope_pattern_asm
    
    // build_ascii_slope_pattern(tile_slope_down_pattern, false)
    adrp x0, tile_slope_down_pattern@PAGE
    add x0, x0, tile_slope_down_pattern@PAGEOFF
    mov w1, #0              // false
    bl _build_ascii_slope_pattern_asm
    
    // Set initialized flag
    adrp x0, terrain_initialized@PAGE
    add x0, x0, terrain_initialized@PAGEOFF
    mov w1, #1
    strb w1, [x0]           // terrain_initialized = true
    
.Linit_terrain_done:
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #96
    ret

// Update terrain audio level for reactive effects
// void update_terrain_audio_level(float audio_level)
// Input: s0 = audio_level
.global _update_terrain_audio_level_asm
_update_terrain_audio_level_asm:
    adrp x0, terrain_audio_level@PAGE
    add x0, x0, terrain_audio_level@PAGEOFF
    str s0, [x0]            // terrain_audio_level = audio_level
    ret

// Enhanced terrain drawing with dynamic colors and audio reactivity
// void draw_terrain_enhanced(uint32_t *pixels, int frame, float audio_level)
// Input: x0 = pixels, w1 = frame, s0 = audio_level
.global _draw_terrain_enhanced_asm
_draw_terrain_enhanced_asm:
    stp x29, x30, [sp, #-160]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    stp x25, x26, [sp, #64]
    stp x27, x28, [sp, #80]
    
    mov x19, x0             // pixels
    mov w20, w1             // frame
    str s0, [sp, #96]       // Save audio_level
    
    // Update terrain audio level
    adrp x0, terrain_audio_level@PAGE
    add x0, x0, terrain_audio_level@PAGEOFF
    str s0, [x0]            //[CHUNK 2 OF 2]
BUNDLE_4_TERRAIN - PART 2
Concatenate all chunks in order to reconstruct.

 terrain_audio_level = audio_level
    
    // Check if initialized
    adrp x0, terrain_initialized@PAGE
    add x0, x0, terrain_initialized@PAGEOFF
    ldrb w1, [x0]
    cmp w1, #0
    b.eq .Ldraw_terrain_done // Return if not initialized
    
    // Constants
    mov w21, #8             // char_width = 8
    mov w22, #12            // char_height = 12
    
    // int offset = (frame * SCROLL_SPEED) % TILE_SIZE
    // OPTIMIZATION: bitwise AND since TILE_SIZE=32 is power of 2  
    mov w0, #2              // SCROLL_SPEED = 2
    mul w0, w20, w0         // frame * SCROLL_SPEED
    and w23, w0, #31        // offset = (frame * SCROLL_SPEED) & 31 (equivalent to % 32)
    
    // int tiles_per_screen = (VIS_WIDTH / TILE_SIZE) + 2
    mov w0, #800            // VIS_WIDTH = 800
    mov w1, #32             // TILE_SIZE = 32
    udiv w0, w0, w1         // VIS_WIDTH / TILE_SIZE = 25
    add w24, w0, #2         // tiles_per_screen = 25 + 2 = 27
    
    // int scroll_tiles = (frame * SCROLL_SPEED) / TILE_SIZE
    mov w0, #2              // SCROLL_SPEED = 2
    mul w0, w20, w0         // frame * SCROLL_SPEED
    mov w1, #32             // TILE_SIZE = 32
    udiv w25, w0, w1        // scroll_tiles = (frame * SCROLL_SPEED) / TILE_SIZE
    
    // Get terrain pattern pointer
    adrp x27, terrain_pattern@PAGE
    add x27, x27, terrain_pattern@PAGEOFF
    
    mov w28, #0             // i = 0 (tile index)
    
.Ldraw_tile_loop:
    cmp w28, w24            // i < tiles_per_screen?
    b.ge .Ldraw_terrain_done
    
    // int terrain_idx = (scroll_tiles + i) % TERRAIN_LENGTH
    // OPTIMIZATION: bitwise AND since TERRAIN_LENGTH=64 is power of 2
    add w0, w25, w28        // scroll_tiles + i
    and w0, w0, #63         // terrain_idx = (scroll_tiles + i) & 63 (equivalent to % 64)
    
    // Load terrain tile: terrain_tile_t terrain = terrain_pattern[terrain_idx]
    mov w1, #8              // sizeof(terrain_tile_t) = 8
    mul w2, w0, w1          // terrain_idx * 8
    add x2, x27, w2, uxtw   // &terrain_pattern[terrain_idx]
    ldr w1, [x2]            // terrain.type
    ldr w2, [x2, #4]        // terrain.height
    
    // Store terrain data on stack  
    str w1, [sp, #100]      // terrain.type
    str w2, [sp, #104]      // terrain.height
    
    // int x0 = i * TILE_SIZE - offset
    mov w0, #32             // TILE_SIZE = 32
    mul w0, w28, w0         // i * TILE_SIZE
    sub w0, w0, w23         // x0 = i * TILE_SIZE - offset
    str w0, [sp, #108]      // Store x0
    
    // if (terrain.type == TERRAIN_GAP) continue
    cmp w1, #4              // TERRAIN_GAP = 4
    b.eq .Ldraw_next_tile   // Skip drawing for gaps
    
    // Draw tiles based on height
    mov w0, #0              // row = 0
    str w0, [sp, #112]      // Store row
    
.Ldraw_row_loop:
    ldr w0, [sp, #112]      // Load row
    ldr w1, [sp, #104]      // Load terrain.height
    cmp w0, w1              // row < terrain.height?
    b.ge .Ldraw_next_tile
    
    // int y0 = VIS_HEIGHT - (row + 1) * TILE_SIZE
    add w1, w0, #1          // row + 1
    mov w2, #32             // TILE_SIZE = 32
    mul w1, w1, w2          // (row + 1) * TILE_SIZE
    mov w2, #600            // VIS_HEIGHT = 600
    sub w1, w2, w1          // y0 = VIS_HEIGHT - (row + 1) * TILE_SIZE
    str w1, [sp, #116]      // Store y0
    
    // Choose which ASCII pattern to use
    ldr w1, [sp, #100]      // terrain.type
    ldr w2, [sp, #104]      // terrain.height
    sub w3, w2, #1          // terrain.height - 1
    cmp w0, w3              // row == terrain.height - 1?
    b.ne .Ldraw_use_flat_pattern
    
    // Check if slope pattern should be used
    cmp w1, #2              // TERRAIN_SLOPE_UP = 2
    b.eq .Ldraw_use_slope_up_pattern
    cmp w1, #3              // TERRAIN_SLOPE_DOWN = 3
    b.eq .Ldraw_use_slope_down_pattern
    
.Ldraw_use_flat_pattern:
    adrp x0, tile_flat_pattern@PAGE
    add x0, x0, tile_flat_pattern@PAGEOFF
    b .Ldraw_pattern_chosen
    
.Ldraw_use_slope_up_pattern:
    adrp x0, tile_slope_up_pattern@PAGE
    add x0, x0, tile_slope_up_pattern@PAGEOFF
    b .Ldraw_pattern_chosen
    
.Ldraw_use_slope_down_pattern:
    adrp x0, tile_slope_down_pattern@PAGE
    add x0, x0, tile_slope_down_pattern@PAGEOFF
    
.Ldraw_pattern_chosen:
    str x0, [sp, #124]      // Store pattern pointer
    
    // Draw ASCII characters from the pattern
    // for (int ty = 0; ty < TILE_SIZE; ty += char_height)
    mov w0, #0              // ty = 0
    str w0, [sp, #132]      // Store ty
    
.Ldraw_ty_loop:
    ldr w0, [sp, #132]      // Load ty
    cmp w0, #32             // ty < TILE_SIZE?
    b.ge .Ldraw_next_row
    
    // for (int tx = 0; tx < TILE_SIZE; tx += char_width)
    mov w1, #0              // tx = 0
    str w1, [sp, #136]      // Store tx
    
.Ldraw_tx_loop:
    ldr w1, [sp, #136]      // Load tx
    cmp w1, #32             // tx < TILE_SIZE?
    b.ge .Ldraw_next_ty
    
    // int pattern_x = tx / char_width
    udiv w2, w1, w21        // pattern_x = tx / char_width
    
    // int pattern_y = ty / char_height
    udiv w3, w0, w22        // pattern_y = ty / char_height
    
    // Bounds check: pattern_x < TILE_SIZE/char_width && pattern_y < TILE_SIZE/char_height
    mov w4, #32             // TILE_SIZE = 32
    udiv w5, w4, w21        // TILE_SIZE / char_width = 32 / 8 = 4
    cmp w2, w5
    b.ge .Ldraw_next_tx
    
    udiv w5, w4, w22        // TILE_SIZE / char_height = 32 / 12 = 2 (rounded down)
    cmp w3, w5
    b.ge .Ldraw_next_tx
    
    // int pattern_idx = pattern_y * (TILE_SIZE/char_width) + pattern_x
    mov w4, #32             // TILE_SIZE = 32
    udiv w5, w4, w21        // TILE_SIZE / char_width = 4
    mul w6, w3, w5          // pattern_y * (TILE_SIZE/char_width)
    add w6, w6, w2          // pattern_idx = pattern_y * 4 + pattern_x
    
    // Bounds check: pattern_idx < TILE_SIZE * TILE_SIZE
    mov w4, #1024           // TILE_SIZE * TILE_SIZE = 32 * 32 = 1024
    cmp w6, w4
    b.ge .Ldraw_next_tx
    
    // char c = pattern[pattern_idx]
    ldr x4, [sp, #124]      // Load pattern pointer
    ldrb w5, [x4, w6, uxtw] // Load character c
    
    // if (c != ' ') - Skip transparent characters
    cmp w5, #' '
    b.eq .Ldraw_check_noise
    
    // Calculate screen coordinates
    // int screen_x = x0 + tx
    ldr w6, [sp, #108]      // Load x0
    add w6, w6, w1          // screen_x = x0 + tx
    
    // int screen_y = y0 + ty
    ldr w7, [sp, #116]      // Load y0
    add w7, w7, w0          // screen_y = y0 + ty
    
    // Bounds check: screen_x >= 0 && screen_x < VIS_WIDTH - char_width
    cmp w6, #0
    b.lt .Ldraw_next_tx
    mov w8, #800            // VIS_WIDTH = 800
    sub w8, w8, w21         // VIS_WIDTH - char_width = 800 - 8 = 792
    cmp w6, w8
    b.ge .Ldraw_next_tx
    
    // Bounds check: screen_y >= 0 && screen_y < VIS_HEIGHT - char_height
    cmp w7, #0
    b.lt .Ldraw_next_tx
    mov w8, #600            // VIS_HEIGHT = 600
    sub w8, w8, w22         // VIS_HEIGHT - char_height = 600 - 12 = 588
    cmp w7, w8
    b.ge .Ldraw_next_tx
    
    // Calculate dynamic color for this character
    // uint32_t color = get_dynamic_terrain_color(terrain_type, screen_x, screen_y, frame, audio_level)
    ldr w0, [sp, #100]      // terrain.type
    mov w1, w6              // screen_x
    mov w2, w7              // screen_y
    mov w3, w20             // frame
    ldr s0, [sp, #96]       // audio_level
    str w5, [sp, #140]      // Save character
    str w6, [sp, #144]      // Save screen_x
    str w7, [sp, #148]      // Save screen_y
    bl _get_dynamic_terrain_color_asm
    str w0, [sp, #152]      // Save dynamic color
    
    // Restore values
    ldr w5, [sp, #140]      // Restore character
    ldr w6, [sp, #144]      // Restore screen_x  
    ldr w7, [sp, #148]      // Restore screen_y
    
    // Apply glitch effects to the character
    // char glitched_char = c (default)
    mov w8, w5              // glitched_char = c
    
    // Check for matrix cascade first (overrides other effects)
    // if (should_apply_matrix_cascade(screen_x, screen_y, frame))
    mov w0, w6              // screen_x
    mov w1, w7              // screen_y
    mov w2, w20             // frame
    str w5, [sp, #156]      // Save original character
    str w6, [sp, #160]      // Save screen_x
    str w7, [sp, #164]      // Save screen_y
    str w8, [sp, #168]      // Save glitched_char
    bl _should_apply_matrix_cascade
    
    cmp w0, #0
    b.eq .Ldraw_apply_terrain_glitch
    
    // glitched_char = get_matrix_cascade_char(screen_x, screen_y, frame)
    ldr w0, [sp, #160]      // screen_x
    ldr w1, [sp, #164]      // screen_y
    mov w2, w20             // frame
    bl _get_matrix_cascade_char
    str w0, [sp, #168]      // Update glitched_char
    b .Ldraw_render_char
    
.Ldraw_apply_terrain_glitch:
    // glitched_char = get_glitched_terrain_char(c, screen_x, screen_y, frame)
    ldr w0, [sp, #156]      // original character
    ldr w1, [sp, #160]      // screen_x
    ldr w2, [sp, #164]      // screen_y
    mov w3, w20             // frame
    bl _get_glitched_terrain_char
    str w0, [sp, #168]      // Update glitched_char
    
.Ldraw_render_char:
    // draw_ascii_char(pixels, screen_x, screen_y, glitched_char, dynamic_color, 255)
    mov x0, x19             // pixels
    ldr w1, [sp, #160]      // screen_x
    ldr w2, [sp, #164]      // screen_y
    ldr w3, [sp, #168]      // glitched_char
    ldr w4, [sp, #152]      // dynamic_color (calculated earlier)
    mov w5, #255            // alpha = 255
    bl _draw_ascii_char_asm
    
    b .Ldraw_next_tx
    
.Ldraw_check_noise:
    // Even on transparent areas, occasionally show digital noise
    // Calculate screen coordinates
    ldr w6, [sp, #108]      // Load x0
    add w6, w6, w1          // screen_x = x0 + tx
    
    ldr w7, [sp, #116]      // Load y0
    add w7, w7, w0          // screen_y = y0 + ty
    
    // Bounds check (same as above)
    cmp w6, #0
    b.lt .Ldraw_next_tx
    mov w8, #800            // VIS_WIDTH = 800
    sub w8, w8, w21         // VIS_WIDTH - char_width
    cmp w6, w8
    b.ge .Ldraw_next_tx
    
    cmp w7, #0
    b.lt .Ldraw_next_tx
    mov w8, #600            // VIS_HEIGHT = 600
    sub w8, w8, w22         // VIS_HEIGHT - char_height
    cmp w7, w8
    b.ge .Ldraw_next_tx
    
    // char noise_char = get_digital_noise_char(screen_x, screen_y, frame)
    mov w0, w6              // screen_x
    mov w1, w7              // screen_y
    mov w2, w20             // frame
    str w6, [sp, #172]      // Save screen_x
    str w7, [sp, #176]      // Save screen_y
    bl _get_digital_noise_char
    
    // if (noise_char != ' ')
    cmp w0, #' '
    b.eq .Ldraw_next_tx
    
    // Calculate dynamic color for noise too (using gap terrain type for variety)
    str w0, [sp, #180]      // Save noise_char
    mov w0, #4              // TERRAIN_GAP for noise
    ldr w1, [sp, #172]      // screen_x
    ldr w2, [sp, #176]      // screen_y
    mov w3, w20             // frame
    ldr s0, [sp, #96]       // audio_level
    bl _get_dynamic_terrain_color_asm
    
    // Use dimmer dynamic color for noise: draw_ascii_char(pixels, screen_x, screen_y, noise_char, dynamic_color, 128)
    mov w4, w0              // dynamic_color
    ldr w3, [sp, #180]      // noise_char
    mov x0, x19             // pixels
    ldr w1, [sp, #172]      // screen_x
    ldr w2, [sp, #176]      // screen_y
    mov w5, #128            // alpha = 128 (dimmer)
    bl _draw_ascii_char_asm
    
.Ldraw_next_tx:
    ldr w1, [sp, #136]      // Load tx
    add w1, w1, w21         // tx += char_width
    str w1, [sp, #136]      // Store tx
    b .Ldraw_tx_loop
    
.Ldraw_next_ty:
    ldr w0, [sp, #132]      // Load ty
    add w0, w0, w22         // ty += char_height
    str w0, [sp, #132]      // Store ty
    b .Ldraw_ty_loop
    
.Ldraw_next_row:
    ldr w0, [sp, #112]      // Load row
    add w0, w0, #1          // row++
    str w0, [sp, #112]      // Store row
    b .Ldraw_row_loop
    
.Ldraw_next_tile:
    add w28, w28, #1        // i++
    b .Ldraw_tile_loop
    
.Ldraw_terrain_done:
    ldp x27, x28, [sp, #80]
    ldp x25, x26, [sp, #64]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #160
    ret

// Compatibility wrapper for old draw_terrain_asm function
// void draw_terrain(uint32_t *pixels, int frame)
// Input: x0 = pixels, w1 = frame
.global _draw_terrain_asm
_draw_terrain_asm:
    // Call enhanced version with default audio level
    adr x2, .Lconst_0_5
    ldr s0, [x2]            // audio_level = 0.5 (moderate)
    b _draw_terrain_enhanced_asm

// Constants
.align 4
.Lconst_magic:
    .long 0x7E44A1          // Magic number for terrain generation

// Floating point constants
.Lconst_0_1:
    .float 0.1
.Lconst_0_15:
    .float 0.15
.Lconst_0_2:
    .float 0.2
.Lconst_0_3:
    .float 0.3
.Lconst_0_5:
    .float 0.5
.Lconst_0_6:
    .float 0.6
.Lconst_0_8:
    .float 0.8
.Lconst_0_9:
    .float 0.9
.Lconst_1_0:
    .float 1.0
.Lconst_100:
    .float 100.0
.Lconst_600:
    .float 600.0
.Lconst_1000:
    .float 1000.0

---END---

[CHUNK 1 OF 3]
BUNDLE_5_BASS_HITS - PART 1
Concatenate all chunks in order to reconstruct.

[NOTDEAFBEEF BLOCKCHAIN BUNDLE - BUNDLE_5_BASS_HITS]
=============================================================
Bass hits and shape system (largest file)
Generated for on-chain storage following deafbeef methodology.

[MANIFEST]
Bundle: bundle_5_bass_hits
Total files: 1
Files included:
  - visual/bass_hits.s (61657 bytes)

Reconstruction: Save each file to its path and build with provided instructions.

=== FILE: visual/bass_hits.s ===
---BEGIN---
.section __TEXT,__text,regular,pure_instructions
.align 2

// External function declarations
.extern _get_glitched_shape_char
.extern _draw_ascii_char_asm
.extern _cosf
.extern _sinf

// Bass hit data structures
.section __DATA,__data
.align 5

// Bass hit array - 16 hits * 32 bytes each = 512 bytes
// bass_hit_t structure layout:
// - shape_type: 4 bytes (bass_shape_type_t enum)
// - color: 4 bytes (color_t struct: r,g,b,a)
// - alpha: 4 bytes (int)
// - scale: 4 bytes (float)
// - max_size: 4 bytes (float)
// - rotation: 4 bytes (float)
// - rot_speed: 4 bytes (float)
// - active: 4 bytes (bool padded to 4)
// Total: 32 bytes per bass_hit_t
bass_hits_array:
    .space (16 * 32), 0     // MAX_BASS_HITS * sizeof(bass_hit_t)

bass_hits_initialized:
    .space 1, 0             // bool

last_bass_step:
    .space 4, 0             // int

// OPTIMIZATION: Trig lookup tables (256 entries each, 1KB total)
// sin/cos values for angles 0 to 2π with linear interpolation
.align 4
sin_lut:
    .float 0.000000, 0.024541, 0.049068, 0.073565, 0.098017, 0.122411, 0.146730, 0.170962
    .float 0.195090, 0.219101, 0.242980, 0.266713, 0.290285, 0.313682, 0.336890, 0.359895
    .float 0.382683, 0.405241, 0.427555, 0.449611, 0.471397, 0.492898, 0.514103, 0.534998
    .float 0.555570, 0.575808, 0.595699, 0.615232, 0.634393, 0.653173, 0.671559, 0.689541
    .float 0.707107, 0.724247, 0.740951, 0.757209, 0.773010, 0.788346, 0.803208, 0.817585
    .float 0.831470, 0.844854, 0.857729, 0.870087, 0.881921, 0.893224, 0.903989, 0.914210
    .float 0.923880, 0.932993, 0.941544, 0.949528, 0.956940, 0.963776, 0.970031, 0.975702
    .float 0.980785, 0.985278, 0.989177, 0.992480, 0.995185, 0.997290, 0.998795, 0.999699
    .float 1.000000, 0.999699, 0.998795, 0.997290, 0.995185, 0.992480, 0.989177, 0.985278
    .float 0.980785, 0.975702, 0.970031, 0.963776, 0.956940, 0.949528, 0.941544, 0.932993
    .float 0.923880, 0.914210, 0.903989, 0.893224, 0.881921, 0.870087, 0.857729, 0.844854
    .float 0.831470, 0.817585, 0.803208, 0.788346, 0.773010, 0.757209, 0.740951, 0.724247
    .float 0.707107, 0.689541, 0.671559, 0.653173, 0.634393, 0.615232, 0.595699, 0.575808
    .float 0.555570, 0.534998, 0.514103, 0.492898, 0.471397, 0.449611, 0.427555, 0.405241
    .float 0.382683, 0.359895, 0.336890, 0.313682, 0.290285, 0.266713, 0.242980, 0.219101
    .float 0.195090, 0.170962, 0.146730, 0.122411, 0.098017, 0.073565, 0.049068, 0.024541
    .float 0.000000, -0.024541, -0.049068, -0.073565, -0.098017, -0.122411, -0.146730, -0.170962
    .float -0.195090, -0.219101, -0.242980, -0.266713, -0.290285, -0.313682, -0.336890, -0.359895
    .float -0.382683, -0.405241, -0.427555, -0.449611, -0.471397, -0.492898, -0.514103, -0.534998
    .float -0.555570, -0.575808, -0.595699, -0.615232, -0.634393, -0.653173, -0.671559, -0.689541
    .float -0.707107, -0.724247, -0.740951, -0.757209, -0.773010, -0.788346, -0.803208, -0.817585
    .float -0.831470, -0.844854, -0.857729, -0.870087, -0.881921, -0.893224, -0.903989, -0.914210
    .float -0.923880, -0.932993, -0.941544, -0.949528, -0.956940, -0.963776, -0.970031, -0.975702
    .float -0.980785, -0.985278, -0.989177, -0.992480, -0.995185, -0.997290, -0.998795, -0.999699
    .float -1.000000, -0.999699, -0.998795, -0.997290, -0.995185, -0.992480, -0.989177, -0.985278
    .float -0.980785, -0.975702, -0.970031, -0.963776, -0.956940, -0.949528, -0.941544, -0.932993
    .float -0.923880, -0.914210, -0.903989, -0.893224, -0.881921, -0.870087, -0.857729, -0.844854
    .float -0.831470, -0.817585, -0.803208, -0.788346, -0.773010, -0.757209, -0.740951, -0.724247
    .float -0.707107, -0.689541, -0.671559, -0.653173, -0.634393, -0.615232, -0.595699, -0.575808
    .float -0.555570, -0.534998, -0.514103, -0.492898, -0.471397, -0.449611, -0.427555, -0.405241
    .float -0.382683, -0.359895, -0.336890, -0.313682, -0.290285, -0.266713, -0.242980, -0.219101
    .float -0.195090, -0.170962, -0.146730, -0.122411, -0.098017, -0.073565, -0.049068, -0.024541

cos_lut:
    .float 1.000000, 0.999699, 0.998795, 0.997290, 0.995185, 0.992480, 0.989177, 0.985278
    .float 0.980785, 0.975702, 0.970031, 0.963776, 0.956940, 0.949528, 0.941544, 0.932993
    .float 0.923880, 0.914210, 0.903989, 0.893224, 0.881921, 0.870087, 0.857729, 0.844854
    .float 0.831470, 0.817585, 0.803208, 0.788346, 0.773010, 0.757209, 0.740951, 0.724247
    .float 0.707107, 0.689541, 0.671559, 0.653173, 0.634393, 0.615232, 0.595699, 0.575808
    .float 0.555570, 0.534998, 0.514103, 0.492898, 0.471397, 0.449611, 0.427555, 0.405241
    .float 0.382683, 0.359895, 0.336890, 0.313682, 0.290285, 0.266713, 0.242980, 0.219101
    .float 0.195090, 0.170962, 0.146730, 0.122411, 0.098017, 0.073565, 0.049068, 0.024541
    .float 0.000000, -0.024541, -0.049068, -0.073565, -0.098017, -0.122411, -0.146730, -0.170962
    .float -0.195090, -0.219101, -0.242980, -0.266713, -0.290285, -0.313682, -0.336890, -0.359895
    .float -0.382683, -0.405241, -0.427555, -0.449611, -0.471397, -0.492898, -0.514103, -0.534998
    .float -0.555570, -0.575808, -0.595699, -0.615232, -0.634393, -0.653173, -0.671559, -0.689541
    .float -0.707107, -0.724247, -0.740951, -0.757209, -0.773010, -0.788346, -0.803208, -0.817585
    .float -0.831470, -0.844854, -0.857729, -0.870087, -0.881921, -0.893224, -0.903989, -0.914210
    .float -0.923880, -0.932993, -0.941544, -0.949528, -0.956940, -0.963776, -0.970031, -0.975702
    .float -0.980785, -0.985278, -0.989177, -0.992480, -0.995185, -0.997290, -0.998795, -0.999699
    .float -1.000000, -0.999699, -0.998795, -0.997290, -0.995185, -0.992480, -0.989177, -0.985278
    .float -0.980785, -0.975702, -0.970031, -0.963776, -0.956940, -0.949528, -0.941544, -0.932993
    .float -0.923880, -0.914210, -0.903989, -0.893224, -0.881921, -0.870087, -0.857729, -0.844854
    .float -0.831470, -0.817585, -0.803208, -0.788346, -0.773010, -0.757209, -0.740951, -0.724247
    .float -0.707107, -0.689541, -0.671559, -0.653173, -0.634393, -0.615232, -0.595699, -0.575808
    .float -0.555570, -0.534998, -0.514103, -0.492898, -0.471397, -0.449611, -0.427555, -0.405241
    .float -0.382683, -0.359895, -0.336890, -0.313682, -0.290285, -0.266713, -0.242980, -0.219101
    .float -0.195090, -0.170962, -0.146730, -0.122411, -0.098017, -0.073565, -0.049068, -0.024541

.section __TEXT,__text,regular,pure_instructions

// Initialize bass hit system
// void init_bass_hits(void)
.global _init_bass_hits_asm
_init_bass_hits_asm:
    stp x29, x30, [sp, #-16]!
    mov x29, sp
    
    // Check if already initialized
    adrp x0, bass_hits_initialized@PAGE
    add x0, x0, bass_hits_initialized@PAGEOFF
    ldrb w1, [x0]
    cmp w1, #0
    b.ne .Linit_bass_done   // Return if already initialized
    
    // Get bass hits array pointer
    adrp x1, bass_hits_array@PAGE
    add x1, x1, bass_hits_array@PAGEOFF
    
    // Initialize all bass hits as inactive
    mov w2, #0              // i = 0
.Linit_bass_loop:
    cmp w2, #16             // MAX_BASS_HITS = 16
    b.ge .Linit_bass_set_flag
    
    // Calculate offset: bass_hits[i].active = false
    mov w3, #32             // sizeof(bass_hit_t) = 32
    mul w4, w2, w3          // i * 32
    add w4, w4, #28         // offset to 'active' field (last 4 bytes)
    mov w5, #0              // false = 0
    str w5, [x1, w4, uxtw]  // Store active = false
    
    add w2, w2, #1          // i++
    b .Linit_bass_loop
    
.Linit_bass_set_flag:
    // Set initialized flag
    mov w1, #1
    strb w1, [x0]           // bass_hits_initialized = true
    
.Linit_bass_done:
    ldp x29, x30, [sp], #16
    ret

// Reset bass hit step tracking
// void reset_bass_hit_step_tracking(void)
.global _reset_bass_hit_step_tracking_asm
_reset_bass_hit_step_tracking_asm:
    // last_bass_step = -1
    adrp x0, last_bass_step@PAGE
    add x0, x0, last_bass_step@PAGEOFF
    mov w1, #-1
    str w1, [x0]
    ret

// Helper function to get bass hits array pointer
// bass_hit_t* get_bass_hits_ptr_asm(void)
.global _get_bass_hits_ptr_asm
_get_bass_hits_ptr_asm:
    adrp x0, bass_hits_array@PAGE
    add x0, x0, bass_hits_array@PAGEOFF
    ret

// Helper function to get last bass step pointer
// int* get_last_bass_step_ptr_asm(void)
.global _get_last_bass_step_ptr_asm
_get_last_bass_step_ptr_asm:
    adrp x0, last_bass_step@PAGE
    add x0, x0, last_bass_step@PAGEOFF
    ret

// Helper function to get bass hits initialized flag pointer
// bool* get_bass_hits_initialized_ptr_asm(void)
.global _get_bass_hits_initialized_ptr_asm
_get_bass_hits_initialized_ptr_asm:
    adrp x0, bass_hits_initialized@PAGE
    add x0, x0, bass_hits_initialized@PAGEOFF
    ret

// Create a new bass hit
// static void spawn_bass_hit(float base_hue, uint32_t seed)
// Input: s0 = base_hue (float), w0 = seed (uint32_t)
.global _spawn_bass_hit_asm
_spawn_bass_hit_asm:
    stp x29, x30, [sp, #-96]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    str s0, [sp, #64]       // Save base_hue
    str w0, [sp, #68]       // Save seed
    
    // Get bass hits array pointer
    adrp x19, bass_hits_array@PAGE
    add x19, x19, bass_hits_array@PAGEOFF
    
    // Find free slot
    mov w20, #-1            // slot = -1
    mov w21, #0             // i = 0
    
.Lspawn_find_slot:
    cmp w21, #16            // MAX_BASS_HITS = 16
    b.ge .Lspawn_check_slot
    
    // Check if bass_hits[i].active == false
    mov w22, #32            // sizeof(bass_hit_t) = 32
    mul w23, w21, w22       // i * 32
    add w23, w23, #28       // offset to 'active' field
    ldr w24, [x19, w23, uxtw] // Load active flag
    
    cmp w24, #0             // active == false
    b.ne .Lspawn_next_slot
    
    // Found free slot
    mov w20, w21            // slot = i
    b .Lspawn_check_slot
    
.Lspawn_next_slot:
    add w21, w21, #1        // i++
    b .Lspawn_find_slot
    
.Lspawn_check_slot:
    cmp w20, #-1            // if (slot == -1)
    b.eq .Lspawn_done       // return (no free slots)
    
    // Get pointer to bass_hits[slot]
    mov w22, #32            // sizeof(bass_hit_t)
    mul w23, w20, w22       // slot * 32
    add x21, x19, w23, uxtw // hit = &bass_hits[slot]
    
    // srand(seed + slot)
    ldr w0, [sp, #68]       // Load seed
    add w0, w0, w20         // seed + slot
    bl _srand
    
    // Choose random shape type: shape_types[rand() % 5]
    bl _rand
    mov w1, #5
    udiv w2, w0, w1         // w2 = rand() / 5
    msub w22, w2, w1, w0    // w22 = rand() % 5 = shape_type
    
    // Store shape_type: hit->shape_type = shape_type
    str w22, [x21]          // Store at offset 0
    
    // Generate color with hue shift
    // float hue_shift = ((rand() / (float)RAND_MAX) - 0.5f) * 0.4f
    bl _rand
    ucvtf s1, w0            // Convert rand() to float
    
    // Load RAND_MAX constant (2147483647 = 0x7FFFFFFF)
    adr x0, .Lconst_rand_max
    ldr s2, [x0]            // s2 = RAND_MAX as float
    fdiv s1, s1, s2         // s1 = rand() / RAND_MAX
    
    adr x0, .Lconst_0_5
    ldr s2, [x0]            // s2 = 0.5f
    fsub s1, s1, s2         // s1 = (rand() / RAND_MAX) - 0.5f
    
    adr x0, .Lconst_0_4
    ldr s2, [x0]            // s2 = 0.4f
    fmul s1, s1, s2         // s1 = hue_shift = ((rand() / RAND_MAX) - 0.5f) * 0.4f
    
    // hsv_t hit_hsv = {fmod(base_hue + hue_shift, 1.0f), 1.0f, 1.0f}
    ldr s0, [sp, #64]       // Load base_hue
    fadd s0, s0, s1         // base_hue + hue_shift
    
    // fmod(base_hue + hue_shift, 1.0f)
    adr x0, .Lconst_1_0
    ldr s2, [x0]            // s2 = 1.0f
    fdiv s3, s0, s2         // s3 = (base_hue + hue_shift) / 1.0f
    fcvtms w0, s3           // w0 = floor(division)
    scvtf s3, w0            // s3 = floor as float
    fmsub s0, s3, s2, s0    // s0 = fmod result
    
    // Create HSV struct on stack: {h, s, v}
    str s0, [sp, #72]       // h = fmod result
    adr x0, .Lconst_1_0
    ldr s1, [x0]            // s = 1.0f
    str s1, [sp, #76]       // s = 1.0f
    str s1, [sp, #80]       // v = 1.0f (reuse same constant)
    
    // Convert HSV to RGB: hit->color = hsv_to_rgb(hit_hsv)
    add x0, sp, #72         // pointer to HSV struct
    add x1, x21, #4         // pointer to hit->color (offset 4)
    bl _hsv_to_rgb
    
    // Set initial properties
    // hit->alpha = 255
    mov w0, #255
    str w0, [x21, #8]       // Store at offset 8
    
    // hit->scale = 0.1f
    adr x0, .Lconst_0_1
    ldr s0, [x0]
    str s0, [x21, #12]      // Store at offset 12
    
    // hit->max_size = (VIS_WIDTH < VIS_HEIGHT ? VIS_WIDTH : VIS_HEIGHT) * 0.6f
    mov w0, #800            // VIS_WIDTH
    mov w1, #600            // VIS_HEIGHT
    cmp w0, w1
    csel w0, w0, w1, lo     // w0 = min(VIS_WIDTH, VIS_HEIGHT) = 600
    ucvtf s0, w0            // Convert to float
    adr x1, .Lconst_0_6
    ldr s1, [x1]            // s1 = 0.6f
    fmul s0, s0, s1         // s0 = min_dimension * 0.6f
    str s0, [x21, #16]      // Store max_size at offset 16
    
    // hit->rotation = 0.0f
    fmov s0, wzr            // s0 = 0.0f
    str s0, [x21, #20]      // Store at offset 20
    
    // hit->rot_speed = ((rand() / (float)RAND_MAX) - 0.5f) * 0.1f
    bl _rand
    ucvtf s0, w0            // Convert rand() to float
    adr x0, .Lconst_rand_max
    ldr s1, [x0]            // s1 = RAND_MAX
    fdiv s0, s0, s1         // s0 = rand() / RAND_MAX
    adr x0, .Lconst_0_5
    ldr s1, [x0]            // s1 = 0.5f
    fsub s0, s0, s1         // s0 = (rand() / RAND_MAX) - 0.5f
    adr x0, .Lconst_0_1
    ldr s1, [x0]            // s1 = 0.1f
    fmul s0, s0, s1         // s0 = rot_speed
    str s0, [x21, #24]      // Store at offset 24
    
    // hit->active = true
    mov w0, #1
    str w0, [x21, #28]      // Store at offset 28
    
.Lspawn_done:
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #96
    ret

// Fast sine lookup using 256-entry table
// Input: s0 = angle (radians), Output: s0 = sin(angle)
.global _sin_lut_asm
_sin_lut_asm:
    // Convert angle to table index: index = (angle / (2*π)) * 256
    adr x1, .Lconst_2pi_inv
    ldr s1, [x1]            // 1/(2π) = 0.159155
    fmul s1, s0, s1         // angle / (2π)
    adr x1, .Lconst_256
    ldr s2, [x1]            // 256.0
    fmul s1, s1, s2         // * 256
    fcvtms w1, s1           // index = floor(angle_norm * 256)
    and w1, w1, #255        // index &= 255 (wrap around)
    
    // Load from sin LUT
    adrp x2, sin_lut@PAGE
    add x2, x2, sin_lut@PAGEOFF
    lsl w1, w1, #2          // index * 4 (float size)
    ldr s0, [x2, w1, uxtw]  // sin_lut[index]
    ret

// Fast cosine lookup using 256-entry table  
// Input: s0 = angle (radians), Output: s0 = cos(angle)
.global _cos_lut_asm
_cos_lut_asm:
    // Convert angle to table index: index = (angle / (2*π)) * 256
    adr x1, .Lconst_2pi_inv
    ldr s1, [x1]            // 1/(2π) = 0.159155
    fmul s1, s0, s1         // angle / (2π)
    adr x1, .Lconst_256
    ldr s2, [x1]            // 256.0
    fmul s1, s1, s2         // * 256
    fcvtms w1, s1           // index = floor(angle_norm * 256)
    and w1, w1, #255        // index &= 255 (wrap around)
    
    // Load from cos LUT
    adrp x2, cos_lut@PAGE
    add x2, x2, cos_lut@PAGEOFF
    lsl w1, w1, #2          // index * 4 (float size)
    ldr s0, [x2, w1, uxtw]  // cos_lut[index]
    ret

// Floating point constants
.align 4
.Lconst_2pi_inv:
    .float 0.159155         // 1/(2π) for angle normalization
.Lconst_256:
    .float 256.0            // LUT size
.Lconst_rand_max:
    .float 2147483647.0     // RAND_MAX as float
.Lconst_0_5:
    .float 0.5
.Lconst_0_4:
    .float 0.4
.Lconst_1_0:
    .float 1.0
.Lconst_0_1:
    .float 0.1
.Lconst_0_6:
    .float 0.6

// Draw ASCII hexagon
// void draw_ascii_hexagon(uint32_t *pixels, int cx, int cy, int size, float rotation, uint32_t color, int alpha, int frame)
// Input: x0=pixels, w1=cx, w2=cy, w3=size, s0=rotation, w4=color, w5=alpha, w6=frame
.global _draw_ascii_hexagon_asm
_draw_ascii_hexagon_asm:
    stp x29, x30, [sp, #-112]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    stp x25, x26, [sp, #64]
    stp x27, x28, [sp, #80]
    
    // Check size threshold
    cmp w3, #8
    b.lt .Lhex_done         // return if size < 8
    
    // Save all parameters to dedicated registers (no more w1-w6 reuse)
    mov x19, x0             // pixels pointer  
    mov w20, w1             // cx
    mov w21, w2             // cy  
    mov w22, w3             // size
    str s0, [sp, #96]       // rotation (on stack)
    mov w23, w4             // color
    mov w24, w5             // alpha
    mov w25, w6             // frame
    
    // Loop counter in dedicated register
    mov w26, #0             // i = 0 (dedicated loop counter)
    
    // for (int i = 0; i < 6; i++)
.Lhex_loop:
    cmp w26, #6
    b.ge .Lhex_done
    
    // float angle = rotation + i * M_PI / 3.0f
    scvtf s1, w26           // Convert i to float
    adr x0, .Lconst_pi_3    // M_PI / 3.0f ≈ 1.047198
    ldr s2, [x0]
    fmul s1, s1, s2         // i * (M_PI / 3.0f)
    ldr s0, [sp, #96]       // Load rotation
    fadd s0, s0, s1         // angle = rotation + i * (M_PI / 3.0f)
    
    // int x = cx + (int)(cosf(angle) * size * 0.7f)  
    // OPTIMIZATION: Use lookup table instead of libm cosf
    bl _cos_lut_asm         // s0 = cos(angle) from LUT
    scvtf s1, w22           // Convert size to float
    fmul s0, s0, s1         // cos(angle) * size
    adr x0, .Lconst_0_7     
    ldr s1, [x0]            // 0.7f
    fmul s0, s0, s1         // cos(angle) * size * 0.7f
    fcvtns w27, s0          // Convert to int, store in w27
    add w27, w20, w27       // x = cx + result
    
    // int y = cy + (int)(sinf(angle) * size * 0.7f)  
    // Recalculate angle since cosf modified s0
    scvtf s1, w26           // Convert i to float
    adr x0, .Lconst_pi_3    
    ldr s2, [x0]
    fmul s1, s1, s2         // i * (M_PI / 3.0f)
    ldr s0, [sp, #96]       // Load rotation
    fadd s0, s0, s1         // angle = rotation + i * (M_PI / 3.0f)
    
    // OPTIMIZATION: Use lookup table instead of libm sinf
    bl _sin_lut_asm         // s0 = sin(angle) from LUT
    scvtf s1, w22           // Convert size to float
    fmul s0, s0, s1         // sin(angle) * size
    adr x0, .Lconst_0_7
    ldr s1, [x0]            // 0.7f
    fmul s0, s0, s1         // sin(angle) * size * 0.7f
    fcvtns w28, s0          // Convert to int, store in w28
    add w28, w21, w28       // y = cy + result
    
    // char base_char = hex_chars[i % char_count]
    mov w0, #6              // char_count = 6
    udiv w1, w26, w0        // w1 = i / 6
    msub w0, w1, w0, w26    // w0 = i % 6
    adr x1, .Lhex_chars
    ldrb w0, [x1, w0, uxtw] // Load hex_chars[i % 6]
    
    // char glitched_char = get_glitched_shape_char(base_char, x, y, frame)
    // w0 already has base_char
    mov w1, w27             // x  
    mov w2, w28             // y
    mov w3, w25             // frame
    bl _get_glitched_shape_char
    // Result in w0 = glitched_char
    
    // draw_ascii_char(pixels, x, y, glitched_char, color, alpha)
    // w0 already has glitched_char, need to set up all parameters
    mov w3, w0              // glitched_char
    mov x0, x19             // pixels
    mov w1, w27             // x
    mov w2, w28             // y
    mov w4, w23             // color
    mov w5, w24             // alpha
    bl _draw_ascii_char_asm
    
    // Increment loop counter
    add w26, w26, #1        // i++
    b .Lhex_loop
    
.Lhex_done:
    ldp x27, x28, [sp, #80]
    ldp x25, x26, [sp, #64]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #112
    ret

// Draw ASCII square  
// void draw_ascii_square(uint32_t *pixels, int cx, int cy, int size, float rotation, uint32_t color, int alpha, int frame)
// Input: x0=pixels, w1=cx, w2=cy, w3=size, s0=rotation, w4=color, w5=alpha, w6=frame
.global _draw_ascii_square_asm
_draw_ascii_square_asm:
    stp x29, x30, [sp, #-160]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    stp x25, x26, [sp, #64]
    stp x27, x28, [sp, #80]
    
    // Check size threshold
    cmp w3, #8
    b.lt .Lsquare_done      // return if size < 8
    
    // Save all parameters to dedicated registers
    mov x19, x0             // pixels pointer  
    mov w20, w1             // cx
    mov w21, w2             // cy  
    mov w22, w3             // size (half)
    str s0, [sp, #96]       // rotation (on stack)
    mov w23, w4             // color
    mov w24, w5             // alpha
    mov w25, w6             // frame
    
    // Calculate initial corners (before rotation)
    // corners[4][2] = {{cx-half, cy-half}, {cx+half, cy-half}, {cx+half, cy+half}, {cx-half, cy+half}}
    sub w0, w20, w22        // cx - half
    sub w1, w21, w22        // cy - half
    stp w0, w1, [sp, #104]  // Store corner 0: top-left
    
    add w0, w20, w22        // cx + half  
    sub w1, w21, w22        // cy - half
    stp w0, w1, [sp, #112]  // Store corner 1: top-right
    
    add w0, w20, w22        // cx + half
    add w1, w21, w22        // cy + half  
    stp w0, w1, [sp, #120]  // Store corner 2: bottom-right
    
    sub w0, w20, w22        // cx - half
    add w1, w21, w22        // cy + half
    stp w0, w1, [sp, #128]  // Store corner 3: bottom-left
    
    // Apply rotation to corners and draw them
    mov w26, #0             // i = 0 (corner index)
    
.Lsquare_corner_loop:
    cmp w26, #4
    b.ge .Lsquare_edges     // Done with corners, now draw edges
    
    // Load corner coordinates
    mov w0, #8              // 8 bytes per corner (2 ints)
    mul w0, w26, w0         // i * 8
    add w0, w0, #104        // offset to corners array
    add x1, sp, w0, uxtw    // address of corners[i]
    ldp w27, w28, [x1]      // Load corners[i][0], corners[i][1]
    
    // Calculate dx = corners[i][0] - cx, dy = corners[i][1] - cy
    sub w0, w27, w20        // dx = corners[i][0] - cx
    sub w1, w28, w21        // dy = corners[i][1] - cy
    scvtf s0, w0            // dx as float
    scvtf s1, w1            // dy as float
    
    // Rotate: rotated_x = dx * cos(rotation) - dy * sin(rotation)
    //         rotated_y = dx * sin(rotation) + dy * cos(rotation)
    ldr s2, [sp, #96]       // Load rotation
    
    // Calculate cos(rotation)
    fmov s3, s2             // Copy rotation for cos call
    bl _cos_lut_asm         // s0 = cos(rotation) from LUT
    fmov s4, s0             // Save cos result in s4
    
    // Calculate sin(rotation)  
    ldr s2, [sp, #96]       // Reload rotation
    fmov s0, s2             // Set up for sin call
    bl _sin_lut_asm         // s0 = sin(rotation) from LUT
    fmov s5, s0             // Save sin result in s5
    
    // Now compute rotated coordinates
    // rotated_x = dx * cos(rotation) - dy * sin(rotation)
    fmul s6, s0, s4         // dx * cos(rotation)  -- wait, s0 is sin result, need to reload dx
    // Let me reload dx, dy
    sub w0, w27, w20        // dx = corners[i][0] - cx
    sub w1, w28, w21        // dy = corners[i][1] - cy  
    scvtf s0, w0            // dx as float
    scvtf s1, w1            // dy as float
    
    fmul s6, s0, s4         // dx * cos(rotation)
    fmul s7, s1, s5         // dy * sin(rotation)
    fsub s6, s6, s7         // rotated_x = dx * cos - dy * sin
    
    // rotated_y = dx * sin(rotation) + dy * cos[CHUNK 2 OF 3]
BUNDLE_5_BASS_HITS - PART 2
Concatenate all chunks in order to reconstruct.

(rotation)
    fmul s7, s0, s5         // dx * sin(rotation)
    fmul s8, s1, s4         // dy * cos(rotation)
    fadd s7, s7, s8         // rotated_y = dx * sin + dy * cos
    
    // Convert back to integers and add center
    fcvtns w0, s6           // rotated_x as int
    fcvtns w1, s7           // rotated_y as int
    add w27, w20, w0        // final_x = cx + rotated_x
    add w28, w21, w1        // final_y = cy + rotated_y
    
    // Store rotated corner back
    mov w0, #8              // 8 bytes per corner
    mul w0, w26, w0         // i * 8
    add w0, w0, #104        // offset to corners array
    add x1, sp, w0, uxtw    // address of corners[i]
    stp w27, w28, [x1]      // Store rotated coordinates
    
    // Get character: base_char = square_chars[i % char_count]
    mov w0, #6              // char_count = 6
    udiv w1, w26, w0        // w1 = i / 6
    msub w0, w1, w0, w26    // w0 = i % 6
    adr x1, .Lsquare_chars
    ldrb w0, [x1, w0, uxtw] // Load square_chars[i % 6]
    
    // char glitched_char = get_glitched_shape_char(base_char, x, y, frame)
    // w0 already has base_char
    mov w1, w27             // x  
    mov w2, w28             // y
    mov w3, w25             // frame
    bl _get_glitched_shape_char
    // Result in w0 = glitched_char
    
    // draw_ascii_char(pixels, x, y, glitched_char, color, alpha)
    mov w3, w0              // glitched_char
    mov x0, x19             // pixels
    mov w1, w27             // x
    mov w2, w28             // y
    mov w4, w23             // color
    mov w5, w24             // alpha
    bl _draw_ascii_char_asm
    
    // Increment corner index
    add w26, w26, #1        // i++
    b .Lsquare_corner_loop
    
.Lsquare_edges:
    // Draw square edges connecting corners
    mov w26, #0             // i = 0 (edge index)
    
.Lsquare_edge_loop:
    cmp w26, #4
    b.ge .Lsquare_done      // Done with all edges
    
    // Calculate next corner index: next = (i + 1) % 4
    add w0, w26, #1         // i + 1
    mov w1, #4              // 4 corners
    udiv w2, w0, w1         // (i + 1) / 4
    msub w27, w2, w1, w0    // next = (i + 1) % 4
    
    // Load current corner coordinates
    mov w0, #8              // 8 bytes per corner
    mul w0, w26, w0         // i * 8
    add w0, w0, #104        // offset to corners array
    add x1, sp, w0, uxtw    // address of corners[i]
    ldp w1, w2, [x1]        // Load corners[i][0], corners[i][1]
    
    // Load next corner coordinates  
    mov w0, #8              // 8 bytes per corner
    mul w0, w27, w0         // next * 8
    add w0, w0, #104        // offset to corners array
    add x3, sp, w0, uxtw    // address of corners[next]
    ldp w3, w4, [x3]        // Load corners[next][0], corners[next][1]
    
    // Calculate steps = (abs(next_x - curr_x) + abs(next_y - curr_y)) / 12
    sub w5, w3, w1          // next_x - curr_x
    cmp w5, #0
    cneg w5, w5, mi         // abs(next_x - curr_x)
    
    sub w6, w4, w2          // next_y - curr_y  
    cmp w6, #0
    cneg w6, w6, mi         // abs(next_y - curr_y)
    
    add w5, w5, w6          // sum of distances
    mov w6, #12
    udiv w28, w5, w6        // steps = distance / 12
    
    // Save corner coordinates for edge drawing
    str w1, [sp, #136]      // curr_x
    str w2, [sp, #140]      // curr_y (4-byte aligned)  
    str w3, [sp, #144]      // next_x
    str w4, [sp, #148]      // next_y
    
    // Draw line between corners
    mov w27, #1             // step = 1 (start from 1, not 0)
    
.Lsquare_line_loop:
    cmp w27, w28            // step < steps?
    b.ge .Lsquare_next_edge
    
    // Calculate t = (float)step / steps
    scvtf s0, w27           // step as float
    scvtf s1, w28           // steps as float
    fdiv s2, s0, s1         // t = step / steps
    
    // Calculate line coordinates
    // line_x = curr_x + (int)(t * (next_x - curr_x))
    ldr w0, [sp, #136]      // curr_x
    ldr w1, [sp, #144]      // next_x
    sub w1, w1, w0          // next_x - curr_x
    scvtf s0, w1            // (next_x - curr_x) as float
    fmul s0, s2, s0         // t * (next_x - curr_x)
    fcvtns w1, s0           // convert to int
    add w1, w0, w1          // line_x = curr_x + result
    
    // line_y = curr_y + (int)(t * (next_y - curr_y))
    ldr w0, [sp, #140]      // curr_y
    ldr w2, [sp, #148]      // next_y
    sub w2, w2, w0          // next_y - curr_y
    scvtf s0, w2            // (next_y - curr_y) as float
    fmul s0, s2, s0         // t * (next_y - curr_y)
    fcvtns w2, s0           // convert to int
    add w2, w0, w2          // line_y = curr_y + result
    
    // char line_char = get_glitched_shape_char('-', line_x, line_y, frame)
    mov w0, #'-'            // base character for lines
    // w1 already has line_x
    // w2 already has line_y  
    mov w3, w25             // frame
    bl _get_glitched_shape_char
    // Result in w0 = glitched_char
    
    // draw_ascii_char(pixels, line_x, line_y, glitched_char, color, alpha - 50)
    mov w3, w0              // glitched_char
    mov x0, x19             // pixels
    // w1 already has line_x
    // w2 already has line_y
    mov w4, w23             // color
    sub w5, w24, #50        // alpha - 50
    cmp w5, #0              // Ensure alpha doesn't go negative
    csel w5, w5, wzr, ge    // max(alpha - 50, 0)
    bl _draw_ascii_char_asm
    
    // Increment step
    add w27, w27, #1        // step++
    b .Lsquare_line_loop
    
.Lsquare_next_edge:
    // Increment edge index
    add w26, w26, #1        // i++
    b .Lsquare_edge_loop
    
.Lsquare_done:
    ldp x27, x28, [sp, #80]
    ldp x25, x26, [sp, #64]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #160
    ret

// Draw ASCII triangle
// void draw_ascii_triangle(uint32_t *pixels, int cx, int cy, int size, float rotation, uint32_t color, int alpha, int frame)
// Input: x0=pixels, w1=cx, w2=cy, w3=size, s0=rotation, w4=color, w5=alpha, w6=frame
.global _draw_ascii_triangle_asm
_draw_ascii_triangle_asm:
    stp x29, x30, [sp, #-144]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    stp x25, x26, [sp, #64]
    stp x27, x28, [sp, #80]
    
    // Check size threshold
    cmp w3, #8
    b.lt .Ltriangle_done    // return if size < 8
    
    // Save all parameters to dedicated registers
    mov x19, x0             // pixels pointer  
    mov w20, w1             // cx
    mov w21, w2             // cy  
    mov w22, w3             // size
    str s0, [sp, #96]       // rotation (on stack)
    mov w23, w4             // color
    mov w24, w5             // alpha
    mov w25, w6             // frame
    
    // Loop counter in dedicated register
    mov w26, #0             // i = 0 (vertex index, 0-2)
    
    // for (int i = 0; i < 3; i++)
.Ltriangle_vertex_loop:
    cmp w26, #3
    b.ge .Ltriangle_done
    
    // float angle = rotation + i * 2.0f * M_PI / 3.0f
    scvtf s1, w26           // Convert i to float
    adr x0, .Lconst_2pi_3   // 2.0f * M_PI / 3.0f ≈ 2.094395
    ldr s2, [x0]
    fmul s1, s1, s2         // i * (2.0f * M_PI / 3.0f)
    ldr s0, [sp, #96]       // Load rotation
    fadd s0, s0, s1         // angle = rotation + i * (2.0f * M_PI / 3.0f)
    
    // int x = cx + (int)(cosf(angle) * size * 0.8f)
    bl _cos_lut_asm         // s0 = cos(angle) from LUT
    scvtf s1, w22           // Convert size to float
    fmul s0, s0, s1         // cos(angle) * size
    adr x0, .Lconst_0_8     
    ldr s1, [x0]            // 0.8f
    fmul s0, s0, s1         // cos(angle) * size * 0.8f
    fcvtns w27, s0          // Convert to int, store in w27
    add w27, w20, w27       // x = cx + result
    
    // int y = cy + (int)(sinf(angle) * size * 0.8f)  
    // Recalculate angle since cosf modified s0
    scvtf s1, w26           // Convert i to float
    adr x0, .Lconst_2pi_3    
    ldr s2, [x0]
    fmul s1, s1, s2         // i * (2.0f * M_PI / 3.0f)
    ldr s0, [sp, #96]       // Load rotation
    fadd s0, s0, s1         // angle = rotation + i * (2.0f * M_PI / 3.0f)
    
    bl _sin_lut_asm         // s0 = sin(angle) from LUT
    scvtf s1, w22           // Convert size to float
    fmul s0, s0, s1         // sin(angle) * size
    adr x0, .Lconst_0_8
    ldr s1, [x0]            // 0.8f
    fmul s0, s0, s1         // sin(angle) * size * 0.8f
    fcvtns w28, s0          // Convert to int, store in w28
    add w28, w21, w28       // y = cy + result
    
    // Store current vertex coordinates for line drawing
    str w27, [sp, #100]     // Store current x
    str w28, [sp, #104]     // Store current y
    
    // char base_char = triangle_chars[i % char_count]
    mov w0, #5              // char_count = 5
    udiv w1, w26, w0        // w1 = i / 5
    msub w0, w1, w0, w26    // w0 = i % 5
    adr x1, .Ltriangle_chars
    ldrb w0, [x1, w0, uxtw] // Load triangle_chars[i % 5]
    
    // char glitched_char = get_glitched_shape_char(base_char, x, y, frame)
    // w0 already has base_char
    mov w1, w27             // x  
    mov w2, w28             // y
    mov w3, w25             // frame
    bl _get_glitched_shape_char
    // Result in w0 = glitched_char
    
    // draw_ascii_char(pixels, x, y, glitched_char, color, alpha)
    mov w3, w0              // glitched_char
    mov x0, x19             // pixels
    mov w1, w27             // x
    mov w2, w28             // y
    mov w4, w23             // color
    mov w5, w24             // alpha
    bl _draw_ascii_char_asm
    
    // Calculate next vertex for line drawing
    // float next_angle = rotation + ((i + 1) % 3) * 2.0f * M_PI / 3.0f
    add w0, w26, #1         // i + 1
    mov w1, #3              // 3 vertices
    udiv w2, w0, w1         // (i + 1) / 3
    msub w0, w2, w1, w0     // next_i = (i + 1) % 3
    
    scvtf s1, w0            // Convert next_i to float
    adr x1, .Lconst_2pi_3   
    ldr s2, [x1]
    fmul s1, s1, s2         // next_i * (2.0f * M_PI / 3.0f)
    ldr s0, [sp, #96]       // Load rotation
    fadd s0, s0, s1         // next_angle = rotation + next_i * (2.0f * M_PI / 3.0f)
    
    // int next_x = cx + (int)(cosf(next_angle) * size * 0.8f)
    bl _cos_lut_asm         // s0 = cos(next_angle) from LUT
    scvtf s1, w22           // Convert size to float
    fmul s0, s0, s1         // cos(next_angle) * size
    adr x1, .Lconst_0_8     
    ldr s1, [x1]            // 0.8f
    fmul s0, s0, s1         // cos(next_angle) * size * 0.8f
    fcvtns w0, s0           // Convert to int
    add w0, w20, w0         // next_x = cx + result
    str w0, [sp, #108]      // Store next_x
    
    // int next_y = cy + (int)(sinf(next_angle) * size * 0.8f)
    // Recalculate next_angle since cosf modified s0
    add w0, w26, #1         // i + 1
    mov w1, #3              // 3 vertices
    udiv w2, w0, w1         // (i + 1) / 3
    msub w0, w2, w1, w0     // next_i = (i + 1) % 3
    
    scvtf s1, w0            // Convert next_i to float
    adr x1, .Lconst_2pi_3   
    ldr s2, [x1]
    fmul s1, s1, s2         // next_i * (2.0f * M_PI / 3.0f)
    ldr s0, [sp, #96]       // Load rotation
    fadd s0, s0, s1         // next_angle
    
    bl _sin_lut_asm         // s0 = sin(next_angle) from LUT
    scvtf s1, w22           // Convert size to float
    fmul s0, s0, s1         // sin(next_angle) * size
    adr x1, .Lconst_0_8
    ldr s1, [x1]            // 0.8f
    fmul s0, s0, s1         // sin(next_angle) * size * 0.8f
    fcvtns w0, s0           // Convert to int
    add w0, w21, w0         // next_y = cy + result
    
    // Store next_y properly first
    str w0, [sp, #112]      // Store next_y
    
    // Draw line between current vertex and next vertex
    // Load coordinates into dedicated registers
    ldr w1, [sp, #100]      // curr_x
    ldr w2, [sp, #104]      // curr_y
    ldr w3, [sp, #108]      // next_x
    ldr w4, [sp, #112]      // next_y
    
    // Store these in a way that won't get corrupted
    str w1, [sp, #116]      // Store curr_x
    str w2, [sp, #120]      // Store curr_y  
    str w3, [sp, #124]      // Store next_x
    str w4, [sp, #128]      // Store next_y
    
    // Calculate steps = abs(next_x - curr_x) + abs(next_y - curr_y)
    sub w5, w3, w1          // next_x - curr_x
    cmp w5, #0
    cneg w5, w5, mi         // abs(next_x - curr_x)
    
    sub w6, w4, w2          // next_y - curr_y  
    cmp w6, #0
    cneg w6, w6, mi         // abs(next_y - curr_y)
    
    add w5, w5, w6          // sum of distances
    mov w6, #12
    udiv w0, w5, w6         // steps = distance / 12
    
    // Draw line points
    mov w27, #1             // step = 1 (start from 1, not 0)
    
.Ltriangle_line_loop:
    cmp w27, w0             // step < steps?
    b.ge .Ltriangle_next_vertex
    
    // Calculate t = (float)step / steps
    scvtf s0, w27           // step as float
    scvtf s1, w0            // steps as float
    fdiv s2, s0, s1         // t = step / steps
    
    // Calculate line coordinates using stored values
    // line_x = curr_x + (int)(t * (next_x - curr_x))
    ldr w1, [sp, #116]      // Reload curr_x
    ldr w3, [sp, #124]      // Reload next_x
    sub w5, w3, w1          // next_x - curr_x
    scvtf s0, w5            // (next_x - curr_x) as float
    fmul s0, s2, s0         // t * (next_x - curr_x)
    fcvtns w5, s0           // convert to int
    add w5, w1, w5          // line_x = curr_x + result
    
    // line_y = curr_y + (int)(t * (next_y - curr_y))
    ldr w2, [sp, #120]      // Reload curr_y
    ldr w4, [sp, #128]      // Reload next_y
    sub w6, w4, w2          // next_y - curr_y
    scvtf s0, w6            // (next_y - curr_y) as float
    fmul s0, s2, s0         // t * (next_y - curr_y)
    fcvtns w6, s0           // convert to int
    add w6, w2, w6          // line_y = curr_y + result
    
    // char line_char = get_glitched_shape_char('-', line_x, line_y, frame)
    mov w0, #'-'            // base character for lines
    mov w1, w5              // line_x
    mov w2, w6              // line_y  
    mov w3, w25             // frame
    bl _get_glitched_shape_char
    // Result in w0 = glitched_char
    
    // draw_ascii_char(pixels, line_x, line_y, glitched_char, color, alpha - 50)
    mov w3, w0              // glitched_char
    mov x0, x19             // pixels
    mov w1, w5              // line_x
    mov w2, w6              // line_y
    mov w4, w23             // color
    sub w5, w24, #50        // alpha - 50
    cmp w5, #0              // Ensure alpha doesn't go negative
    csel w5, w5, wzr, ge    // max(alpha - 50, 0)
    bl _draw_ascii_char_asm
    
    // Increment step
    add w27, w27, #1        // step++
    b .Ltriangle_line_loop
    
.Ltriangle_next_vertex:
    // Increment vertex index
    add w26, w26, #1        // i++
    b .Ltriangle_vertex_loop

.Ltriangle_done:
    ldp x27, x28, [sp, #80]
    ldp x25, x26, [sp, #64]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #144
    ret

// Draw ASCII diamond
// void draw_ascii_diamond(uint32_t *pixels, int cx, int cy, int size, float rotation, uint32_t color, int alpha, int frame)
// Input: x0=pixels, w1=cx, w2=cy, w3=size, s0=rotation, w4=color, w5=alpha, w6=frame
.global _draw_ascii_diamond_asm
_draw_ascii_diamond_asm:
    stp x29, x30, [sp, #-144]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    stp x25, x26, [sp, #64]
    stp x27, x28, [sp, #80]
    
    // Check size threshold
    cmp w3, #8
    b.lt .Ldiamond_done     // return if size < 8
    
    // Save all parameters to dedicated registers
    mov x19, x0             // pixels pointer  
    mov w20, w1             // cx
    mov w21, w2             // cy  
    mov w22, w3             // size
    str s0, [sp, #96]       // rotation (on stack)
    mov w23, w4             // color
    mov w24, w5             // alpha
    mov w25, w6             // frame
    
    // Calculate diamond points (4 points: top, right, bottom, left)
    // points[4][2] = {{cx, cy-size}, {cx+size, cy}, {cx, cy+size}, {cx-size, cy}}
    mov w0, w20             // cx
    sub w1, w21, w22        // cy - size
    stp w0, w1, [sp, #104]  // Store point 0: top
    
    add w0, w20, w22        // cx + size  
    mov w1, w21             // cy
    stp w0, w1, [sp, #112]  // Store point 1: right
    
    mov w0, w20             // cx
    add w1, w21, w22        // cy + size  
    stp w0, w1, [sp, #120]  // Store point 2: bottom
    
    sub w0, w20, w22        // cx - size
    mov w1, w21             // cy
    stp w0, w1, [sp, #128]  // Store point 3: left
    
    // Apply rotation to points and draw them
    mov w26, #0             // i = 0 (point index)
    
.Ldiamond_point_loop:
    cmp w26, #4
    b.ge .Ldiamond_edges    // Done with points, now draw edges
    
    // Load point coordinates
    mov w0, #8              // 8 bytes per point (2 ints)
    mul w0, w26, w0         // i * 8
    add w0, w0, #104        // offset to points array
    add x1, sp, w0, uxtw    // address of points[i]
    ldp w27, w28, [x1]      // Load points[i][0], points[i][1]
    
    // Calculate dx = points[i][0] - cx, dy = points[i][1] - cy
    sub w0, w27, w20        // dx = points[i][0] - cx
    sub w1, w28, w21        // dy = points[i][1] - cy
    scvtf s0, w0            // dx as float
    scvtf s1, w1            // dy as float
    
    // Rotate: rotated_x = dx * cos(rotation) - dy * sin(rotation)
    //         rotated_y = dx * sin(rotation) + dy * cos(rotation)
    ldr s2, [sp, #96]       // Load rotation
    
    // Calculate cos(rotation)
    fmov s3, s2             // Copy rotation for cos call
    bl _cos_lut_asm         // s0 = cos(rotation) from LUT
    fmov s4, s0             // Save cos result in s4
    
    // Calculate sin(rotation)  
    ldr s2, [sp, #96]       // Reload rotation
    fmov s0, s2             // Set up for sin call
    bl _sin_lut_asm         // s0 = sin(rotation) from LUT
    fmov s5, s0             // Save sin result in s5
    
    // Reload dx, dy
    sub w0, w27, w20        // dx = points[i][0] - cx
    sub w1, w28, w21        // dy = points[i][1] - cy  
    scvtf s0, w0            // dx as float
    scvtf s1, w1            // dy as float
    
    // Now compute rotated coordinates
    fmul s6, s0, s4         // dx * cos(rotation)
    fmul s7, s1, s5         // dy * sin(rotation)
    fsub s6, s6, s7         // rotated_x = dx * cos - dy * sin
    
    fmul s7, s0, s5         // dx * sin(rotation)
    fmul s8, s1, s4         // dy * cos(rotation)
    fadd s7, s7, s8         // rotated_y = dx * sin + dy * cos
    
    // Convert back to integers and add center
    fcvtns w0, s6           // rotated_x as int
    fcvtns w1, s7           // rotated_y as int
    add w27, w20, w0        // final_x = cx + rotated_x
    add w28, w21, w1        // final_y = cy + rotated_y
    
    // Store rotated point back
    mov w0, #8              // 8 bytes per point
    mul w0, w26, w0         // i * 8
    add w0, w0, #104        // offset to points array
    add x1, sp, w0, uxtw    // address of points[i]
    stp w27, w28, [x1]      // Store rotated coordinates
    
    // Get character: base_char = diamond_chars[i % char_count]
    mov w0, #5              // char_count = 5
    udiv w1, w26, w0        // w1 = i / 5
    msub w0, w1, w0, w26    // w0 = i % 5
    adr x1, .Ldiamond_chars
    ldrb w0, [x1, w0, uxtw] // Load diamond_chars[i % 5]
    
    // char glitched_char = get_glitched_shape_char(base_char, x, y, frame)
    // w0 already has base_char
    mov w1, w27             // x  
    mov w2, w28             // y
    mov w3, w25             // frame
    bl _get_glitched_shape_char
    // Result in w0 = glitched_char
    
    // draw_ascii_char(pixels, x, y, glitched_char, color, alpha)
    mov w3, w0              // glitched_char
    mov x0, x19             // pixels
    mov w1, w27             // x
    mov w2, w28             // y
    mov w4, w23             // color
    mov w5, w24             // alpha
    bl _draw_ascii_char_asm
    
    // Increment point index
    add w26, w26, #1        // i++
    b .Ldiamond_point_loop
    
.Ldiamond_edges:
    // Draw diamond edges connecting points
    mov w26, #0             // i = 0 (edge index)
    
.Ldiamond_edge_loop:
    cmp w26, #4
    b.ge .Ldiamond_done     // Done with all edges
    
    // Calculate next point index: next = (i + 1) % 4
    add w0, w26, #1         // i + 1
    mov w1, #4              // 4 points
    udiv w2, w0, w1         // (i + 1) / 4
    msub w27, w2, w1, w0    // next = (i + 1) % 4
    
    // Load current point coordinates
    mov w0, #8              // 8 bytes per point
    mul w0, w26, w0         // i * 8
    add w0, w0, #104        // offset to points array
    add x1, sp, w0, uxtw    // address of points[i]
    ldp w1, w2, [x1]        // Load points[i][0], points[i][1]
    
    // Load next point coordinates  
    mov w0, #8              // 8 bytes per point
    mul w0, w27, w0         // next * 8
    add w0, w0, #104        // offset to points array
    add x3, sp, w0, uxtw    // address of points[next]
    ldp w3, w4, [x3]        // Load points[next][0], points[next][1]
    
    // Calculate steps = (abs(next_x - curr_x) + abs(next_y - curr_y)) / 12
    sub w5, w3, w1          // next_x - curr_x
    cmp w5, #0
    cneg w5, w5, mi         // abs(next_x - curr_x)
    
    sub w6, w4, w2          // next_y - curr_y  
    cmp w6, #0
    cneg w6, w6, mi         // abs(next_y - curr_y)
    
    add w5, w5, w6          // sum of distances
    mov w6, #12
    udiv w28, w5, w6        // steps = distance / 12
    
    // Save point coordinates for edge drawing
    str w1, [sp, #136]      // curr_x
    str w2, [sp, #140]      // curr_y
    str w3, [sp, #144]      // next_x (note: using unused stack space)
    str w4, [sp, #148]      // next_y
    
    // Draw line between points
    mov w27, #1             // step = 1 (start from 1, not 0)
    
.Ldiamond_line_loop:
    cmp w27, w28            // step < steps?
    b.ge .Ldiamond_next_edge
    
    // Calculate t = (float)step / steps
    scvtf s0, w27           // step as float
    scvtf s1, w28           // steps as float
    fdiv s2, s0, s1         // t = step / steps
    
    // Calculate line coordinates
    // line_x = curr_x + (int)(t * (next_x - curr_x))
    ldr w0, [sp, #136]      // curr_x
    ldr w1, [sp, #144]      // next_x
    sub w1, w1, w0          // next_x - curr_x
    scvtf s0, w1            // (next_x - curr_x) as float
    fmul s0, s2, s0         // t * (next_x - curr_x)
    fcvtns w1, s0           // convert to int
    add w1, w0, w1          // line_x = curr_x + result
    
    // line_y = curr_y + (int)(t * (next_y - curr_y))
    ldr w0, [sp, #140]      // curr_y
    ldr w2, [sp, #148]      // next_y
    sub w2, w2, w0          // next_y - curr_y
    scvtf s0, w2            // (next_y - curr_y) as float
    fmul s0, s2, s0         // t * (next_y - curr_y)
    fcvtns w2, s0           // convert to int
    add w2, w0, w2          // line_y = curr_y + result
    
    // char line_char = get_glitched_shape_char('=', line_x, line_y, frame)
    mov w0, #'='            // base character for diamond lines
    // w1 already has line_x
    // w2 already has line_y  
    mov w3, w25             // frame
    bl _get_glitched_shape_char
    // Result in w0 = glitched_char
    
    // draw_ascii_char(pixels, line_x, line_y, glitched_char, color, alpha - 50)
    mov w3, w0              // glitched_char
    mov x0, x19             // pixels
    // w1 already has line_x
    // w2 already has line_y
    mov w4, w23             // color
    sub w5, w24, #50        // alpha - 50
    cmp w5, #0              // Ensure alpha doesn't go negative
    csel w5, w5, wzr, ge    // max(alpha - 50, 0)
    bl _draw_ascii_char_asm
    
    // Increment step
    add w27, w27, #1        // step++
    b .Ldiamond_[CHUNK 3 OF 3]
BUNDLE_5_BASS_HITS - PART 3
Concatenate all chunks in order to reconstruct.

line_loop
    
.Ldiamond_next_edge:
    // Increment edge index
    add w26, w26, #1        // i++
    b .Ldiamond_edge_loop
    
.Ldiamond_done:
    ldp x27, x28, [sp, #80]
    ldp x25, x26, [sp, #64]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #144
    ret

// Draw ASCII star
// void draw_ascii_star(uint32_t *pixels, int cx, int cy, int size, float rotation, uint32_t color, int alpha, int frame)
// Input: x0=pixels, w1=cx, w2=cy, w3=size, s0=rotation, w4=color, w5=alpha, w6=frame
.global _draw_ascii_star_asm
_draw_ascii_star_asm:
    stp x29, x30, [sp, #-112]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    stp x25, x26, [sp, #64]
    stp x27, x28, [sp, #80]
    
    // Check size threshold
    cmp w3, #8
    b.lt .Lstar_done        // return if size < 8
    
    // Save all parameters to dedicated registers
    mov x19, x0             // pixels pointer  
    mov w20, w1             // cx
    mov w21, w2             // cy  
    mov w22, w3             // size
    str s0, [sp, #96]       // rotation (on stack)
    mov w23, w4             // color
    mov w24, w5             // alpha
    mov w25, w6             // frame
    
    // Loop counter in dedicated register
    mov w26, #0             // i = 0 (point index, 0-9 for 10 points)
    
    // for (int i = 0; i < 10; i++) - 5-pointed star with inner/outer points
.Lstar_point_loop:
    cmp w26, #10
    b.ge .Lstar_done
    
    // float angle = rotation + i * M_PI / 5.0f
    scvtf s1, w26           // Convert i to float
    adr x0, .Lconst_pi_5    // M_PI / 5.0f ≈ 0.628318
    ldr s2, [x0]
    fmul s1, s1, s2         // i * (M_PI / 5.0f)
    ldr s0, [sp, #96]       // Load rotation
    fadd s0, s0, s1         // angle = rotation + i * (M_PI / 5.0f)
    
    // float radius = (i % 2 == 0) ? size * 0.8f : size * 0.4f; // Alternate between outer and inner
    mov w0, #2
    udiv w1, w26, w0        // w1 = i / 2
    msub w0, w1, w0, w26    // w0 = i % 2
    
    scvtf s1, w22           // Convert size to float
    cmp w0, #0              // i % 2 == 0?
    b.ne .Lstar_inner_radius
    
    // Outer radius: size * 0.8f
    adr x0, .Lconst_0_8     
    ldr s2, [x0]            // 0.8f
    fmul s1, s1, s2         // size * 0.8f
    b .Lstar_calc_pos
    
.Lstar_inner_radius:
    // Inner radius: size * 0.4f
    adr x0, .Lconst_0_4     
    ldr s2, [x0]            // 0.4f
    fmul s1, s1, s2         // size * 0.4f
    
.Lstar_calc_pos:
    // s1 now contains the radius
    // int x = cx + (int)(cosf(angle) * radius)
    bl _cos_lut_asm         // s0 = cos(angle) from LUT
    fmul s0, s0, s1         // cos(angle) * radius
    fcvtns w27, s0          // Convert to int, store in w27
    add w27, w20, w27       // x = cx + result
    
    // int y = cy + (int)(sinf(angle) * radius)  
    // Recalculate angle since cosf modified s0
    scvtf s1, w26           // Convert i to float
    adr x0, .Lconst_pi_5    
    ldr s2, [x0]
    fmul s1, s1, s2         // i * (M_PI / 5.0f)
    ldr s0, [sp, #96]       // Load rotation
    fadd s0, s0, s1         // angle = rotation + i * (M_PI / 5.0f)
    
    // Recalculate radius
    mov w0, #2
    udiv w1, w26, w0        // w1 = i / 2
    msub w0, w1, w0, w26    // w0 = i % 2
    
    scvtf s1, w22           // Convert size to float
    cmp w0, #0              // i % 2 == 0?
    b.ne .Lstar_inner_radius2
    
    // Outer radius: size * 0.8f
    adr x0, .Lconst_0_8     
    ldr s2, [x0]            // 0.8f
    fmul s1, s1, s2         // size * 0.8f
    b .Lstar_calc_y
    
.Lstar_inner_radius2:
    // Inner radius: size * 0.4f
    adr x0, .Lconst_0_4     
    ldr s2, [x0]            // 0.4f
    fmul s1, s1, s2         // size * 0.4f
    
.Lstar_calc_y:
    bl _sin_lut_asm         // s0 = sin(angle) from LUT
    fmul s0, s0, s1         // sin(angle) * radius
    fcvtns w28, s0          // Convert to int, store in w28
    add w28, w21, w28       // y = cy + result
    
    // char base_char = star_chars[i % char_count]
    mov w0, #8              // char_count = 8
    udiv w1, w26, w0        // w1 = i / 8
    msub w0, w1, w0, w26    // w0 = i % 8
    adr x1, .Lstar_chars
    ldrb w0, [x1, w0, uxtw] // Load star_chars[i % 8]
    
    // char glitched_char = get_glitched_shape_char(base_char, x, y, frame)
    // w0 already has base_char
    mov w1, w27             // x  
    mov w2, w28             // y
    mov w3, w25             // frame
    bl _get_glitched_shape_char
    // Result in w0 = glitched_char
    
    // draw_ascii_char(pixels, x, y, glitched_char, color, alpha)
    mov w3, w0              // glitched_char
    mov x0, x19             // pixels
    mov w1, w27             // x
    mov w2, w28             // y
    mov w4, w23             // color
    mov w5, w24             // alpha
    bl _draw_ascii_char_asm
    
    // Increment loop counter
    add w26, w26, #1        // i++
    b .Lstar_point_loop
    
.Lstar_done:
    ldp x27, x28, [sp, #80]
    ldp x25, x26, [sp, #64]
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #112
    ret

// Update all active bass hits
// void update_bass_hits(float elapsed_ms, float step_sec, float base_hue, uint32_t seed)
// Input: s0=elapsed_ms, s1=step_sec, s2=base_hue, w0=seed
.global _update_bass_hits_asm
_update_bass_hits_asm:
    stp x29, x30, [sp, #-96]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    str s0, [sp, #48]       // elapsed_ms
    str s1, [sp, #52]       // step_sec
    str s2, [sp, #56]       // base_hue
    str w0, [sp, #60]       // seed
    
    // Check if initialized
    adrp x0, bass_hits_initialized@PAGE
    add x0, x0, bass_hits_initialized@PAGEOFF
    ldrb w1, [x0]
    cmp w1, #0
    b.eq .Lupdate_done      // Return if not initialized
    
    // Calculate current step: (int)(elapsed_ms / 1000.0f / step_sec) % 32
    ldr s0, [sp, #48]       // elapsed_ms
    adr x0, .Lconst_1000
    ldr s1, [x0]            // 1000.0f
    fdiv s0, s0, s1         // elapsed_ms / 1000.0f
    ldr s1, [sp, #52]       // step_sec
    fdiv s0, s0, s1         // elapsed_ms / 1000.0f / step_sec
    fcvtzs w19, s0          // Convert to int
    mov w0, #32
    udiv w1, w19, w0        // current_step / 32
    msub w19, w1, w0, w19   // current_step = current_step % 32
    
    // Check if we should spawn: current_step % (STEPS_PER_BEAT * 8) == 0
    mov w0, #32             // STEPS_PER_BEAT * 8 = 4 * 8 = 32
    udiv w1, w19, w0        // current_step / 32
    msub w0, w1, w0, w19    // current_step % 32
    cmp w0, #0
    b.ne .Lupdate_check_hits // Skip spawn if not on beat
    
    // Check if different from last step
    adrp x0, last_bass_step@PAGE
    add x0, x0, last_bass_step@PAGEOFF
    ldr w1, [x0]
    cmp w19, w1
    b.eq .Lupdate_check_hits // Skip if same step
    
    // Update last step and spawn
    str w19, [x0]           // last_bass_step = current_step
    
    // Call spawn_bass_hit(base_hue, seed + current_step)
    ldr s0, [sp, #56]       // base_hue
    ldr w1, [sp, #60]       // seed
    add w0, w1, w19         // seed + current_step
    bl _spawn_bass_hit_asm
    
.Lupdate_check_hits:
    // Update all active bass hits
    adrp x19, bass_hits_array@PAGE
    add x19, x19, bass_hits_array@PAGEOFF
    mov w20, #0             // i = 0
    
.Lupdate_hit_loop:
    cmp w20, #16            // MAX_BASS_HITS = 16
    b.ge .Lupdate_done
    
    // Get pointer to bass_hits[i]
    mov w0, #32             // sizeof(bass_hit_t) = 32
    mul w1, w20, w0         // i * 32
    add x21, x19, w1, uxtw  // hit = &bass_hits[i]
    
    // Check if active: if (!hit->active) continue
    ldr w0, [x21, #28]      // Load active flag (offset 28)
    cmp w0, #0
    b.eq .Lupdate_next_hit  // Skip if not active
    
    // Update scale: if (hit->scale < 1.0f) hit->scale += 0.15f
    ldr s0, [x21, #12]      // Load scale (offset 12)
    adr x0, .Lconst_1_0
    ldr s1, [x0]            // 1.0f
    fcmp s0, s1
    b.ge .Lupdate_scale_done
    
    adr x0, .Lconst_0_15
    ldr s1, [x0]            // 0.15f
    fadd s0, s0, s1         // scale += 0.15f
    str s0, [x21, #12]      // Store updated scale
    
.Lupdate_scale_done:
    // Update alpha: hit->alpha = hit->alpha > 8 ? hit->alpha - 8 : 0
    ldr w0, [x21, #8]       // Load alpha (offset 8)
    cmp w0, #8
    b.le .Lupdate_alpha_zero
    
    sub w0, w0, #8          // alpha - 8
    b .Lupdate_alpha_store
    
.Lupdate_alpha_zero:
    mov w0, #0              // alpha = 0
    
.Lupdate_alpha_store:
    str w0, [x21, #8]       // Store updated alpha
    
    // Update rotation: hit->rotation += hit->rot_speed
    ldr s0, [x21, #20]      // Load rotation (offset 20)
    ldr s1, [x21, #24]      // Load rot_speed (offset 24)
    fadd s0, s0, s1         // rotation += rot_speed
    str s0, [x21, #20]      // Store updated rotation
    
    // Check if should deactivate: if (hit->alpha <= 0) hit->active = false
    ldr w0, [x21, #8]       // Load alpha
    cmp w0, #0
    b.gt .Lupdate_next_hit
    
    mov w0, #0              // false
    str w0, [x21, #28]      // hit->active = false
    
.Lupdate_next_hit:
    add w20, w20, #1        // i++
    b .Lupdate_hit_loop
    
.Lupdate_done:
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #96
    ret

// Draw all active bass hits
// void draw_bass_hits(uint32_t *pixels, int frame)
// Input: x0=pixels, w1=frame
.global _draw_bass_hits_asm
_draw_bass_hits_asm:
    stp x29, x30, [sp, #-96]!
    mov x29, sp
    stp x19, x20, [sp, #16]
    stp x21, x22, [sp, #32]
    stp x23, x24, [sp, #48]
    mov x19, x0             // pixels
    mov w20, w1             // frame
    
    // Check if initialized
    adrp x0, bass_hits_initialized@PAGE
    add x0, x0, bass_hits_initialized@PAGEOFF
    ldrb w1, [x0]
    cmp w1, #0
    b.eq .Ldraw_done        // Return if not initialized
    
    // Calculate center: cx = VIS_WIDTH / 2, cy = VIS_HEIGHT / 2
    mov w21, #400           // cx = 800 / 2 = 400
    mov w22, #300           // cy = 600 / 2 = 300
    
    // Get bass hits array pointer
    adrp x23, bass_hits_array@PAGE
    add x23, x23, bass_hits_array@PAGEOFF
    mov w24, #0             // i = 0
    
.Ldraw_hit_loop:
    cmp w24, #16            // MAX_BASS_HITS = 16
    b.ge .Ldraw_done
    
    // Get pointer to bass_hits[i]
    mov w0, #32             // sizeof(bass_hit_t) = 32
    mul w1, w24, w0         // i * 32
    add x0, x23, w1, uxtw   // hit = &bass_hits[i]
    
    // Check if active and visible: if (!hit->active || hit->alpha <= 0) continue
    ldr w1, [x0, #28]       // Load active flag
    cmp w1, #0
    b.eq .Ldraw_next_hit    // Skip if not active
    
    ldr w1, [x0, #8]        // Load alpha
    cmp w1, #0
    b.le .Ldraw_next_hit    // Skip if alpha <= 0
    
    // Calculate size: int size = (int)(hit->max_size * fminf(hit->scale, 1.0f))
    ldr s0, [x0, #16]       // Load max_size (offset 16)
    ldr s1, [x0, #12]       // Load scale (offset 12)
    adr x1, .Lconst_1_0
    ldr s2, [x1]            // 1.0f
    fcmp s1, s2
    fcsel s1, s1, s2, le    // s1 = fminf(scale, 1.0f)
    fmul s0, s0, s1         // max_size * scale
    fcvtzs w2, s0           // Convert to int size
    
    // Get color: uint32_t color = color_to_pixel(hit->color)
    add x1, x0, #4          // pointer to hit->color (offset 4)
    stp x0, x1, [sp, #64]   // Save hit pointer and color pointer
    str w2, [sp, #72]       // Save size
    mov x0, x1              // color pointer
    bl _color_to_pixel
    mov w3, w0              // color result
    ldp x0, x1, [sp, #64]   // Restore pointers
    ldr w2, [sp, #72]       // Restore size
    
    // Get other parameters
    ldr w4, [x0, #8]        // alpha
    ldr s0, [x0, #20]       // rotation
    ldr w5, [x0]            // shape_type
    
    // Set up function call parameters in correct order
    mov x0, x19             // pixels
    mov w1, w21             // cx  
    mov w2, w22             // cy
    // Move parameters to correct registers (do in reverse order to avoid overwriting)
    mov w5, w4              // alpha (w4 -> w5)
    mov w4, w3              // color (w3 -> w4)  
    mov w3, w2              // size (w2 -> w3)
    // s0 already has rotation  
    mov w6, w20             // frame
    
    // Call appropriate shape function based on shape_type
    cmp w5, #0              // BASS_TRIANGLE = 0
    b.eq .Ldraw_triangle
    cmp w5, #1              // BASS_DIAMOND = 1
    b.eq .Ldraw_diamond
    cmp w5, #2              // BASS_HEXAGON = 2
    b.eq .Ldraw_hexagon
    cmp w5, #3              // BASS_STAR = 3
    b.eq .Ldraw_star
    cmp w5, #4              // BASS_SQUARE = 4
    b.eq .Ldraw_square
    b .Ldraw_next_hit       // Unknown shape type
    
.Ldraw_triangle:
    bl _draw_ascii_triangle_asm
    b .Ldraw_next_hit
    
.Ldraw_diamond:
    bl _draw_ascii_diamond_asm
    b .Ldraw_next_hit
    
.Ldraw_hexagon:
    bl _draw_ascii_hexagon_asm
    b .Ldraw_next_hit
    
.Ldraw_star:
    bl _draw_ascii_star_asm
    b .Ldraw_next_hit
    
.Ldraw_square:
    bl _draw_ascii_square_asm
    b .Ldraw_next_hit
    
.Ldraw_next_hit:
    add w24, w24, #1        // i++
    b .Ldraw_hit_loop
    
.Ldraw_done:
    ldp x23, x24, [sp, #48]
    ldp x21, x22, [sp, #32]
    ldp x19, x20, [sp, #16]
    ldp x29, x30, [sp], #96
    ret

// All character arrays and constants
.align 1
.Lhex_chars:
    .byte 'O', '0', '#', '*', '+', 'X'

.Lsquare_chars:
    .byte '#', '=', '+', 'H', 'M', 'W'

.Ltriangle_chars:
    .byte '^', 'A', '/', '\\', '-'

.Ldiamond_chars:
    .byte '<', '>', '^', 'v', '*'

.Lstar_chars:
    .byte '*', '+', 'x', 'X', '^', 'v', '<', '>'

// All floating point constants
.align 4
.Lconst_pi_3:
    .float 1.047198         // M_PI / 3.0f
.Lconst_0_7:
    .float 0.7
.Lconst_2pi_3:
    .float 2.094395         // 2.0f * M_PI / 3.0f
.Lconst_0_8:
    .float 0.8
.Lconst_pi_5:
    .float 0.628318         // M_PI / 5.0f
.Lconst_0_15:
    .float 0.15
.Lconst_1000:
    .float 1000.0

---END---

[CHUNK 1 OF 3]
BUNDLE_6_C_BRIDGE - PART 1
Concatenate all chunks in order to reconstruct.

[NOTDEAFBEEF BLOCKCHAIN BUNDLE - BUNDLE_6_C_BRIDGE]
=============================================================
C bridge code and build system
Generated for on-chain storage following deafbeef methodology.

[MANIFEST]
Bundle: bundle_6_c_bridge
Total files: 4
Files included:
  - generate_frames.c (38400 bytes)
  - simple_wav_reader.c (5277 bytes)
  - generate_nft.sh (6255 bytes)
  - Makefile (3429 bytes)

Reconstruction: Save each file to its path and build with provided instructions.

=== FILE: generate_frames.c ===
---BEGIN---
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>
#include <ctype.h>
#include "src/include/visual_types.h"
#include "src/include/deterministic_prng.h"

// Deterministically hash a transaction hash to a 32-bit seed
// Preserves deafbeef-style reproducibility while handling long hashes
uint32_t hash_transaction_to_seed(const char* tx_hash) {
    uint32_t seed = 0;
    const char* hex_start = tx_hash;
    
    // Skip "0x" prefix if present
    if (tx_hash[0] == '0' && (tx_hash[1] == 'x' || tx_hash[1] == 'X')) {
        hex_start += 2;
    }
    
    size_t len = strlen(hex_start);
    
    // XOR all 8-character chunks together for good distribution
    for (int i = 0; i < len; i += 8) {
        char chunk[9] = {0};
        int chunk_len = (len - i >= 8) ? 8 : (len - i);
        strncpy(chunk, hex_start + i, chunk_len);
        
        // Convert hex chunk to uint32_t and XOR into seed
        uint32_t chunk_val = (uint32_t)strtoul(chunk, NULL, 16);
        seed ^= chunk_val;
    }
    
    // If seed is 0, use a fallback to avoid degenerate case
    if (seed == 0) {
        seed = 0xDEADBEEF;
    }
    
    return seed;
}

// Forward declarations for ASM visual functions
extern void clear_frame_asm(uint32_t *pixels, uint32_t color);
extern void init_terrain_asm(uint32_t seed, float base_hue);
extern void draw_terrain_asm(uint32_t *pixels, int frame);
extern void draw_terrain_enhanced_asm(uint32_t *pixels, int frame, float audio_level);
// Particles removed for now
// extern void init_particles_asm(void);
// extern void update_particles_asm(float elapsed_ms, float step_sec, float base_hue);
// extern void draw_particles_asm(uint32_t *pixels);
extern void init_glitch_system_asm(uint32_t seed, float intensity);
extern void update_glitch_intensity_asm(float new_intensity);
extern void init_bass_hits_asm(void);
extern void draw_bass_hits_asm(uint32_t *pixels, int frame);
extern void update_bass_hits_asm(float elapsed_ms);
extern uint32_t circle_color_asm(float hue, float saturation, float value);
extern void draw_circle_filled_asm(uint32_t *pixels, int cx, int cy, int radius, uint32_t color);
extern void draw_ascii_char_asm(uint32_t *pixels, int x, int y, char c, uint32_t color, int bg_alpha);

// Global pixels buffer for shape drawing
static uint32_t *g_current_pixels = NULL;
void set_current_pixels(uint32_t *pixels) { g_current_pixels = pixels; }

// Workload budget system for 60 FPS stability
typedef struct {
    int max_projectiles;      // Dynamic cap on active projectiles
    int max_boss_shapes;      // Dynamic cap on boss formation complexity
    int min_firing_cooldown;  // Dynamic minimum between shots
    float complexity_factor;  // 0.0-1.0 based on audio intensity
} workload_budget_t;

static workload_budget_t g_budget = {0};

// Workload budget management
void update_workload_budget(float audio_level) {
    // AGGRESSIVE budget to maintain 60 FPS - performance over visual complexity
    
    // Drastically reduced base budgets for 60 FPS stability
    int base_projectiles = 2;  // Reduced from 8
    int base_boss_shapes = 2;  // Reduced from 5  
    int base_cooldown = 10;    // Reduced from 15
    
    // Audio intensity factor (0.0 = quiet, 1.0 = loud)
    g_budget.complexity_factor = audio_level;
    
    // Scale projectiles: 2-6 based on audio, capped at 6 for performance
    g_budget.max_projectiles = base_projectiles + (int)(audio_level * 4);
    if (g_budget.max_projectiles > 6) g_budget.max_projectiles = 6;
    
    // Scale boss complexity: 2-4 shapes max, very conservative
    g_budget.max_boss_shapes = base_boss_shapes + (int)(audio_level * 2);
    if (g_budget.max_boss_shapes > 4) g_budget.max_boss_shapes = 4;
    
    // Faster firing on loud sections, but not too fast
    g_budget.min_firing_cooldown = base_cooldown - (int)(audio_level * 6);
    if (g_budget.min_firing_cooldown < 5) g_budget.min_firing_cooldown = 5;
}

// Projectile system for ship firing
typedef struct {
    float x, y;           // Position
    float vx, vy;         // Velocity
    char character;       // ASCII character ('o', 'x', '-', '0', etc.)
    uint32_t color;       // Projectile color
    int life;             // Remaining life frames
    bool active;          // Is this projectile active?
} projectile_t;

#define MAX_PROJECTILES 32
#define VIS_WIDTH 800
#define VIS_HEIGHT 600
static projectile_t projectiles[MAX_PROJECTILES] = {0};
static int last_shot_frame = -100; // Frame when last shot was fired

// Enhanced boss shape system using all 5 ASM shapes with diversity
extern void draw_ascii_triangle_asm(uint32_t *pixels, int cx, int cy, int size, float rotation, uint32_t color, int alpha, int frame);
extern void draw_ascii_diamond_asm(uint32_t *pixels, int cx, int cy, int size, float rotation, uint32_t color, int alpha, int frame);
extern void draw_ascii_hexagon_asm(uint32_t *pixels, int cx, int cy, int size, float rotation, uint32_t color, int alpha, int frame);
extern void draw_ascii_star_asm(uint32_t *pixels, int cx, int cy, int size, float rotation, uint32_t color, int alpha, int frame);
extern void draw_ascii_square_asm(uint32_t *pixels, int cx, int cy, int size, float rotation, uint32_t color, int alpha, int frame);

void draw_boss_shape(float cx, float cy, int shape_type, int size, float rotation, float hue, float saturation, float value, int frame) {
    if (!g_current_pixels) return; // Safety check
    
    uint32_t color = circle_color_asm(hue, saturation, value);
    int alpha = 255; // Full opacity for boss shapes
    
    // Use all 5 ASM shapes with proper parameters
    switch(shape_type) {
        case 0: // Triangle
            draw_ascii_triangle_asm(g_current_pixels, (int)cx, (int)cy, size, rotation, color, alpha, frame);
            break;
        case 1: // Diamond  
            draw_ascii_diamond_asm(g_current_pixels, (int)cx, (int)cy, size, rotation, color, alpha, frame);
            break;
        case 2: // Hexagon
            draw_ascii_hexagon_asm(g_current_pixels, (int)cx, (int)cy, size, rotation, color, alpha, frame);
            break;
        case 3: // Star
            draw_ascii_star_asm(g_current_pixels, (int)cx, (int)cy, size, rotation, color, alpha, frame);
            break;
        case 4: // Square
            draw_ascii_square_asm(g_current_pixels, (int)cx, (int)cy, size, rotation, color, alpha, frame);
            break;
    }
}

// Projectile system functions
void spawn_projectile(float ship_x, float ship_y, float boss_x, float boss_y, uint32_t seed) {
    // Count active projectiles first
    int active_count = 0;
    for (int i = 0; i < MAX_PROJECTILES; i++) {
        if (projectiles[i].active) active_count++;
    }
    
    // Respect workload budget - don't spawn if at cap
    if (active_count >= g_budget.max_projectiles) {
        return; // Budget exceeded, skip this projectile
    }
    
    // Find an inactive projectile slot
    for (int i = 0; i < MAX_PROJECTILES; i++) {
        if (!projectiles[i].active) {
            // Seed-based projectile type selection
            prng_seed(&g_projectile_prng, seed + i);
            char projectile_chars[] = {'o', 'x', '-', '0', '*', '+', '>', '=', '~'};
            int char_count = sizeof(projectile_chars) / sizeof(projectile_chars[0]);
            
            projectiles[i].x = ship_x + 20; // Start slightly ahead of ship
            projectiles[i].y = ship_y;
            
            // Calculate velocity towards boss
            float dx = boss_x - ship_x;
            float dy = boss_y - ship_y;
            float distance = sqrt(dx*dx + dy*dy);
            float speed = 8.0f; // Pixels per frame
            
            projectiles[i].vx = (dx / distance) * speed;
            projectiles[i].vy = (dy / distance) * speed;
            projectiles[i].character = projectile_chars[prng_range(&g_projectile_prng, char_count)];
            projectiles[i].color = circle_color_asm(0.1f + prng_range(&g_projectile_prng, 100) / 1000.0f, 1.0f, 1.0f); // Yellowish
            projectiles[i].life = 120; // 2 seconds at 60fps
            projectiles[i].active = true;
            break;
        }
    }
}

void update_projectiles(void) {
    for (int i = 0; i < MAX_PROJECTILES; i++) {
        if (projectiles[i].active) {
            // Move projectile
            projectiles[i].x += projectiles[i].vx;
            projectiles[i].y += projectiles[i].vy;
            projectiles[i].life--;
            
            // Deactivate if off screen or life expired
            if (projectiles[i].x < 0 || projectiles[i].x >= VIS_WIDTH ||
                projectiles[i].y < 0 || projectiles[i].y >= VIS_HEIGHT ||
                projectiles[i].life <= 0) {
                projectiles[i].active = false;
            }
        }
    }
}

void draw_projectiles(void) {
    if (!g_current_pixels) return;
    
    for (int i = 0; i < MAX_PROJECTILES; i++) {
        if (projectiles[i].active) {
            draw_ascii_char_asm(g_current_pixels, 
                (int)projectiles[i].x, (int)projectiles[i].y,
                projectiles[i].character, projectiles[i].color, 255);
        }
    }
}

// Sidecar timeline reader (preferred) and audio-analysis fallback
#include "src/include/timeline.h"
void init_audio_visual_mapping(void);
float get_smoothed_audio_level(int frame);
void update_audio_visual_effects(int frame, float base_hue);
float get_audio_driven_glitch_intensity(int frame);
float get_audio_driven_hue_shift(int frame);

// Audio functions
bool load_wav_file(const char *filename);
float get_audio_rms_for_frame(int frame);
float get_audio_bpm(void);
float get_max_rms(void);
float get_audio_duration(void); // Get actual audio duration in seconds
bool is_audio_finished(int frame);
void print_audio_info(void);
void cleanup_audio_data(void);

#define FRAME_TIME_MS (1000 / VIS_FPS)

// PPM image output helpers
static inline void write_frame_ppm(FILE *out, uint32_t *pixels) {
    // Each frame carries its own header (PPM P6) for ffmpeg image2pipe
    fprintf(out, "P6\n%d %d\n255\n", VIS_WIDTH, VIS_HEIGHT);
    for (int y = 0; y < VIS_HEIGHT; y++) {
        for (int x = 0; x < VIS_WIDTH; x++) {
            uint32_t pixel = pixels[y * VIS_WIDTH + x];
            uint8_t r = (pixel >> 16) & 0xFF;
            uint8_t g = (pixel >> 8) & 0xFF;
            uint8_t b = pixel & 0xFF;
            fwrite(&r, 1, 1, out);
            fwrite(&g, 1, 1, out);
            fwrite(&b, 1, 1, out);
        }
    }
    fflush(out);
}

void save_frame_as_ppm(uint32_t *pixels, int frame_num) {
    char filename[256];
    snprintf(filename, sizeof(filename), "frame_%04d.ppm", frame_num);
    FILE *f = fopen(filename, "wb");
    if (!f) { fprintf(stderr, "Could not create %s\n", filename); return; }
    write_frame_ppm(f, pixels);
    fclose(f);
    fprintf(stderr, "✅ Generated frame_%04d.ppm\n", frame_num);
}

// Custom top terrain drawing function
void draw_top_terrain(uint32_t *pixels, int frame, float hue, float audio_level) {
    // Simple procedural top terrain using different algorithm
    const int char_width = 8; // Use proper 8x12 glyph spacing
    const int char_height = 12;
    const char terrain_chars[] = "^^^^====~~~~----____";
    const int num_chars = 20;
    const int char_alpha = 255; // Fully opaque - this was the bug!
    
    // Create brighter color based on hue
    uint32_t color = circle_color_asm(hue, 1.0f, 1.0f); // Full brightness and saturation
    
    // Generate terrain from top down - make it much more visible
    for (int x = 0; x < VIS_WIDTH; x += char_width) {
        // Use different pattern than bottom terrain
        int pattern = (x / char_width + frame / 2) % num_chars;
        char c = terrain_chars[pattern];
        
        // Audio-reactive height - different response than bottom
        int height_variation = (int)(audio_level * 8) + 3; // Audio variation
        int y_offset = (int)(sin((x + frame * 3) * 0.03f) * height_variation);
        
        // Draw multiple rows for thickness, from top down
        for (int row = 0; row < 6 + height_variation; row++) {
            int y = row * char_height + y_offset + 10; // Start 10 pixels from top
            if (y >= 0 && y < VIS_HEIGHT / 2) { // Use top half
                draw_ascii_char_asm(pixels, x, y, c, color, char_alpha);
            }
        }
    }
}

// Ship component system - seed determines design
typedef struct {
    const char* nose_patterns[4];     // 4 different nose designs
    const char* body_patterns[4];     // 4 different body designs  
    const char* wing_patterns[4];     // 4 different wing designs
    const char* trail_patterns[4];    // 4 different trail designs
    int sizes[3];                     // 3 different sizes
} ship_components_t;

ship_components_t ship_parts = {
    .nose_patterns = {
        "  ^  ",  // Classic
        " /^\\ ", // Wide
        " <*> ", // Star
        " >+< "  // Cross
    },
    .body_patterns = {
        "[###]", // Block
        "<ooo>", // Circles  
        "{***}", // Stars
        "(===)" // Lines
    },
    .wing_patterns = {
        "<   >", // Simple
        "<<+>>", // Double
        "[---]", // Brackets
        "\\___/" // Curves
    },
    .trail_patterns = {
        " ~~~ ", // Waves
        " --- ", // Lines
        " *** ", // Stars
        " ... "  // Dots
    },
    .sizes = {1, 2, 3} // Size multipliers
};

// Ship flying through the terrain corridor
void draw_ship(uint32_t *pixels, int frame, float hue, float audio_level, uint32_t seed) {
    // Ship position on LEFT side of screen (leaving room for enemies)
    float base_x = VIS_WIDTH * 0.15f; // 15% from left (moved further left)
    float center_y = VIS_HEIGHT / 2.0f;
    
    // Audio-reactive movement - enhanced for bigger ship
    float sway = sin(frame * 0.05f) * 40.0f; // Side-to-side movement  
    float bob = sin(frame * 0.08f) * 30.0f;  // Up-down movement
    float audio_dodge = audio_level * 35.0f; // React to audio
    
    // Calculate final position
    int ship_x = (int)(base_x + sway + audio_dodge);
    int ship_y = (int)(center_y + bob);
    
    // Calculate boss position for targeting (using same logic as draw_enemy_boss)
    float boss_base_x = VIS_WIDTH * 0.75f;
    float boss_center_y = VIS_HEIGHT / 2.0f;
    float boss_hover = sin(frame * 0.03f) * 20.0f;
    float boss_pulse = sin(frame * 0.12f) * 15.0f;
    float boss_audio_react = audio_level * 25.0f;
    int boss_x = (int)(boss_base_x + boss_hover - boss_audio_react);
    int boss_y = (int)(boss_center_y + boss_pulse);
    
    // Ship firing logic - budget-aware firing rate
    if (frame - last_shot_frame >= g_budget.min_firing_cooldown) {
        spawn_projectile(ship_x, ship_y, boss_x, boss_y, seed + frame);
        last_shot_frame = frame;
    }
    
    // Seed-based ship design selection
    prng_seed(&g_ship_prng, seed);
    int nose_type = prng_range(&g_ship_prng, 4);
    int body_type = prng_range(&g_ship_prng, 4);
    int wing_type = prng_range(&g_ship_prng, 4); 
    int trail_type = prng_range(&g_ship_prng, 4);
    int size = ship_parts.sizes[prng_range(&g_ship_prng, 3)];
    
    // Seed-based colors - create unique palette
    float primary_hue = prng_float(&g_ship_prng);
    float secondary_hue = primary_hue + 0.3f;
    if (secondary_hue > 1.0f) secondary_hue -= 1.0f;
    
    uint32_t primary_color = circle_color_asm(primary_hue, 1.0f, 1.0f);
    uint32_t secondary_color = circle_color_asm(secondary_hue, 0.8f, 0.9f);
    
    // Selected ship components
    const char* nose = ship_parts.nose_patterns[nose_type];
    const char* body = ship_parts.body_patterns[body_type];
    const char* wings = ship_parts.wing_patterns[wing_type];
    const char* trail = ship_parts.trail_patterns[trail_type];
    
    int char_spacing = 8 * size;
    int line_spacing = 12 * size;
    
    // Draw ship layers (bigger and more detailed)
    for (int layer = 0; layer < size; layer++) {
        int offset_y = layer * 2; // Slight layer offset
        
        // Nose (top)
        for (int i = 0; i < 5; i++) {
            if (nose[i] != ' ') {
                for (int s = 0; s < size; s++) {
                    draw_ascii_char_asm(pixels, 
                        ship_x + (i-2)*char_spacing + s*4, 
                        ship_y - line_spacing*2 + offset_y, 
                        nose[i], primary_color, 255);
                }
            }
        }
        
        // Wings (upper middle)
        for (int i = 0; i < 5; i++) {
            if (wings[i] != ' ') {
                for (int s = 0; s < size; s++) {
                    draw_ascii_char_asm(pixels, 
                        ship_x + (i-2)*char_spacing + s*4, 
                        ship_y - line_spacing + offset_y, 
                        wings[i], secondary_color, 255);
                }
            }
        }
        
        // Body (center) 
        for (int i = 0; i < 5; i++) {
            if (body[i] != ' ') {
                for (int s = 0; s < size; s++) {
                    draw_ascii_char_asm(pixels, 
                        ship_x + (i-2)*char_spacing + s*4, 
                        ship_y + offset_y, 
                        body[i], primary_color, 255);
                }
            }
        }
        
        // Trail (bottom)
        for (int i = 0; i < 5; i++) {
            if (trail[i] != ' ') {
                for (int s = 0; s < size; s++) {
                    draw_ascii_char_asm(pixels, 
                        ship_x + (i-2)*char_spacing + s*4, 
                        ship_y + line_spacing + offset_y, 
                        trail[i], secondary_color, 255);
                }
            }
        }
    }
}

// Enhanced boss system with massive diversity - mix and match shapes, sizes, colors
void draw_enemy_boss(uint32_t *pixels, int frame, float hue, float audio_level, uint32_t seed) {
    // Boss position on RIGHT side of screen (75% from left)
    float base_x = VIS_WIDTH * 0.75f; // 75% from left
    float center_y = VIS_HEIGHT / 2.0f;
    
    // Audio-reactive movement - different pattern from ship
    float hover = sin(frame * 0.03f) * 20.0f; // Slower hovering movement
    float pulse = sin(frame * 0.12f) * 15.0f; // Pulsing motion
    float audio_react = audio_level * 25.0f; // React to audio differently
    
    // Calculate final position
    int boss_x = (int)(base_x + hover - audio_react); // Move left on audio hits
    int boss_y = (int)(center_y + pulse);
    
    // Seed-based boss design with MASSIVE DIVERSITY
    prng_seed(&g_boss_prng, seed + 0x1000); // Different seed offset for boss variety
    
    // 1. Random formation type (8 different formation patterns)
    int formation_type = prng_range(&g_boss_prng, 8);
    
    // 2. Budget-aware number of components (respects workload cap)
    int max_shapes = (g_budget.max_boss_shapes > 3) ? g_budget.max_boss_shapes : 3;
    int num_components = 3 + prng_range(&g_boss_prng, max_shapes - 2);
    
    // 3. Base boss hue with variety
    float boss_base_hue = hue + prng_float(&g_boss_prng); // More hue variety
    if (boss_base_hue > 1.0f) boss_base_hue -= 1.0f;
    
    // 4. Size variety (small to massive)
    int base_size = 15 + prng_range(&g_boss_prng, 25); // Size range: 15-40
    
    // 5. Rotation variety
    float base_rotation = prng_range(&g_boss_prng, 360) * M_PI / 180.0f;
    
    // Draw diverse boss formations
    switch(formation_type) {
        case 0: // Star Burst Formation - mixed shapes radiating outward
            for (int i = 0; i < num_components; i++) {
                float angle = (2.0f * M_PI * i) / num_components;
                float radius = 30 + (i * 15); // Expanding radius
                int shape = prng_range(&g_boss_prng, 5); // All 5 shapes
                int size = base_size + prng_range(&g_boss_prng, 15) - 7; // Size variety ±7
                float shape_hue = boss_base_hue + (i * 0.1f); 
                if (shape_hue > 1.0f) shape_hue -= 1.0f;
                float sat = 0.7f + prng_range(&g_boss_prng, 30) / 100.0f; // Saturation variety
                float val = 0.8f + prng_range(&g_boss_prng, 20) / 100.0f; // Brightness variety
                float rotation = base_rotation + (i * 0.3f);
                
                int x = boss_x + (int)(cos(angle) * radius);
                int y = boss_y + (int)(sin(angle) * radius);
                draw_boss_shape(x, y, shape, size, rotation, shape_hue, sat, val, frame);
            }
            break;
            
        case 1: // Cluster Formation - tight group with mixed shapes
            for (int i = 0; i < num_components; i++) {
                int shape = prng_range(&g_boss_prng, 5);
                int size = base_size + prng_range(&g_boss_prng, 10) - 5;
                float cluster_radius = 20 + prng_range(&g_boss_prng, 30);
                float angle = prng_range(&g_boss_prng, 360) * M_PI / 180.0f;
                float shape_hue = boss_base_hue + prng_range(&g_boss_prng, 30) / 100.0f;
                if (shape_hue > 1.0f) shape_hue -= 1.0f;
                float sat = 0.6f + prng_range(&g_boss_prng, 40) / 100.0f;
                float val = 0.7f + prng_range(&g_boss_prng, 30) / 100.0f;
                float rotation = base_rotation + prng_range(&g_boss_prng, 360) * M_PI / 180.0f;
                
                int x = boss_x + (int)(cos(angle) * cluster_radius);
                int y = boss_y + (int)(sin(angle) * cluster_radius);
                draw_boss_shape(x, y, shape, size, rotation, shape_hue, sat, val, frame);
            }
            break;
            
        case 2: // Wing Formation - symmetrical left/right
            int wing_shapes = num_components / 2;
            for (int i = 0; i < wing_shapes; i++) {
                int shape = prng_range(&g_boss_prng, 5);
                int size = base_size + prng_range(&g_boss_prng, 12) - 6;
                float wing_distance = 40 + (i * 20);
                float y_offset = (i - wing_shapes/2) * 25;
                float shape_hue = boss_base_hue + (i * 0.15f);
                if (shape_hue > 1.0f) shape_hue -= 1.0f;
                float sat = 0.8f + prng_range(&g_boss_prng, 20) / 100.0f;
                float val = 0.9f + prng_range(&g_boss_prng, 10) / 100.0f;
                float rotation = base_rotation + (i * 0.2f);
                
                // Left wing
                draw_boss_shape(boss_x - wing_distance, boss_y + y_offset, shape, size, rotation, shape_hue, sat, val, frame);
                // Right wing (different shape)
                int right_shape = (shape + 1 + prng_range(&g_boss_prng, 4)) % 5;
                draw_boss_shape(boss_x + wing_distance, boss_y + y_offset, right_shape, size, -rotation, shape_hue + 0.1f, sat, val, frame);
            }
            break;
            
        case 3: // Spiral Formation - shapes in rotating spiral
            for (int i = 0; i < num_components; i++) {
                float spiral_angle = (i * 0.6f) + (frame * 0.02f); // Rotating spiral
                float spiral_radius = 10 + (i * 8);
                int shape = (i + seed) % 5; // Sequential shapes
                int size = base_size + (i % 8) - 4;
                float shape_hue = boss_base_hue + (i * 0.08f);
                if (shape_hue > 1.0f) shape_hue -= 1.0f;
                float sat = 0.7f + ((i * 13) % 30) / 100.0f;
                float val = 0.8f + ((i * 17) % 20) / 100.0[CHUNK 2 OF 3]
BUNDLE_6_C_BRIDGE - PART 2
Concatenate all chunks in order to reconstruct.

f;
                float rotation = spiral_angle + base_rotation;
                
                int x = boss_x + (int)(cos(spiral_angle) * spiral_radius);
                int y = boss_y + (int)(sin(spiral_angle) * spiral_radius);
                draw_boss_shape(x, y, shape, size, rotation, shape_hue, sat, val, frame);
            }
            break;
            
        case 4: // Grid Formation - organized rectangular pattern
            int grid_size = (int)sqrt(num_components);
            for (int i = 0; i < num_components; i++) {
                int grid_x = i % grid_size;
                int grid_y = i / grid_size;
                int shape = (grid_x + grid_y + seed) % 5; // Pattern-based shapes
                int size = base_size + ((grid_x + grid_y) % 6) - 3;
                float shape_hue = boss_base_hue + ((grid_x + grid_y) * 0.12f);
                if (shape_hue > 1.0f) shape_hue -= 1.0f;
                float sat = 0.6f + ((grid_x * 7 + grid_y * 11) % 40) / 100.0f;
                float val = 0.7f + ((grid_x * 5 + grid_y * 13) % 30) / 100.0f;
                float rotation = base_rotation + (grid_x + grid_y) * 0.25f;
                
                int x = boss_x + (grid_x - grid_size/2) * 30;
                int y = boss_y + (grid_y - grid_size/2) * 30;
                draw_boss_shape(x, y, shape, size, rotation, shape_hue, sat, val, frame);
            }
            break;
            
        case 5: // Random Chaos Formation - completely random placement
            for (int i = 0; i < num_components; i++) {
                int shape = prng_range(&g_boss_prng, 5);
                int size = 10 + prng_range(&g_boss_prng, 30); // Wide size range
                float random_x = boss_x + prng_range(&g_boss_prng, 120) - 60; // ±60 pixel spread
                float random_y = boss_y + prng_range(&g_boss_prng, 120) - 60;
                float shape_hue = prng_range(&g_boss_prng, 100) / 100.0f; // Completely random hue
                float sat = 0.5f + prng_range(&g_boss_prng, 50) / 100.0f;
                float val = 0.6f + prng_range(&g_boss_prng, 40) / 100.0f;
                float rotation = prng_range(&g_boss_prng, 360) * M_PI / 180.0f;
                
                draw_boss_shape(random_x, random_y, shape, size, rotation, shape_hue, sat, val, frame);
            }
            break;
            
        case 6: // Layered Formation - concentric circles of different shapes
            int layers = 1 + (num_components / 4);
            for (int layer = 0; layer < layers; layer++) {
                int shapes_in_layer = 3 + layer * 2;
                float layer_radius = 20 + layer * 25;
                for (int i = 0; i < shapes_in_layer && layer * shapes_in_layer + i < num_components; i++) {
                    float angle = (2.0f * M_PI * i) / shapes_in_layer;
                    int shape = (layer + i) % 5;
                    int size = base_size - layer * 3; // Smaller shapes in outer layers
                    float shape_hue = boss_base_hue + layer * 0.2f + i * 0.1f;
                    if (shape_hue > 1.0f) shape_hue -= 1.0f;
                    float sat = 0.8f - layer * 0.1f;
                    float val = 0.9f - layer * 0.1f;
                    float rotation = base_rotation + layer * 0.5f + i * 0.3f;
                    
                    int x = boss_x + (int)(cos(angle) * layer_radius);
                    int y = boss_y + (int)(sin(angle) * layer_radius);
                    draw_boss_shape(x, y, shape, size, rotation, shape_hue, sat, val, frame);
                }
            }
            break;
            
        case 7: // Pulsing Formation - sizes vary with audio and frame
            for (int i = 0; i < num_components; i++) {
                float pulse_phase = (i * 0.5f) + (frame * 0.08f);
                float pulse_factor = 0.7f + 0.3f * sin(pulse_phase) + audio_level * 0.4f;
                int shape = i % 5;
                int size = (int)(base_size * pulse_factor);
                float angle = (2.0f * M_PI * i) / num_components;
                float radius = 35 + sin(frame * 0.05f + i) * 15; // Varying radius
                float shape_hue = boss_base_hue + sin(pulse_phase) * 0.2f;
                if (shape_hue > 1.0f) shape_hue -= 1.0f;
                if (shape_hue < 0.0f) shape_hue += 1.0f;
                float sat = 0.7f + audio_level * 0.3f;
                float val = 0.8f + sin(pulse_phase) * 0.2f;
                float rotation = base_rotation + pulse_phase;
                
                int x = boss_x + (int)(cos(angle) * radius);
                int y = boss_y + (int)(sin(angle) * radius);
                draw_boss_shape(x, y, shape, size, rotation, shape_hue, sat, val, frame);
            }
            break;
    }
}

int main(int argc, char *argv[]) {
    // CLI: <audio.wav> [seed_hex] [max_frames] [--pipe-ppm] [--range start end]
    bool pipe_ppm = false;
    int range_start = -1, range_end = -1;
    
    if (argc < 2 || argc > 8) {
        printf("🎬 NotDeafBeef Frame Generator\n");
        printf("Usage: %s <audio_file.wav> [seed_hex] [max_frames] [--pipe-ppm] [--range start end]\n", argv[0]);
        printf("Example: %s audio.wav 0xDEADBEEF\n", argv[0]);
        printf("Example: %s audio.wav 0xDEADBEEF 24 --pipe-ppm  # Stream frames to stdout\n", argv[0]);
        printf("Example: %s audio.wav 0xDEADBEEF 0 --range 100 200  # Render frames 100-199\n", argv[0]);
        return 1;
    }
    
    // Parse flags and options
    int arg_idx = argc - 1;
    while (arg_idx >= 2) {
        if (strcmp(argv[arg_idx], "--pipe-ppm") == 0) {
            pipe_ppm = true;
            argc--;
            arg_idx--;
        } else if (strcmp(argv[arg_idx], "--range") == 0 && arg_idx >= 3) {
            // --range start end
            range_end = atoi(argv[arg_idx + 1]);
            range_start = atoi(argv[arg_idx]);
            argc -= 3; // Remove --range start end
            arg_idx -= 3;
        } else {
            break;
        }
    }

    printf("🎨 Generating visual frames from audio: %s\n", argv[1]);
    
    // Load audio file
    if (!load_wav_file(argv[1])) {
        fprintf(stderr, "❌ Failed to load audio file: %s\n", argv[1]);
        return 1;
    }
    
    print_audio_info();
    
    // Initialize audio-visual mapping
    init_audio_visual_mapping();
    
    // Initialize visual systems with seed from audio
    uint32_t seed = 0xCAFEBABE; // Could be derived from audio file hash  
    
    // For testing: allow command line seed override
    if (argc >= 3) {
        // OPTIMIZATION: Hash long transaction hashes to 32-bit seeds
        seed = hash_transaction_to_seed(argv[2]);
        printf("🎲 Using hashed seed: 0x%08X (from %s)\n", seed, argv[2]);
    }
    
    // Initialize PRNG streams
    init_visual_prng_streams(seed);
    
    // Allocate pixel buffer
    uint32_t *pixels = calloc(VIS_WIDTH * VIS_HEIGHT, sizeof(uint32_t));
    if (!pixels) {
        fprintf(stderr, "❌ Failed to allocate pixel buffer\n");
        return 1;
    }
    
    printf("🚀 Initializing visual systems...\n");
    
    float base_hue = 0.5f;

    // Prefer timeline sidecar if present (<audio>.json) to drive visuals deterministically
    timeline_t tl = {0};
    char sidecar_path[512];
    snprintf(sidecar_path, sizeof(sidecar_path), "%s.json", argv[1]);
    bool have_timeline = timeline_load(sidecar_path, &tl);
    if (have_timeline) {
        printf("🧭 Using timeline sidecar: %s\n", sidecar_path);
    } else {
        printf("ℹ️  No timeline sidecar found (%s). Falling back to WAV analysis.\n", sidecar_path);
    }
    
    init_terrain_asm(seed, base_hue);
    // init_particles_asm(); // Removed for now
    init_glitch_system_asm(seed, 0.5f);
    init_bass_hits_asm();
    
    // Initialize second terrain system for top with different color
    uint32_t top_seed = seed ^ 0x12345678; // Different seed for variation
    float top_hue = base_hue + 0.3f; // Shift hue for different color
    if (top_hue > 1.0f) top_hue -= 1.0f; // Wrap around
    // We'll call init_terrain_asm again but we need a way to have two terrains
    
    printf("🎬 Generating frames at 60 FPS...\n");
    
    int frame = 0;
    int total_frames = 0;
    
    // Calculate total frames needed (audio duration * FPS)
    // Get actual audio duration from loaded WAV file instead of hardcoded 5.0s
    float audio_duration = get_audio_duration(); // Use actual audio duration
    total_frames = (int)(audio_duration * VIS_FPS);
    
    // Allow frame limit override for quick testing
    if (argc == 4) {
        int max_frames = atoi(argv[3]);
        if (max_frames > 0 && max_frames < total_frames) {
            total_frames = max_frames;
            fprintf(pipe_ppm ? stderr : stdout, "🎯 Limiting to %d frames for quick test\n", total_frames);
        }
    }
    
    // Apply range filtering if specified
    int start_frame = 0;
    int end_frame = total_frames;
    if (range_start >= 0 && range_end >= 0) {
        if (range_start >= total_frames || range_end <= range_start) {
            fprintf(stderr, "❌ Invalid range: %d-%d (total frames: %d)\n", range_start, range_end, total_frames);
            return 1;
        }
        start_frame = range_start;
        end_frame = (range_end > total_frames) ? total_frames : range_end;
        fprintf(pipe_ppm ? stderr : stdout, "🎯 Rendering slice: frames %d-%d\n", start_frame, end_frame-1);
    }
    
    fprintf(pipe_ppm ? stderr : stdout,
            "📽️  Total frames to generate: %d (%.1f seconds at %d FPS)\n",
            end_frame - start_frame, audio_duration, VIS_FPS);
    
    frame = start_frame; // Start from specified frame
    while (frame < end_frame && !is_audio_finished(frame)) {
        // Clear frame
        clear_frame_asm(pixels, 0x000000); // Black background
        
        // Set current pixels for shape drawing functions
        set_current_pixels(pixels);
        
        // Get audio-driven parameters (from sidecar if available)
        float audio_hue = have_timeline ? timeline_compute_hue(&tl, frame, VIS_FPS)
                                        : get_audio_driven_hue_shift(frame);
        float audio_level = have_timeline ? timeline_compute_level(&tl, frame, VIS_FPS)
                                          : get_smoothed_audio_level(frame);
        float glitch_intensity = have_timeline ? timeline_compute_glitch(&tl, frame, VIS_FPS)
                                               : get_audio_driven_glitch_intensity(frame);
        
        // Update workload budget based on current audio intensity
        update_workload_budget(audio_level);
        
        // Update audio-visual effects
        update_audio_visual_effects(frame, audio_hue);
        
        // Update glitch intensity
        update_glitch_intensity_asm(glitch_intensity);
        
        // Focus on terrain systems
        
        // Calculate different audio responses for each terrain
        float bottom_speed_multiplier = 1.0f + audio_level * 3.0f; // 1x to 4x speed
        float top_hue = audio_hue + 0.3f; // Different hue for top terrain
        if (top_hue > 1.0f) top_hue -= 1.0f;
        
        // Draw bottom terrain (enhanced system) - moderate speed with dynamic colors
        int bottom_frame = (int)(frame * bottom_speed_multiplier);
        draw_terrain_enhanced_asm(pixels, bottom_frame, audio_level);
        
        // Draw top terrain (new system) - different pattern and color
        draw_top_terrain(pixels, frame, top_hue, audio_level);
        
        // Update bass hits animation (needed for proper rendering)
        float elapsed_ms = frame * FRAME_TIME_MS;
        update_bass_hits_asm(elapsed_ms);
        
        // Budget-aware visual rendering - skip expensive elements on heavy frames
        if (g_budget.complexity_factor < 0.8f) {  // Only render complex elements when audio is not too intense
            // Draw ship flying through the corridor (pass seed for unique design)
            draw_ship(pixels, frame, audio_hue, audio_level, seed);
            
            // Draw enemy boss on the right side
            draw_enemy_boss(pixels, frame, audio_hue, audio_level, seed);
            
            // Update and draw projectiles (ship firing at boss)
            update_projectiles();
            draw_projectiles();
        } else {
            // High intensity - only update projectiles, don't render ship/boss
            update_projectiles();
            draw_projectiles();
        }
        
        // Draw the bass hits (this renders the ship and any other shapes)
        draw_bass_hits_asm(pixels, frame);
        
        // Output frame (with slice-aware naming)
        if (pipe_ppm) {
            write_frame_ppm(stdout, pixels);
        } else {
            // Include range info in filename for parallel slice rendering
            if (range_start >= 0 && range_end >= 0) {
                char filename[256];
                snprintf(filename, sizeof(filename), "frame_%04d_slice_%d_%d.ppm", frame, range_start, range_end-1);
                FILE *f = fopen(filename, "wb");
                if (!f) { fprintf(stderr, "Could not create %s\n", filename); return 1; }
                write_frame_ppm(f, pixels);
                fclose(f);
                fprintf(stderr, "✅ Generated %s\n", filename);
            } else {
                save_frame_as_ppm(pixels, frame);
            }
        }
        
        // Progress indicator
        if (!pipe_ppm && frame % 30 == 0) {
            printf("🎬 Frame %d/%d (%.1f%% complete)\n",
                   frame, end_frame, ((frame - start_frame) * 100.0f) / (end_frame - start_frame));
        } else if (pipe_ppm && frame % 120 == 0) {
            fprintf(stderr, "🎬 Frame %d/%d (%.1f%%)\n",
                    frame, end_frame, ((frame - start_frame) * 100.0f) / (end_frame - start_frame));
        }
        
        frame++;
    }
    
    if (!pipe_ppm) {
        printf("🎉 Frame generation complete! Generated %d frames\n", frame - start_frame);
        if (range_start >= 0 && range_end >= 0) {
            printf("📽️  Slice complete: frames %d-%d\n", range_start, range_end-1);
            printf("📽️  To merge slices: use parallel_render_coordinator.sh\n");
        } else {
            printf("📽️  To create video: ffmpeg -r 60 -i frame_%%04d.ppm -c:v libx264 -pix_fmt yuv420p output.mp4\n");
        }
    } else {
        fprintf(stderr, "🎉 Frame piping complete! Sent %d frames to stdout.\n", frame - start_frame);
        fprintf(stderr, "💡 Example: ./generate_frames audio.wav 0xSEED --pipe-ppm | ffmpeg -r 60 -f image2pipe -vcodec ppm -i - -i audio.wav -c:v libx264 -pix_fmt yuv420p -shortest output.mp4\n");
    }
    
    // Cleanup
    free(pixels);
    cleanup_audio_data();
    if (have_timeline) timeline_free(&tl);
    
    return 0;
}




---END---

=== FILE: simple_wav_reader.c ===
---BEGIN---
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

// WAV file header structure
typedef struct {
    char riff[4];           // "RIFF"
    uint32_t chunk_size;    // File size - 8
    char wave[4];           // "WAVE"
    char fmt[4];            // "fmt "
    uint32_t fmt_size;      // Format chunk size
    uint16_t audio_format;  // Audio format (1 = PCM)
    uint16_t num_channels;  // Number of channels
    uint32_t sample_rate;   // Sample rate
    uint32_t byte_rate;     // Byte rate
    uint16_t block_align;   // Block align
    uint16_t bits_per_sample; // Bits per sample
    char data[4];           // "data"
    uint32_t data_size;     // Data size
} wav_header_t;

// Audio analysis data
typedef struct {
    int16_t *samples;       // Raw audio samples (stereo interleaved)
    uint32_t sample_count;  // Total samples (left + right)
    uint32_t frame_count;   // Number of stereo frames
    uint32_t sample_rate;   // Sample rate (Hz)
    float duration;         // Duration in seconds
} audio_data_t;

static audio_data_t audio_data = {0};

// Simple audio level calculation (RMS)
float calculate_audio_level_at_frame(int frame_number, float fps) {
    if (!audio_data.samples || audio_data.frame_count == 0) {
        return 0.2f; // Default level
    }
    
    float time_seconds = frame_number / fps;
    uint32_t sample_index = (uint32_t)(time_seconds * audio_data.sample_rate);
    
    if (sample_index >= audio_data.frame_count) {
        sample_index = audio_data.frame_count - 1;
    }
    
    // Calculate RMS over a small window
    uint32_t window_size = audio_data.sample_rate / 30; // ~33ms window
    uint32_t start_sample = (sample_index > window_size/2) ? sample_index - window_size/2 : 0;
    uint32_t end_sample = start_sample + window_size;
    if (end_sample > audio_data.frame_count) {
        end_sample = audio_data.frame_count;
        start_sample = (end_sample > window_size) ? end_sample - window_size : 0;
    }
    
    float sum_squares = 0.0f;
    uint32_t count = 0;
    
    for (uint32_t i = start_sample; i < end_sample; i++) {
        float left = audio_data.samples[i * 2] / 32768.0f;
        float right = audio_data.samples[i * 2 + 1] / 32768.0f;
        float mono = (left + right) * 0.5f;
        sum_squares += mono * mono;
        count++;
    }
    
    if (count == 0) return 0.2f;
    
    float rms = sqrtf(sum_squares / count);
    return fminf(1.0f, fmaxf(0.0f, rms * 3.0f)); // Scale and clamp
}

// Load WAV file
bool load_wav_file(const char* filename) {
    FILE* file = fopen(filename, "rb");
    if (!file) {
        printf("Failed to open WAV file: %s\n", filename);
        return false;
    }
    
    wav_header_t header;
    if (fread(&header, sizeof(header), 1, file) != 1) {
        printf("Failed to read WAV header\n");
        fclose(file);
        return false;
    }
    
    // Basic validation
    if (strncmp(header.riff, "RIFF", 4) != 0 || 
        strncmp(header.wave, "WAVE", 4) != 0 ||
        strncmp(header.data, "data", 4) != 0) {
        printf("Invalid WAV file format\n");
        fclose(file);
        return false;
    }
    
    if (header.audio_format != 1 || header.bits_per_sample != 16) {
        printf("Unsupported WAV format (need 16-bit PCM)\n");
        fclose(file);
        return false;
    }
    
    // Allocate and read sample data
    uint32_t sample_count = header.data_size / 2; // 16-bit samples
    audio_data.samples = malloc(header.data_size);
    if (!audio_data.samples) {
        printf("Failed to allocate memory for samples\n");
        fclose(file);
        return false;
    }
    
    if (fread(audio_data.samples, header.data_size, 1, file) != 1) {
        printf("Failed to read sample data\n");
        free(audio_data.samples);
        audio_data.samples = NULL;
        fclose(file);
        return false;
    }
    
    audio_data.sample_count = sample_count;
    audio_data.frame_count = sample_count / header.num_channels;
    audio_data.sample_rate = header.sample_rate;
    audio_data.duration = (float)audio_data.frame_count / header.sample_rate;
    
    fclose(file);
    
    printf("Loaded WAV: %d samples, %.2f seconds, %d Hz\n", 
           audio_data.frame_count, audio_data.duration, audio_data.sample_rate);
    
    return true;
}

// Additional functions needed by audio_visual_bridge.c
float get_audio_duration() {
    return audio_data.duration;
}

bool is_audio_finished() {
    return false; // For frame generation, never consider audio "finished"
}

void print_audio_info() {
    printf("Audio info: %.2f seconds, %d Hz, %d frames\n", 
           audio_data.duration, audio_data.sample_rate, audio_data.frame_count);
}

float get_audio_rms_for_frame(int frame_number, float fps) {
    return calculate_audio_level_at_frame(frame_number, fps);
}

float get_max_rms() {
    return 1.0f; // Assume normalized
}

float get_audio_bpm() {
    return 120.0f; // Default BPM
}

// Cleanup
void cleanup_audio_data() {
    if (audio_data.samples) {
        free(audio_data.samples);
        audio_data.samples = NULL;
    }
    audio_data.sample_count = 0;
    audio_data.frame_count = 0;
    audio_data.sample_rate = 0;
    audio_data.duration = 0.0f;
}

---END---

=== FILE: generate_nft.sh ===
---BEGIN---
#!/bin/bash

# generate_nft.sh - NotDeafBeef NFT Generation Pipeline
# Generates complete audio-visual NFT from Ethereum transaction hash
# 
# Usage: ./generate_nft.sh <tx_hash> [output_dir]
# Example: ./generate_nft.sh 0xDEADBEEF123456789ABCDEF output/

set -e  # Exit on any error

# Configuration
TX_HASH=${1:-"0xDEADBEEF"}
OUTPUT_DIR=${2:-"./nft_output"}
SEED="$TX_HASH"  # Use full transaction hash as seed
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
SCRIPT_DIR=$(pwd)  # Store script directory for absolute paths

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit 1
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Validate inputs
if [ -z "$TX_HASH" ]; then
    error "Transaction hash required. Usage: $0 <tx_hash> [output_dir]"
fi

# Create output directory structure
mkdir -p "$OUTPUT_DIR"
mkdir -p "$OUTPUT_DIR/temp"

# File names
AUDIO_BASE="$OUTPUT_DIR/temp/${SEED}_base.wav"
AUDIO_LONG="$OUTPUT_DIR/${TX_HASH}_audio.wav"
VIDEO_FINAL="$OUTPUT_DIR/${TX_HASH}_final.mp4"
METADATA_FILE="$OUTPUT_DIR/${TX_HASH}_metadata.json"

log "🎨 Starting NFT generation for transaction: $TX_HASH"
log "   Seed: $SEED"
log "   Output: $OUTPUT_DIR"

# Step 1: Generate base audio segment
log "🎵 Step 1: Generating base audio segment..."
cd src/c

# Build if necessary
if [ ! -f bin/segment ]; then
    log "   Building audio engine..."
    make segment USE_ASM=1 VOICE_ASM="GENERATOR_ASM KICK_ASM SNARE_ASM HAT_ASM MELODY_ASM LIMITER_ASM FM_VOICE_ASM" || error "Failed to build audio engine"
fi

# Generate base segment
log "   Synthesizing audio with seed $SEED..."
./bin/segment "$SEED" > /dev/null 2>&1

# Find generated file
SEGMENT_FILE=$(ls seed_0x*.wav 2>/dev/null | head -1)
if [ ! -f "$SEGMENT_FILE" ]; then
    error "Audio generation failed - no output file found"
fi

# Move to our naming convention
mv "$SEGMENT_FILE" "../../$AUDIO_BASE"
cd ../..

AUDIO_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_BASE" 2>/dev/null)
success "Generated base audio: ${AUDIO_DURATION}s"

# Step 2: Create extended audio (6x concatenation ≈ 25 seconds)
log "🔄 Step 2: Creating extended audio track..."

# Create temp directory for concatenation
TEMP_CONCAT="$OUTPUT_DIR/temp/concat"
mkdir -p "$TEMP_CONCAT"

# Create 6 copies for concatenation
for i in {1..6}; do
    cp "$AUDIO_BASE" "$TEMP_CONCAT/segment_$i.wav"
done

# Concatenate with sox (fallback to ffmpeg if sox not available)
if command -v sox >/dev/null 2>&1; then
    log "   Using sox for concatenation..."
    sox "$TEMP_CONCAT"/segment_*.wav "$AUDIO_LONG" 2>/dev/null || error "Sox concatenation failed"
else
    log "   Using ffmpeg for concatenation..."
    # Create file list for ffmpeg
    for i in {1..6}; do
        echo "file '$TEMP_CONCAT/segment_$i.wav'" >> "$TEMP_CONCAT/filelist.txt"
    done
    ffmpeg -f concat -safe 0 -i "$TEMP_CONCAT/filelist.txt" -c copy "$AUDIO_LONG" -y >/dev/null 2>&1 || error "FFmpeg concatenation failed"
fi

EXTENDED_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$AUDIO_LONG" 2>/dev/null)
success "Created extended audio: ${EXTENDED_DURATION}s"

# Step 3: Generate visual frames
log "🖼️  Step 3: Generating visual frames..."

# Build frame generator if needed
if [ ! -f generate_frames ]; then
    log "   Building frame generator..."
    make generate_frames || error "Failed to build frame generator"
fi

# Generate frames (change to output d[CHUNK 3 OF 3]
BUNDLE_6_C_BRIDGE - PART 3
Concatenate all chunks in order to reconstruct.

irectory to ensure frames are created in the right place)
log "   Rendering frames with seed $SEED..."
AUDIO_LONG_ABS="$SCRIPT_DIR/$AUDIO_LONG"  # Convert to absolute path
cd "$OUTPUT_DIR"
"$SCRIPT_DIR/generate_frames" "$AUDIO_LONG_ABS" "$SEED" > "temp/frame_log.txt" 2>&1
cd "$SCRIPT_DIR"

# Check if frames were generated
FRAME_COUNT=$(ls "$OUTPUT_DIR"/frame_*.ppm 2>/dev/null | wc -l)
if [ "$FRAME_COUNT" -eq 0 ]; then
    error "Frame generation failed - no frames found"
fi

success "Generated $FRAME_COUNT frames"

# Step 4: Create final video (run from output directory where frames are)
log "🎬 Step 4: Creating final video..."
AUDIO_LONG_ABS="$SCRIPT_DIR/$AUDIO_LONG"  # Convert to absolute path
cd "$OUTPUT_DIR"

ffmpeg -r 60 -i frame_%04d.ppm \
       -i "$AUDIO_LONG_ABS" \
       -c:v libx264 -c:a aac \
       -pix_fmt yuv420p \
       -shortest "$VIDEO_FINAL" \
       -y >/dev/null 2>&1 || error "Video creation failed"

cd "$SCRIPT_DIR"

# Verify video was created
if [ ! -f "$VIDEO_FINAL" ]; then
    error "Video file was not created"
fi

VIDEO_SIZE=$(du -h "$VIDEO_FINAL" | cut -f1)
VIDEO_DURATION=$(ffprobe -v quiet -show_entries format=duration -of csv=p=0 "$VIDEO_FINAL" 2>/dev/null)
success "Created final video: ${VIDEO_DURATION}s, $VIDEO_SIZE"

# Step 5: Generate metadata
log "📋 Step 5: Generating metadata..."

cat > "$METADATA_FILE" << EOF
{
  "transaction_hash": "$TX_HASH",
  "seed": "$SEED", 
  "audio_duration": $EXTENDED_DURATION,
  "video_duration": $VIDEO_DURATION,
  "video_size": "$VIDEO_SIZE",
  "video_resolution": "800x600",
  "frame_rate": 60,
  "frame_count": $FRAME_COUNT,
  "generated_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "assembly_version": "v1.0",
  "reproducible": true,
  "files": {
    "video": "$(basename "$VIDEO_FINAL")",
    "audio": "$(basename "$AUDIO_LONG")", 
    "metadata": "$(basename "$METADATA_FILE")"
  }
}
EOF

success "Generated metadata"

# Step 6: Cleanup temporary files
log "🧹 Step 6: Cleaning up..."
rm -f frame_*.ppm
rm -rf "$OUTPUT_DIR/temp"

# Final summary
log "✨ NFT Generation Complete!"
echo ""
echo "📁 Generated Files:"
echo "   🎬 Video: $VIDEO_FINAL"
echo "   🎵 Audio: $AUDIO_LONG"  
echo "   📋 Metadata: $METADATA_FILE"
echo ""
echo "🔍 NFT Details:"
echo "   📝 Transaction: $TX_HASH"
echo "   🎲 Seed: $SEED"
echo "   ⏱️  Duration: ${VIDEO_DURATION}s"
echo "   📦 Size: $VIDEO_SIZE"
echo ""
echo "✅ Ready for NFT marketplace upload!"
echo ""

# Verification hint
echo "🔄 To verify reproducibility, run:"
echo "   ./verify_nft.sh $TX_HASH $VIDEO_FINAL"

---END---

=== FILE: Makefile ===
---BEGIN---
# NotDeafbeef - Root Build System
# Orchestrates builds for both C and Assembly implementations

# Default target builds the stable configuration
all: c-build

# Build C implementation (stable)
c-build:
	$(MAKE) -C src/c

# Export timeline JSON for a given seed (usage: make export_timeline SEED=0xDEADBEEF OUT=path.json)
export_timeline:
	$(MAKE) -C src/c bin/export_timeline
	cd src/c && ./bin/export_timeline $(SEED) $(OUT)

# Visual assembly object files
visual_core.o: src/asm/visual/visual_core.s
	gcc -c src/asm/visual/visual_core.s -o visual_core.o

drawing.o: src/asm/visual/drawing.s
	gcc -c src/asm/visual/drawing.s -o drawing.o

ascii_renderer.o: src/asm/visual/ascii_renderer.s
	gcc -c src/asm/visual/ascii_renderer.s -o ascii_renderer.o

particles.o: src/asm/visual/particles.s
	gcc -c src/asm/visual/particles.s -o particles.o

bass_hits.o: src/asm/visual/bass_hits.s
	gcc -c src/asm/visual/bass_hits.s -o bass_hits.o

terrain.o: src/asm/visual/terrain.s
	gcc -c src/asm/visual/terrain.s -o terrain.o

glitch_system.o: src/asm/visual/glitch_system.s
	gcc -c src/asm/visual/glitch_system.s -o glitch_system.o

# Build visual system with ASM components
vis-build: visual_core.o drawing.o ascii_renderer.o particles.o bass_hits.o terrain.o glitch_system.o
	mkdir -p bin
	gcc -o bin/vis_main src/vis_main.c src/visual_c_stubs.c src/audio_visual_bridge.c src/wav_reader.c visual_core.o drawing.o ascii_renderer.o particles.o bass_hits.o terrain.o glitch_system.o -Iinclude $(shell pkg-config --cflags --libs sdl2) -lm

# Frame generator (no SDL2 required)
generate_frames: visual_core.o drawing.o ascii_renderer.o particles.o bass_hits.o terrain.o glitch_system.o
	gcc -o generate_frames generate_frames.c src/audio_visual_bridge.c src/deterministic_prng.c src/timeline_reader.c simple_wav_reader.c visual_core.o drawing.o ascii_renderer.o particles.o bass_hits.o terrain.o glitch_system.o -Iinclude -Isrc/include -lm

# Build audio system only (for protection verification)
audio:
	$(MAKE) -C src/c segment USE_ASM=1 VOICE_ASM="GENERATOR_ASM KICK_ASM SNARE_ASM HAT_ASM MELODY_ASM LIMITER_ASM"

# Generate test audio files  
test-audio:
	python3 tools/generate_test_wavs.py

# NEW: Generate comprehensive WAV tests for all sounds in both C and ASM
test-comprehensive:
	python3 tools/generate_comprehensive_tests.py

# NEW: Compare C vs ASM WAV files
compare:
	python3 tools/compare_c_vs_asm.py

# NEW: Play specific sound for audition (usage: make play SOUND=kick)
play:
ifndef SOUND
	@echo "Usage: make play SOUND=<sound_name>"
	@echo "Example: make play SOUND=kick"
else
	python3 tools/compare_c_vs_asm.py --play $(SOUND)
endif

# Run test suite
test:
	pytest tests/

# Clean all build artifacts
clean:
	$(MAKE) -C src/c clean
	rm -rf output/
	find . -name "*.o" -delete
	find . -name "*.dSYM" -delete
	rm -f generate_frames 2>/dev/null || true

# Generate a demo audio segment
demo:
	$(MAKE) -C src/c segment
	@echo "Generated demo audio: src/c/seed_0xcafebabe.wav"

# Quick verification that everything works
verify: c-build test-audio
	@echo "✅ NotDeafbeef verification complete!"

# NEW: Full verification including comprehensive tests
verify-full: c-build test-comprehensive compare
	@echo "✅ NotDeafbeef full verification complete!"
	@echo "Check the comparison output above for any issues."

.PHONY: all c-build vis-build audio test-audio test-comprehensive compare play test clean demo verify verify-full

---END---

